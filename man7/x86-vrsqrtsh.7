'\" t
.nh
.TH "X86-VRSQRTSH" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
VRSQRTSH - COMPUTE APPROXIMATE RECIPROCAL OF SQUARE ROOT OF SCALAR FP16 VALUE
.TS
allbox;
l l l l l 
l l l l l .
\fBInstruction En bit Mode Flag Support Instruction En bit Mode Flag Support 64/32 CPUID Feature Instruction En bit Mode Flag CPUID Feature Instruction En bit Mode Flag Op/ 64/32 CPUID Feature Instruction En bit Mode Flag 64/32 CPUID Feature Instruction En bit Mode Flag CPUID Feature Instruction En bit Mode Flag Op/ 64/32 CPUID Feature\fP	\fB\fP	\fBSupport\fP	\fB\fP	\fBDescription\fP
T{
EVEX.LLIG.66.MAP6.W0 4F /r VRSQRTSH xmm1{k1}{z}, xmm2, xmm3/m16
T}	A	V/V	AVX512-FP16	T{
Compute the approximate reciprocal square root of the FP16 value in xmm3/m16 and store the result in the low word element of xmm1 subject to writemask k1. Bits 127:16 of xmm2 are copied to xmm1[127:16]\&.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING  href="vrsqrtsh.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	Scalar	ModRM:reg (w)	VEX.vvvv (r)	ModRM:r/m (r)	N/A
.TE

.SS DESCRIPTION
This instruction performs the computation of the approximate reciprocal
square-root of the low FP16 value in the second source operand (the
third operand) and stores the result in the low word element of the
destination operand (the first operand) according to the writemask k1.

.PP
The maximum relative error for this approximation is less than
2−11 + 2−14\&.

.PP
Bits 127:16 of the destination operand are copied from the corresponding
bits of the first source operand. Bits MAXVL−1:128 of the destination
operand are zeroed.

.PP
For special cases, see Table 5-38
\[la]vrsqrtph.html#tbl\-5\-38\[ra]\&.

.SS OPERATION
.SS VRSQRTSH DEST{K1}, SRC1, SRC2  href="vrsqrtsh.html#vrsqrtsh-dest-k1---src1--src2"
class="anchor">¶

.EX
VL = 128, 256 or 512
KL := VL/16
IF k1[0] or *no writemask*:
    DEST.fp16[0] := APPROXIMATE(1.0 / SQRT(src2.fp16[0]))
ELSE IF *zeroing*:
    DEST.fp16[0] := 0
//else DEST.fp16[0] remains unchanged
DEST[127:16] := src1[127:16]
DEST[MAXVL-1:128] := 0
.EE

.SS INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="vrsqrtsh.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
VRSQRTSH __m128h _mm_mask_rsqrt_sh (__m128h src, __mmask8 k, __m128h a, __m128h b);

VRSQRTSH __m128h _mm_maskz_rsqrt_sh (__mmask8 k, __m128h a, __m128h b);

VRSQRTSH __m128h _mm_rsqrt_sh (__m128h a, __m128h b);
.EE

.SS SIMD FLOATING-POINT EXCEPTIONS  href="vrsqrtsh.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
None.

.SS OTHER EXCEPTIONS
EVEX-encoded instruction, see Table
2-58, “Type E10 Class Exception Conditions.”

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
