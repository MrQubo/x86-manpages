'\" t
.nh
.TH "X86-EAUG" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
EAUG - ADD A PAGE TO AN INITIALIZED ENCLAVE
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
EAX = 0DH ENCLS[EAUG]	IR	V/V	SGX2	T{
This leaf function adds a page to an initialized enclave.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l 
l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP
Op/En	EAX	RBX	RCX
IR	EAUG (In)	Address of a PAGEINFO (In)	T{
Address of the destination EPC page (In)
T}
.TE

.SS DESCRIPTION
This leaf function zeroes a page of EPC memory, associates the EPC page
with an SECS page residing in the EPC, and stores the linear address and
security attributes in the EPCM. As part of the association, the
security attributes are configured to prevent access to the EPC page
until a corresponding invocation of the EACCEPT leaf or EACCEPTCOPY leaf
confirms the addition of the new page into the enclave. This instruction
can only be executed when current privilege level is 0.

.PP
RBX contains the effective address of a PAGEINFO structure while RCX
contains the effective address of an EPC page. The table below provides
additional information on the memory parameter of the EAUG leaf
function.

.SH EAUG MEMORY PARAMETER SEMANTICS
.TS
allbox;
l l l l l 
l l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP
PAGEINFO	PAGEINFO.SECS	PAGEINFO.SRCPGE	PAGEINFO.SECINFO	EPCPAGE
T{
Read access permitted by Non Enclave
T}	T{
Read/Write access permitted by Enclave
T}	Must be zero	T{
Read access permitted by Non Enclave
T}	T{
Write access permitted by Enclave
T}
.TE

.PP
The instruction faults if any of the following:

.SH EAUG FAULTING CONDITIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
T{
The operands are not properly aligned.
T}	T{
Unsupported security attributes are set.
T}
Refers to an invalid SECS.	T{
Reference is made to an SECS that is locked by another thread.
T}
T{
The EPC page is locked by another thread.
T}	T{
RCX does not contain an effective address of an EPC page.
T}
The EPC page is already valid.	T{
The specified enclave offset is outside of the enclave address space.
T}
The SECS has been initialized.	
.TE

.SS CONCURRENCY RESTRICTIONS
.SS OPERATION
.SH TEMP VARIABLES IN EAUG OPERATIONAL FLOW  href="eaug.html#temp-variables-in-eaug-operational-flow"
class="anchor">¶

.TS
allbox;
l l l l 
l l l l .
\fBName\fP	\fBType\fP	\fBSize (bits)\fP	\fBDescription\fP
TMP_SECS	Effective Address	32/64	T{
Effective address of the SECS destination page.
T}
TMP_SECINFO	Effective Address	32/64	T{
Effective address of an SECINFO structure which contains security attributes of the page to be added.
T}
SCRATCH_SECINFO	SECINFO	512	T{
Scratch storage for holding the contents of DS:TMP_SECINFO.
T}
TMP_LINADDR	Unsigned Integer	64	T{
Holds the linear address to be stored in the EPCM and used to calculate TMP_ENCLAVEOFFSET.
T}
.TE

.PP
IF (DS:RBX is not 32Byte Aligned)

.PP
THEN #GP(0); FI;

.PP
IF (DS:RCX is not 4KByte Aligned)

.PP
THEN #GP(0); FI;

.PP
IF (DS:RCX does not resolve within an EPC)

.PP
THEN #PF(DS:RCX); FI;

.PP
TMP_SECS := DS:RBX.SECS;

.PP
TMP_SECINFO := DS:RBX.SECINFO;

.PP
IF (DS:RBX.SECINFO is not 0)

.PP
THEN

.PP
IF (DS:TMP_SECINFO is not 64B aligned)

.PP
THEN #GP(0); FI;

.PP
FI;

.PP
TMP_LINADDR := DS:RBX.LINADDR;

.PP
IF ( DS:TMP_SECS is not 4KByte aligned or TMP_LINADDR is not 4KByte
aligned )

.PP
THEN #GP(0); FI;

.PP
IF DS:RBX.SRCPAGE is not 0

.PP
THEN #GP(0); FI;

.PP
IF (DS:TMP_SECS does not resolve within an EPC)

.PP
THEN #PF(DS:TMP_SECS); FI;

.PP
(* Check the EPC page for concurrency *)

.PP
IF (EPC page in use)

.PP
THEN

.PP
IF (&lt;&lt;VMX non-root operation&gt;&gt; AND
&lt;&lt;ENABLE_EPC_VIRTUALIZATION_EXTENSIONS&gt;&gt;)

.PP
THEN

.PP
VMCS.Exit_reason := SGX_CONFLICT;

.PP
VMCS.Exit_qualification.code := EPC_PAGE_CONFLICT_EXCEPTION;

.PP
VMCS.Exit_qualification.error := 0;

.PP
VMCS.Guest-physical_address := &lt;&lt; translation of DS:RCX produced
by paging &gt;&gt;;

.PP
VMCS.Guest-linear_address := DS:RCX;

.PP
Deliver VMEXIT;

.PP
ELSE

.PP
#GP(0);

.PP
FI;

.PP
FI:

.PP
IF (EPCM(DS:RCX).VALID ≠ 0)

.PP
THEN #PF(DS:RCX); FI;

.PP
(* copy SECINFO contents into a scratch SECINFO *)

.PP
IF (DS:RBX.SECINFO is 0)

.PP
THEN

.PP
(* allocate and initialize a new scratch SECINFO structure *)

.PP
SCRATCH_SECINFO.PT := PT_REG;

.PP
SCRATCH_SECINFO.R := 1;

.PP
SCRATCH_SECINFO.W := 1;

.PP
SCRATCH_SECINFO.X := 0;

.PP
&lt;&lt; zero out remaining fields of SCRATCH_SECINFO &gt;&gt;

.PP
ELSE

.PP
(* copy SECINFO contents into scratch SECINFO *)

.PP
SCRATCH_SECINFO := DS:TMP_SECINFO;

.PP
(* check SECINFO flags for misconfiguration *)

.PP
(* reserved flags must be zero *)

.PP
(* SECINFO.FLAGS.PT must either be PT_SS_FIRST, or PT_SS_REST *)

.PP
IF ( (SCRATCH_SECINFO reserved fields are not 0) or

.PP
CPUID.(EAX=12H, ECX=1):EAX[6] is 0) OR

.PP
(SCRATCH_SECINFO.PT is not PT_SS_FIRST, or PT_SS_REST) OR

.PP
( (SCRATCH_SECINFO.FLAGS.R is 0) OR (SCRATCH_SECINFO.FLAGS.W is 0) OR
(SCRATCH_SECINFO.FLAGS.X is 1) ) )

.PP
THEN #GP(0); FI;

.PP
FI;

.PP
(* Check if PT_SS_FIRST/PT_SS_REST page types are requested then
CR4.CET must be 1 *)

.PP
IF ( (SCRATCH_SECINFO.PT is PT_SS_FIRST OR SCRATCH_SECINFO.PT is
PT_SS_REST) AND CR4.CET == 0 )

.PP
THEN #GP(0); FI;

.PP
(* Check the SECS for concurrency *)

.PP
IF (SECS is not available for EAUG)

.PP
THEN #GP(0); FI;

.PP
IF (EPCM(DS:TMP_SECS).VALID = 0 or EPCM(DS:TMP_SECS).PT ≠ PT_SECS)

.PP
THEN #PF(DS:TMP_SECS); FI;

.PP
(* Check if the enclave to which the page will be added is in the
Initialized state *)

.PP
IF (DS:TMP_SECS is not initialized)

.PP
THEN #GP(0); FI;

.PP
(* Check the enclave offset is within the enclave linear address space
*) IF ( (TMP_LINADDR &lt; DS:TMP_SECS.BASEADDR) or (TMP_LINADDR ≥
DS:TMP_SECS.BASEADDR + DS:TMP_SECS.SIZE) ) THEN #GP(0); FI;

.PP
IF ( (SCRATCH_SECINFO.PT is PT_SS_FIRST OR SCRATCH_SECINFO.PT is
PT_SS_REST) )

.PP
THEN

.PP
(* SS pages cannot created on first or last page of ELRANGE *)

.PP
IF ( TMP_LINADDR == DS:TMP_SECS.BASEADDR OR

.PP
TMP_LINADDR == (DS:TMP_SECS.BASEADDR + DS:TMP_SECS.SIZE - 0x1000) )

.PP
THEN

.PP
#GP(0); FI;

.PP
FI;

.PP
(* Clear the content of EPC page*)

.PP
DS:RCX[32767:0] := 0;

.PP
IF (CPUID.(EAX=07H, ECX=0H):ECX[CET_SS] = 1)

.PP
THEN

.PP
(* set up shadow stack RSTORSSP token *)

.PP
IF (SCRATCH_SECINFO.PT is PT_SS_FIRST)

.PP
THEN

.PP
DS:RCX[0xFF8] := (TMP_LINADDR + 0x1000) |
TMP_SECS.ATTRIBUTES.MODE64BIT; FI;

.PP
FI;

.PP
(* Set EPCM security attributes *)

.PP
EPCM(DS:RCX).R := SCRATCH_SECINFO.FLAGS.R;

.PP
EPCM(DS:RCX).W := SCRATCH_SECINFO.FLAGS.W;

.PP
EPCM(DS:RCX).X := SCRATCH_SECINFO.FLAGS.X;

.PP
EPCM(DS:RCX).PT := SCRATCH_SECINFO.FLAGS.PT;

.PP
EPCM(DS:RCX).ENCLAVEADDRESS := TMP_LINADDR;

.PP
EPCM(DS:RCX).BLOCKED := 0;

.PP
EPCM(DS:RCX).PENDING := 1;

.PP
EPCM(DS:RCX).MODIFIED := 0;

.PP
EPCM(DS:RCX).PR := 0;

.PP
(* associate the EPCPAGE with the SECS by storing the SECS identifier
of DS:TMP_SECS *)

.PP
Update EPCM(DS:RCX) SECS identifier to reference DS:TMP_SECS
identifier;

.PP
(* Set EPCM valid fields *)

.PP
EPCM(DS:RCX).VALID := 1;

.SS FLAGS AFFECTED
None

.SS PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If a memory operand effective address is outside the DS segment limit.
T}
	T{
If a memory operand is not properly aligned.
T}
	If a memory operand is locked.
	T{
If the enclave is not initialized.
T}
#PF(error	T{
code) If a page fault occurs in accessing memory operands.
T}
.TE

.SS 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If a memory operand is non-canonical form.
T}
	T{
If a memory operand is not properly aligned.
T}
	If a memory operand is locked.
	T{
If the enclave is not initialized.
T}
#PF(error	T{
code) If a page fault occurs in accessing memory operands.
T}
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
