'\" t
.nh
.TH "X86-EENTER" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
EENTER - ENTERS AN ENCLAVE
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
EAX = 02H ENCLU[EENTER]	IR	V/V	SGX1	T{
This leaf function is used to enter an enclave.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP
Op/En	EAX		RBX	RCX	
IR	EENTER (In)	Content of RBX.CSSA (Out)	Address of a TCS (In)	Address of AEP (In)	T{
Address of IP following EENTER (Out)
T}
.TE

.SS DESCRIPTION
The ENCLU[EENTER] instruction transfers execution to an enclave. At
the end of the instruction, the logical processor is executing in
enclave mode at the RIP computed as EnclaveBase + TCS.OENTRY. If the
target address is not within the CS segment (32-bit) or is not canonical
(64-bit), a #GP(0) results.

.SH EENTER MEMORY PARAMETER SEMANTICS  href="eenter.html#eenter-memory-parameter-semantics"
class="anchor">¶

.TS
allbox;
l 
l .
\fB\fP
TCS
Enclave access
.TE

.PP
EENTER is a serializing instruction. The instruction faults if any of
the following occurs:

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
T{
Address in RBX is not properly aligned.
T}	T{
Any TCS.FLAGS’s must-be-zero bit is not zero.
T}
T{
TCS pointed to by RBX is not valid or available or locked.
T}	T{
Current 32/64 mode does not match the enclave mode in SECS.ATTRIBUTES.MODE64.
T}
The SECS is in use.	T{
Either of TCS-specified FS and GS segment is not a subsets of the current DS segment.
T}
T{
Any one of DS, ES, CS, SS is not zero.
T}	T{
If XSAVE available, CR4.OSXSAVE = 0, but SECS.ATTRIBUTES.XFRM ≠ 3.
T}
CR4.OSFXSR ≠ 1.	T{
If CR4.OSXSAVE = 1, SECS.ATTRIBUTES.XFRM is not a subset of XCR0.
T}
T{
If SECS.ATTRIBUTES.AEXNOTIFY ≠ TCS.FLAGS.AEXNOTIFY and TCS.FLAGS.DBGOPTIN = 0.
T}	
.TE

.PP
The following operations are performed by EENTER:
.IP \(bu 2
RSP and RBP are saved in the current SSA frame on EENTER and are
automatically restored on EEXIT or interrupt.
.IP \(bu 2
The AEP contained in RCX is stored into the TCS for use by AEXs.FS
and GS (including hidden portions) are saved and new values are
constructed using TCS.OFSBASE/GSBASE (32 and 64-bit mode) and
TCS.OFSLIMIT/GSLIMIT (32-bit mode only). The resulting segments must
be a subset of the DS segment.
.IP \(bu 2
If CR4.OSXSAVE == 1, XCR0 is saved and replaced by
SECS.ATTRIBUTES.XFRM. The effect of RFLAGS.TF depends on whether the
enclave entry is opt-in or opt-out (see Section 40.1.2):
.RS
.IP \(bu 2
On opt-out entry, TF is saved and cleared (it is restored on
EEXIT or AEX). Any attempt to set TF via a POPF instruction
while inside the enclave clears TF (see Section 40.2.5).
.IP \(bu 2
On opt-out entry, TF is saved and cleared (it is restored on
EEXIT or AEX). Any attempt to set TF via a POPF instruction
while inside the enclave clears TF (see Section 40.2.5).
.IP \(bu 2
On opt-in entry, a single-step debug exception is pended on the
instruction boundary immediately after EENTER (see Section
40.2.2).
.IP \(bu 2
On opt-in entry, a single-step debug exception is pended on the
instruction boundary immediately after EENTER (see Section
40.2.2).
.RE
.IP \(bu 2
All code breakpoints that do not overlap with ELRANGE are also
suppressed. If the entry is an opt-out entry, all code and data
breakpoints that overlap with the ELRANGE are suppressed.
.IP \(bu 2
On opt-out entry, a number of performance monitoring counters and
behaviors are modified or suppressed (see Section 40.2.3):
.RS
.IP \(bu 2
All performance monitoring activity on the current thread is
suppressed except for incrementing and firing of FIXED_CTR1 and
FIXED_CTR2.
.IP \(bu 2
All performance monitoring activity on the current thread is
suppressed except for incrementing and firing of FIXED_CTR1 and
FIXED_CTR2.
.IP \(bu 2
PEBS is suppressed.
.IP \(bu 2
PEBS is suppressed.
.IP \(bu 2
AnyThread counting on other threads is demoted to MyThread mode
and IA32_PERF_GLOBAL_STATUS[60] on that thread is set
.IP \(bu 2
AnyThread counting on other threads is demoted to MyThread mode
and IA32_PERF_GLOBAL_STATUS[60] on that thread is set
.IP \(bu 2
If the opt-out entry on a hardware thread results in suppression
of any performance monitoring, then the processor sets
IA32_PERF_GLOBAL_STATUS[60] and
IA32_PERF_GLOBAL_STATUS[63]\&.
.IP \(bu 2
If the opt-out entry on a hardware thread results in suppression
of any performance monitoring, then the processor sets
IA32_PERF_GLOBAL_STATUS[60] and
IA32_PERF_GLOBAL_STATUS[63]\&.
.RE

.SS CONCURRENCY RESTRICTIONS
.SS OPERATION
.SH TEMP VARIABLES IN EENTER OPERATIONAL FLOW  href="eenter.html#temp-variables-in-eenter-operational-flow"
class="anchor">¶

.TS
allbox;
l l l l 
l l l l .
\fBName\fP	\fBType\fP	\fBSize (Bits)\fP	\fBDescription\fP
TMP_FSBASE	Effective Address	32/64	T{
Proposed base address for FS segment.
T}
TMP_GSBASE	Effective Address	32/64	T{
Proposed base address for FS segment.
T}
TMP_FSLIMIT	Effective Address	32/64	T{
Highest legal address in proposed FS segment.
T}
TMP_GSLIMIT	Effective Address	32/64	T{
Highest legal address in proposed GS segment.
T}
TMP_XSIZE	integer	64	T{
Size of XSAVE area based on SECS.ATTRIBUTES.XFRM.
T}
TMP_SSA_PAGE	Effective Address	32/64	T{
Pointer used to iterate over the SSA pages in the current frame.
T}
TMP_GPR	Effective Address	32/64	T{
Address of the GPR area within the current SSA frame.
T}
.TE

.PP
TMP_MODE64 := ((IA32_EFER.LMA = 1) && (CS.L = 1));

.PP
(* Make sure DS is usable, expand up *)

.PP
IF (TMP_MODE64 = 0 and (DS not usable or ( ( DS[S] = 1) and (DS[bit
11] = 0) and DS[bit 10] = 1) ) )

.PP
THEN #GP(0); FI;

.PP
(* Check that CS, SS, DS, ES.base is 0 *)

.PP
IF (TMP_MODE64 = 0)

.PP
THEN

.PP
IF(CS.base ≠ 0 or DS.base ≠ 0) #GP(0); FI;

.PP
IF(ES usable and ES.base ≠ 0) #GP(0); FI;

.PP
IF(SS usable and SS.base ≠ 0) #GP(0); FI;

.PP
IF(SS usable and SS.B = 0) #GP(0); FI;

.PP
FI;

.PP
IF (DS:RBX is not 4KByte Aligned)

.PP
THEN #GP(0); FI;

.PP
IF (DS:RBX does not resolve within an EPC)

.PP
THEN #PF(DS:RBX); FI;

.PP
(* Check AEP is canonical*)

.PP
IF (TMP_MODE64 = 1 and (CS:RCX is not canonical) )

.PP
THEN #GP(0); FI;

.PP
(* Check concurrency of TCS operation*)

.PP
IF (Other Intel SGX instructions are operating on TCS)

.PP
THEN #GP(0); FI;

.PP
(* TCS verification *)

.PP
IF (EPCM(DS:RBX).VALID = 0)

.PP
THEN #PF(DS:RBX); FI;

.PP
IF (EPCM(DS:RBX).BLOCKED = 1)

.PP
THEN #PF(DS:RBX); FI;

.PP
IF ( (EPCM(DS:RBX).ENCLAVEADDRESS ≠ DS:RBX) or (EPCM(DS:RBX).PT ≠
PT_TCS) )

.PP
THEN #PF(DS:RBX); FI;

.PP
IF ((EPCM(DS:RBX).PENDING = 1) or (EPCM(DS:RBX).MODIFIED = 1))

.PP
THEN #PF(DS:RBX); FI;

.PP
IF ( (DS:RBX).OSSA is not 4KByte Aligned)

.PP
THEN #GP(0); FI;

.PP
(* Check proposed FS and GS *)

.PP
IF ( ( (DS:RBX).OFSBASE is not 4KByte Aligned) or ( (DS:RBX).OGSBASE is
not 4KByte Aligned) )

.PP
THEN #GP(0); FI;

.PP
(* Get the SECS for the enclave in which the TCS resides *)

.PP
TMP_SECS := Address of SECS for TCS;

.PP
(* Ensure that the FLAGS field in the TCS does not have any reserved
bits set *)

.PP
IF ( ( (DS:RBX).FLAGS & FFFFFFFFFFFFFFFCH) ≠ 0)

.PP
THEN #GP(0); FI;

.PP
(* SECS must exist and enclave must have previously been EINITted *)

.PP
IF (the enclave is not already initialized)

.PP
THEN #GP(0); FI;

.PP
(* make sure the logical processor’s operating mode matches the enclave
*)

.PP
IF ( (TMP_MODE64 ≠ TMP_SECS.ATTRIBUTES.MODE64BIT) )

.PP
THEN #GP(0); FI;

.PP
IF (CR4.OSFXSR = 0)

.PP
THEN #GP(0); FI;

.PP
(* Check for legal values of SECS.ATTRIBUTES.XFRM *)

.PP
IF (CR4.OSXSAVE = 0)

.PP
THEN

.PP
IF (TMP_SECS.ATTRIBUTES.XFRM ≠ 03H) THEN #GP(0); FI;

.PP
ELSE

.PP
IF ( (TMP_SECS.ATTRIBUTES.XFRM & XCR0) ≠ TMP_SECS.ATTRIBUES.XFRM) THEN
#GP(0); FI;

.PP
FI;

.PP
IF ((DS:RBX).CSSA.FLAGS.DBGOPTIN = 0) and (DS:RBX).CSSA.FLAGS.AEXNOTIFY
≠ TMP_SECS.ATTRIBUTES.AEXNOTIFY))

.PP
THEN #GP(0); FI;

.PP
(* Make sure the SSA contains at least one more frame *) IF (
(DS:RBX).CSSA ≥ (DS:RBX).NSSA) THEN #GP(0); FI;

.PP
(* Compute linear address of SSA frame *)

.PP
TMP_SSA := (DS:RBX).OSSA + TMP_SECS.BASEADDR + 4096 *
TMP_SECS.SSAFRAMESIZE * (DS:RBX).CSSA;

.PP
TMP_XSIZE := compute_XSAVE_frame_size(TMP_SECS.ATTRIBUTES.XFRM);

.PP
FOR EACH TMP_SSA_PAGE = TMP_SSA to TMP_SSA + TMP_XSIZE

.PP
(* Check page is read/write accessible *)

.PP
Check that DS:TMP_SSA_PAGE is read/write accessible;

.PP
If a fault occurs, release locks, abort, and deliver that fault;

.PP
IF (DS:TMP_SSA_PAGE does not resolve to EPC page)

.PP
THEN #PF(DS:TMP_SSA_PAGE); FI;

.PP
IF (EPCM(DS:TMP_SSA_PAGE).VALID = 0)

.PP
THEN #PF(DS:TMP_SSA_PAGE); FI;

.PP
IF (EPCM(DS:TMP_SSA_PAGE).BLOCKED = 1)

.PP
THEN #PF(DS:TMP_SSA_PAGE); FI;

.PP
IF ((EPCM(DS:TMP_SSA_PAGE).PENDING = 1) or
(EPCM(DS:TMP_SSA_PAGE).MODIFIED = 1))

.PP
THEN #PF(DS:TMP_SSA_PAGE); FI;

.PP
IF ( ( EPCM(DS:TMP_SSA_PAGE).ENCLAVEADDRESS ≠ DS:TMP_SSA_PAGE) or
(EPCM(DS:TMP_SSA_PAGE).PT ≠ PT_REG) or

.PP
(EPCM(DS:TMP_SSA_PAGE).ENCLAVESECS ≠ EPCM(DS:RBX).ENCLAVESECS) or

.PP
(EPCM(DS:TMP_SSA_PAGE).R = 0) or (EPCM(DS:TMP_SSA_PAGE).W = 0) )

.PP
THEN #PF(DS:TMP_SSA_PAGE); FI;

.PP
CR_XSAVE_PAGE_n := Physical_Address(DS:TMP_SSA_PAGE);

.PP
ENDFOR

.PP
(* Compute address of GPR area*)

.PP
TMP_GPR := TMP_SSA + 4096 * DS:TMP_SECS.SSAFRAMESIZE -
sizeof(GPRSGX_AREA);

.PP
If a fault occurs; release locks, abort, and deliver that fault;

.PP
IF (DS:TMP_GPR does not resolve to EPC page)

.PP
THEN #PF(DS:TMP_GPR); FI;

.PP
IF (EPCM(DS:TMP_GPR).VALID = 0)

.PP
THEN #PF(DS:TMP_GPR); FI;

.PP
IF (EPCM(DS:TMP_GPR).BLOCKED = 1)

.PP
THEN #PF(DS:TMP_GPR); FI;

.PP
IF ((EPCM(DS:TMP_GPR).PENDING = 1) or (EPCM(DS:TMP_GPR).MODIFIED = 1))

.PP
THEN #PF(DS:TMP_GPR); FI;

.PP
IF ( ( EPCM(DS:TMP_GPR).ENCLAVEADDRESS ≠ DS:TMP_GPR) or
(EPCM(DS:TMP_GPR).PT ≠ PT_REG) or

.PP
(EPCM(DS:TMP_GPR).ENCLAVESECS EPCM(DS:RBX).ENCLAVESECS) or

.PP
(EPCM(DS:TMP_GPR).R = 0) or (EPCM(DS:TMP_GPR).W = 0) )

.PP
THEN #PF(DS:TMP_GPR); FI;

.PP
IF (TMP_MODE64 = 0)

.PP
THEN

.PP
IF (TMP_GPR + (GPR_SIZE -1) is not in DS segment) THEN #GP(0); FI;

.PP
FI;

.PP
CR_GPR_PA := Physical_Address (DS: TMP_GPR);

.PP
(* Validate TCS.OENTRY *)

.PP
TMP_TARGET := (DS:RBX).OENTRY + TMP_SECS.BASEADDR;

.PP
IF (TMP_MODE64 = 1)

.PP
THEN

.PP
IF (TMP_TARGET is not canonical) THEN #GP(0); FI;

.PP
ELSE

.PP
IF (TMP_TARGET &gt; CS limit) THEN #GP(0); FI;

.PP
FI;

.PP
(* Check proposed FS/GS segments fall within DS *)

.PP
IF (TMP_MODE64 = 0)

.PP
THEN

.PP
TMP_FSBASE := (DS:RBX).OFSBASE + TMP_SECS.BASEADDR;

.PP
TMP_FSLIMIT := (DS:RBX).OFSBASE + TMP_SECS.BASEADDR +
(DS:RBX).FSLIMIT;

.PP
TMP_GSBASE := (DS:RBX).OGSBASE + TMP_SECS.BASEADDR;

.PP
TMP_GSLIMIT := (DS:RBX).OGSBASE + TMP_SECS.BASEADDR +
(DS:RBX).GSLIMIT;

.PP
(* if FS wrap-around, make sure DS has no holes*)

.PP
IF (TMP_FSLIMIT &lt; TMP_FSBASE)

.PP
THEN

.PP
IF (DS.limit &lt; 4GB) THEN #GP(0); FI;

.PP
ELSE

.PP
IF (TMP_FSLIMIT &gt; DS.limit) THEN #GP(0); FI;

.PP
FI;

.PP
(* if GS wrap-around, make sure DS has no holes*)

.PP
IF (TMP_GSLIMIT &lt; TMP_GSBASE)

.PP
THEN

.PP
IF (DS.limit &lt; 4GB) THEN #GP(0); FI;

.PP
ELSE

.PP
IF (TMP_GSLIMIT &gt; DS.limit) THEN #GP(0); FI;

.PP
FI;

.PP
ELSE

.PP
TMP_FSBASE := (DS:RBX).OFSBASE + TMP_SECS.BASEADDR;

.PP
TMP_GSBASE := (DS:RBX).OGSBASE + TMP_SECS.BASEADDR;

.PP
IF ( (TMP_FSBASE is not canonical) or (TMP_GSBASE is not canonical))

.PP
THEN #GP(0); FI;

.PP
FI;

.PP
(* Ensure the enclave is not already active and this thread is the only
one using the TCS*)

.PP
IF (DS:RBX.STATE = ACTIVE)

.PP
THEN #GP(0); FI;

.PP
TMP_IA32_U_CET := 0

.PP
TMP_SSP : = 0

.PP
IF CPUID.(EAX=12H, ECX=1):EAX[6] = 1

.PP
THEN

.PP
IF ( CR4.CET = 0 )

.PP
THEN

.PP
(* If part does not support CET or CET has not been enabled and enclave
requires CET then fail *)

.PP
IF ( TMP_SECS.CET_ATTRIBUTES ≠ 0 OR TMP_SECS.CET_LEG_BITMAP_OFFSET
≠ 0 ) #GP(0); FI;

.PP
FI;

.PP
(* If indirect branch tracking or shadow stacks enabled but CET state
save area is not 16B aligned then fail EENTER *)

.PP
IF ( TMP_SECS.CET_ATTRIBUTES.SH_STK_EN = 1 OR
TMP_SECS.CET_ATTRIBUTES.ENDBR_EN = 1 )

.PP
THEN

.PP
IF (DS:RBX.OCETSSA is not 16B aligned) #GP(0); FI;

.PP
FI;

.PP
IF (TMP_SECS.CET_ATTRIBUTES.SH_STK_EN OR
TMP_SECS.CET_ATTRIBUTES.ENDBR_EN)

.PP
THEN

.PP
(* Setup CET state from SECS, note tracker goes to IDLE *)

.PP
TMP_IA32_U_CET = TMP_SECS.CET_ATTRIBUTES;

.PP
IF (TMP_IA32_U_CET.LEG_IW_EN = 1 AND TMP_IA32_U_CET.ENDBR_EN =
1 )

.PP
THEN

.PP
TMP_IA32_U_CET := TMP_IA32_U_CET + TMP_SECS.BASEADDR;

.PP
TMP_IA32_U_CET := TMP_IA32_U_CET +
TMP_SECS.CET_LEG_BITMAP_BASE;

.PP
FI;

.PP
(* Compute linear address of what will become new CET state save area
and cache its PA *)

.PP
TMP_CET_SAVE_AREA = DS:RBX.OCETSSA + TMP_SECS.BASEADDR +
(DS:RBX.CSSA) * 16

.PP
TMP_CET_SAVE_PAGE = TMP_CET_SAVE_AREA & ~0xFFF;

.PP
Check the TMP_CET_SAVE_PAGE page is read/write accessible

.PP
If fault occurs release locks, abort, and deliver fault

.PP
(* Read the EPCM VALID, PENDING, MODIFIED, BLOCKED, and PT fields
atomically *)

.PP
IF ((DS:TMP_CET_SAVE_PAGE Does NOT RESOLVE TO EPC PAGE) OR

.PP
(EPCM(DS:TMP_CET_SAVE_PAGE).VALID = 0) OR

.PP
(EPCM(DS:TMP_CET_SAVE_PAGE).PENDING = 1) OR

.PP
(EPCM(DS:TMP_CET_SAVE_PAGE).MODIFIED = 1) OR

.PP
(EPCM(DS:TMP_CET_SAVE_PAGE).BLOCKED = 1) OR

.PP
(EPCM(DS:TMP_CET_SAVE_PAGE).R = 0) OR

.PP
(EPCM(DS:TMP_CET_SAVE_PAGE).W = 0) OR

.PP
(EPCM(DS:TMP_CET_SAVE_PAGE).ENCLAVEADDRESS ≠ DS:TMP_CET_SAVE_PAGE)
OR

.PP
(EPCM(DS:TMP_CET_SAVE_PAGE).PT ≠ PT_SS_REST) OR

.PP
(EPCM(DS:TMP_CET_SAVE_PAGE).ENCLAVESECS ≠ EPCM(DS:RBX).ENCLAVESECS))

.PP
THEN

.PP
#PF(DS:TMP_CET_SAVE_PAGE);

.PP
FI;

.PP
CR_CET_SAVE_AREA_PA := Physical address(DS:TMP_CET_SAVE_AREA)

.PP
IF TMP_IA32_U_CET.SH_STK_EN = 1

.PP
THEN

.PP
TMP_SSP = TCS.PREVSSP;

.PP
FI;

.PP
FI;

.PP
CR_ENCLAVE_MODE := 1;

.PP
CR_ACTIVE_SECS := TMP_SECS;

.PP
CR_ELRANGE := (TMPSECS.BASEADDR, TMP_SECS.SIZE);

.PP
(* Save state for possible AEXs *)

.PP
CR_TCS_PA := Physical_Address (DS:RBX);

.PP
CR_TCS_LA := RBX;

.PP
CR_TCS_LA.AEP := RCX;

.PP
(* Save the hidden portions of FS and GS *)

.PP
CR_SAVE_FS_selector := FS.selector;

.PP
CR_SAVE_FS_base := FS.base;

.PP
CR_SAVE_FS_limit := FS.limit;

.PP
CR_SAVE_FS_access_rights := FS.access_rights;

.PP
CR_SAVE_GS_selector := GS.selector;

.PP
CR_SAVE_GS_base := GS.base;

.PP
CR_SAVE_GS_limit := GS.limit;

.PP
CR_SAVE_GS_access_rights := GS.access_rights;

.PP
(* If XSAVE is enabled, save XCR0 and replace it with
SECS.ATTRIBUTES.XFRM*)

.PP
IF (CR4.OSXSAVE = 1)

.PP
CR_SAVE_XCR0 := XCR0;

.PP
XCR0 := TMP_SECS.ATTRIBUTES.XFRM;

.PP
FI;

.PP
RCX := RIP;

.PP
RIP := TMP_TARGET;

.PP
RAX := (DS:RBX).CSSA;

.PP
(* Save the outside RSP and RBP so they can be restored on interrupt or
EEXIT *)

.PP
DS:TMP_SSA.U_RSP := RSP;

.PP
DS:TMP_SSA.U_RBP := RBP;

.PP
(* Do the FS/GS swap *)

.PP
FS.base := TMP_FSBASE;

.PP
FS.limit := DS:RBX.FSLIMIT;

.PP
FS.type := 0001b;

.PP
FS.W := DS.W;

.PP
FS.S := 1;

.PP
FS.DPL := DS.DPL;

.PP
FS.G := 1;

.PP
FS.B := 1;

.PP
FS.P := 1;

.PP
FS.AVL := DS.AVL;

.PP
FS.L := DS.L;

.PP
FS.unusable := 0;

.PP
FS.selector := 0BH;

.PP
GS.base := TMP_GSBASE;

.PP
GS.limit := DS:RBX.GSLIMIT;

.PP
GS.type := 0001b;

.PP
GS.W := DS.W;

.PP
GS.S := 1;

.PP
GS.DPL := DS.DPL;

.PP
GS.G := 1;

.PP
GS.B := 1;

.PP
GS.P := 1;

.PP
GS.AVL := DS.AVL;

.PP
GS.L := DS.L;

.PP
GS.unusable := 0;

.PP
GS.selector := 0BH;

.PP
CR_DBGOPTIN := TCS.FLAGS.DBGOPTIN;

.PP
Suppress_all_code_breakpoints_that_are_outside_ELRANGE;

.PP
IF (CR_DBGOPTIN = 0)

.PP
THEN

.PP
Suppress_all_code_breakpoints_that_overlap_with_ELRANGE;

.PP
CR_SAVE_TF := RFLAGS.TF;

.PP
RFLAGS.TF := 0;

.PP
Suppress_monitor_trap_flag for the source of the execution of the
enclave;

.PP
Suppress any pending debug exceptions;

.PP
Suppress any pending MTF VM exit;

.PP
ELSE

.PP
IF RFLAGS.TF = 1

.PP
THEN pend a single-step #DB at the end of EENTER; FI;

.PP
IF the “monitor trap flag” VM-execution control is set

.PP
THEN pend an MTF VM exit at the end of EENTER; FI;

.PP
FI;

.PP
IF ((CPUID.(EAX=7H, ECX=0):EDX[CET_IBT] = 1) OR (CPUID.(EAX=7H,
ECX=0):ECX[CET_SS] = 1)

.PP
THEN

.PP
(* Save enclosing application CET state into save registers *)

.PP
CR_SAVE_IA32_U_CET := IA32_U_CET

.PP
(* Setup enclave CET state *)

.PP
IF CPUID.(EAX=07H, ECX=00h):ECX[CET_SS] = 1

.PP
THEN

.PP
CR_SAVE_SSP := SSP

.PP
SSP := TMP_SSP

.PP
FI;

.PP
IA32_U_CET := TMP_IA32_U_CET;

.PP
FI;

.PP
Flush_linear_context;

.PP
Allow_front_end_to_begin_fetch_at_new_RIP;

.SS FLAGS AFFECTED
RFLAGS.TF is cleared on opt-out entry.

.SS PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	If DS:RBX is not page aligned.
	T{
If the enclave is not initialized.
T}
	T{
If part or all of the FS or GS segment specified by TCS is outside the DS segment or not properly aligned.
T}
	T{
If the thread is not in the INACTIVE state.
T}
	T{
If CS, DS, ES or SS bases are not all zero.
T}
	If executed in enclave mode.
	T{
If any reserved field in the TCS FLAG is set.
T}
	T{
If the target address is not within the CS segment.
T}
	If CR4.OSFXSR = 0.
	T{
If CR4.OSXSAVE = 0 and SECS.ATTRIBUTES.XFRM ≠ 3.
T}
	T{
If CR4.OSXSAVE = 1and SECS.ATTRIBUTES.XFRM is not a subset of XCR0.
T}
	T{
If SECS.ATTRIBUTES.AEXNOTIFY ≠ TCS.FLAGS.AEXNOTIFY and TCS.FLAGS.DBGOPTIN = 0.
T}
#PF(error	T{
code) If a page fault occurs in accessing memory.
T}
	T{
If DS:RBX does not point to a valid TCS.
T}
	T{
If one or more pages of the current SSA frame are not readable/writable, or do not resolve to a valid PT_REG EPC page.
T}
.TE

.SS 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	If DS:RBX is not page aligned.
	T{
If the enclave is not initialized.
T}
	T{
If the thread is not in the INACTIVE state.
T}
	T{
If CS, DS, ES or SS bases are not all zero.
T}
	If executed in enclave mode.
	T{
If part or all of the FS or GS segment specified by TCS is outside the DS segment or not properly aligned.
T}
	T{
If the target address is not canonical.
T}
	If CR4.OSFXSR = 0.
	T{
If CR4.OSXSAVE = 0 and SECS.ATTRIBUTES.XFRM ≠ 3.
T}
	T{
If CR4.OSXSAVE = 1and SECS.ATTRIBUTES.XFRM is not a subset of XCR0.
T}
	T{
If SECS.ATTRIBUTES.AEXNOTIFY ≠ TCS.FLAGS.AEXNOTIFY and TCS.FLAGS.DBGOPTIN = 0.
T}
#PF(error	T{
code) If a page fault occurs in accessing memory operands.
T}
	T{
If DS:RBX does not point to a valid TCS.
T}
	T{
If one or more pages of the current SSA frame are not readable/writable, or do not resolve to a valid PT_REG EPC page.
T}
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
