'\" t
.nh
.TH "X86-EDBGWR" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
EDBGWR - WRITE TO A DEBUG ENCLAVE
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
EAX = 05H ENCLS[EDBGWR]	IR	V/V	SGX1	T{
This leaf function writes a dword/quadword to a debug enclave.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP
Op/En	EAX		RBX	RCX
IR	EDBGWR (In)	Return error code (Out)	T{
Data to be written to a debug enclave (In)
T}	T{
Address of Target memory in the EPC (In)
T}
.TE

.SS DESCRIPTION
This leaf function copies the content in EBX/RBX to an EPC page
belonging to a debug enclave. Eight bytes are written in 64-bit mode,
four bytes are written in non-64-bit modes. The size of data cannot be
overridden.

.PP
The effective address of the target location inside the EPC is provided
in the register RCX.

.SH EDBGWR MEMORY PARAMETER SEMANTICS  href="edbgwr.html#edbgwr-memory-parameter-semantics"
class="anchor">¶

.TS
allbox;
l 
l .
\fB\fP
EPCQW
T{
Write access permitted by Enclave
T}
.TE

.PP
The instruction faults if any of the following:

.SH EDBGWR FAULTING CONDITIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
T{
RCX points into a page that is an SECS.
T}	T{
RCX does not resolve to a naturally aligned linear address.
T}
T{
RCX points to a page that does not belong to an enclave that is in debug mode.
T}	T{
RCX points to a location inside a TCS that is not the FLAGS word.
T}
T{
An operand causing any segment violation.
T}	May page fault.
CPL &gt; 0.	
.TE

.PP
The error codes are:

.PP
This instruction ignores the EPCM RWX attributes on the enclave page.
Consequently, violation of EPCM RWX attributes via EDBGRD does not
result in a #GP.

.SS CONCURRENCY RESTRICTIONS
.SS OPERATION
.SH TEMP VARIABLES IN EDBGWR OPERATIONAL FLOW  href="edbgwr.html#temp-variables-in-edbgwr-operational-flow"
class="anchor">¶

.TS
allbox;
l l l l 
l l l l .
\fBName\fP	\fBType\fP	\fBSize (Bits)\fP	\fBDescription\fP
TMP_MODE64	Binary	1	((IA32_EFER.LMA = 1) && (CS.L = 1)).
TMP_SECS		64	T{
Physical address of SECS of the enclave to which source operand belongs.
T}
.TE

.PP
TMP_MODE64 := ((IA32_EFER.LMA = 1) && (CS.L = 1));

.PP
IF ( (TMP_MODE64 = 1) and (DS:RCX is not 8Byte Aligned) )

.PP
THEN #GP(0); FI;

.PP
IF ( (TMP_MODE64 = 0) and (DS:RCX is not 4Byte Aligned) )

.PP
THEN #GP(0); FI;

.PP
IF (DS:RCX does not resolve within an EPC)

.PP
THEN #PF(DS:RCX); FI;

.PP
(* make sure no other Intel SGX instruction is accessing the same EPCM
entry *)

.PP
IF (Another instruction modifying the same EPCM entry is executing)

.PP
THEN #GP(0); FI;

.PP
IF (EPCM(DS:RCX).VALID = 0)

.PP
THEN #PF(DS:RCX); FI;

.PP
(* make sure that DS:RCX (DST) is pointing to a PT_REG or PT_TCS or
PT_SS_FIRST or PT_SS_REST *)

.PP
IF ( (EPCM(DS:RCX).PT ≠ PT_REG) and (EPCM(DS:RCX).PT ≠ PT_TCS)

.PP
and (EPCM(DS:RCX).PT ≠ PT_SS_FIRST) and (EPCM(DS:RCX).PT ≠
PT_SS_REST))

.PP
THEN #PF(DS:RCX); FI;

.PP
(* make sure that DS:RCX points to an accessible EPC page *)

.PP
IF ( (EPCM(DS:RCX).PENDING is not 0) or (EPCM(DS:RCS).MODIFIED is not 0)
)

.PP
THEN

.PP
RFLAGS.ZF := 1;

.PP
RAX := SGX_PAGE_NOT_DEBUGGABLE;

.PP
GOTO DONE;

.PP
FI;

.PP
(* If destination is a TCS, then make sure that the offset into the
page can only point to the FLAGS field*)

.PP
IF ( ( EPCM(DS:RCX). PT = PT_TCS) and ((DS:RCX) & FF8H ≠
offset_of_FLAGS & 0FF8H) )

.PP
THEN #GP(0); FI;

.PP
(* Locate the SECS for the enclave to which the DS:RCX page belongs *)

.PP
TMP_SECS := GET_SECS_PHYS_ADDRESS(EPCM(DS:RCX).ENCLAVESECS);

.PP
(* make sure the enclave owning the PT_REG or PT_TCS page allow debug
*)

.PP
IF (TMP_SECS.ATTRIBUTES.DEBUG = 0)

.PP
THEN #GP(0); FI;

.PP
IF ( (TMP_MODE64 = 1) )

.PP
THEN (DS:RCX)[63:0] := RBX[63:0];

.PP
ELSE (DS:RCX)[31:0] := EBX[31:0];

.PP
FI;

.PP
(* clear EAX and ZF to indicate successful completion *)

.PP
RAX := 0;

.PP
RFLAGS.ZF := 0;

.PP
DONE:

.PP
(* clear flags *)

.PP
RFLAGS.CF,PF,AF,OF,SF := 0

.SS FLAGS AFFECTED
ZF is set if the page is MODIFIED or PENDING; RAX contains the error
code. Otherwise ZF is cleared and RAX is set to 0. CF, PF, AF, OF, SF
are cleared.

.SS PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the address in RCS violates DS limit or access rights.
T}
	If DS segment is unusable.
	T{
If RCX points to a memory location not 4Byte-aligned.
T}
	T{
If the address in RCX points to a page belonging to a non-debug enclave.
T}
	T{
If the address in RCX points to a page which is not PT_TCS or PT_REG.
T}
	T{
If the address in RCX points to a location inside TCS that is not the FLAGS word.
T}
#PF(error	T{
code) If a page fault occurs in accessing memory operands.
T}
	T{
If the address in RCX points to a non-EPC page.
T}
	T{
If the address in RCX points to an invalid EPC page.
T}
.TE

.SS 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	If RCX is non-canonical form.
	T{
If RCX points to a memory location not 8Byte-aligned.
T}
	T{
If the address in RCX points to a page belonging to a non-debug enclave.
T}
	T{
If the address in RCX points to a page which is not PT_TCS or PT_REG.
T}
	T{
If the address in RCX points to a location inside TCS that is not the FLAGS word.
T}
#PF(error	T{
code) If a page fault occurs in accessing memory operands.
T}
	T{
If the address in RCX points to a non-EPC page.
T}
	T{
If the address in RCX points to an invalid EPC page.
T}
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
