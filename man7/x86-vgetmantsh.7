'\" t
.nh
.TH "X86-VGETMANTSH" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
VGETMANTSH - EXTRACT FP16 OF NORMALIZED MANTISSA FROM FP16 SCALAR
.TS
allbox;
l l l l l 
l l l l l .
\fBInstruction En Bit Mode Flag Support Instruction En Bit Mode Flag Support 64/32 CPUID Feature Instruction En Bit Mode Flag CPUID Feature Instruction En Bit Mode Flag Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag 64/32 CPUID Feature Instruction En Bit Mode Flag CPUID Feature Instruction En Bit Mode Flag Op/ 64/32 CPUID Feature\fP	\fB\fP	\fBSupport\fP	\fB\fP	\fBDescription\fP
T{
EVEX.LLIG.NP.0F3A.W0 27 /r /ib VGETMANTSH xmm1{k1}{z}, xmm2, xmm3/m16 {sae}, imm8
T}	A	V/V	AVX512-FP16	T{
Extract the normalized mantissa of the low FP16 element in xmm3/m16 using imm8 for sign control and mantissa interval normalization. Store the mantissa to xmm1 subject to writemask k1 and merge with the other elements of xmm2. Bits 127:16 of xmm2 are copied to xmm1[127:16]\&.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING  href="vgetmantsh.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	Scalar	ModRM:reg (w)	VEX.vvvv (r)	ModRM:r/m (r)	imm8 (r)
.TE

.SS DESCRIPTION
This instruction converts the FP16 value in the low element of the
second source operand to FP16 values with the mantissa normalization and
sign control specified by the imm8 byte, see Table
5-19
\[la]vgetmantph.html#tbl\-5\-19\[ra]\&. The converted result is written to the
low element of the destination operand using writemask k1. The
normalized mantissa is specified by interv (imm8[1:0]) and the sign
control (SC) is specified by bits 3:2 of the immediate byte.

.PP
Bits 127:16 of the destination operand are copied from the corresponding
bits of the first source operand. Bits MAXVL-1:128 of the destination
operand are zeroed. The low FP16 element of the destination is updated
according to the writemask.

.PP
For each input FP16 value x, The conversion operation is:

.PP
GetMant(x) = ±2k|x.significand|

.PP
where:

.PP
1 ≤ |x.significand| &lt; 2

.PP
Unbiased exponent k depends on the interval range defined by interv and
whether the exponent of the source is even or odd. The sign of the final
result is determined by the sign control and the source sign and the
leading fraction bit.

.PP
The encoded value of imm8[1:0] and sign control are shown in Table
5-19
\[la]vgetmantph.html#tbl\-5\-19\[ra]\&.

.PP
Each converted FP16 result is encoded according to the sign control, the
unbiased exponent k (adding bias) and a mantissa normalized to the range
specified by interv.

.PP
The GetMant() function follows Table 5-20
\[la]vgetmantph.html#tbl\-5\-20\[ra]
when dealing with floating-point special numbers.

.SS OPERATION
.SS VGETMANTSH DEST{K1}, SRC1, SRC2, IMM8  href="vgetmantsh.html#vgetmantsh-dest-k1---src1--src2--imm8"
class="anchor">¶

.EX
sign_control := imm8[3:2]
normalization_interval := imm8[1:0]
IF k1[0] or *no writemask*:
    dest.fp16[0] := getmant_fp16(src2.fp16[0],
            // see VGETMANTPH
        normalization_interval)
ELSE IF *zeroing*:
    dest.fp16[0] := 0
//else dest.fp16[0] remains unchanged
DEST[127:16] := src1[127:16]
DEST[MAXVL-1:128] := 0
.EE

.SS INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="vgetmantsh.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
VGETMANTSH __m128h _mm_getmant_round_sh (__m128h a, __m128h b, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign, const int sae);

VGETMANTSH __m128h _mm_mask_getmant_round_sh (__m128h src, __mmask8 k, __m128h a, __m128h b, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign, const int sae);

VGETMANTSH __m128h _mm_maskz_getmant_round_sh (__mmask8 k, __m128h a, __m128h b, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign, const int sae);

VGETMANTSH __m128h _mm_getmant_sh (__m128h a, __m128h b, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign);

VGETMANTSH __m128h _mm_mask_getmant_sh (__m128h src, __mmask8 k, __m128h a, __m128h b, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign);

VGETMANTSH __m128h _mm_maskz_getmant_sh (__mmask8 k, __m128h a, __m128h b, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign);
.EE

.SS SIMD FLOATING-POINT EXCEPTIONS  href="vgetmantsh.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
Invalid, Denormal

.SS OTHER EXCEPTIONS
EVEX-encoded instructions, see Table
2-47, “Type E3 Class Exception Conditions.”

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
