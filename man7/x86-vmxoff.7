'\" t
.nh
.TH "X86-VMXOFF" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
VMXOFF - LEAVE VMX OPERATION
.TS
allbox;
l l l 
l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fBDescription\fP
0F 01 C4 VMXOFF	ZO	Leaves VMX operation.
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
ZO	NA	NA	NA	NA
.TE

.SH DESCRIPTION
Takes the logical processor out of VMX operation, unblocks INIT signals,
conditionally re-enables A20M, and clears any address-range
monitoring.1

.SH OPERATION
.EX
IF (not in VMX operation) or (CR0.PE = 0) or (RFLAGS.VM = 1) or (IA32_EFER.LMA = 1 and CS.L = 0)
    THEN #UD;
ELSIF in VMX non-root operation
    THEN VMexit;
ELSIF CPL > 0
    THEN #GP(0);
ELSIF dual-monitor treatment of SMIs and SMM is active
    THEN VMfail(VMXOFF under dual-monitor treatment of SMIs and SMM);
    ELSE
        leave VMX operation;
        unblock INIT;
        IF IA32_SMM_MONITOR_CTL[2] = 02
            THEN unblock SMIs;
        IF outside SMX operation3
            THEN unblock and enable A20M;
        FI;
        clear address-range monitoring;
        VMsucceed;
FI;
.EE

.SH FLAGS AFFECTED
See the operation section and Section 31.2.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If executed in VMX root operation with CPL &gt; 0.
T}
.TE

.PP
.RS

.PP
1\&. See the information on MONITOR/MWAIT in Chapter 9,
“Multiple-Processor Management,” of the Intel® 64 and IA-32
Architectures Software Developer’s Manual, Volume 3A.

.PP
2\&. Setting IA32_SMM_MONITOR_CTL[bit 2] to 1 prevents VMXOFF from
unblocking SMIs regardless of the value of the register’s value bit
(bit 0). Not all processors allow this bit to be set to 1. Software
should consult the VMX capability MSR IA32_VMX_MISC (see Appendix
A.6) to determine whether this is allowed.

.PP
3\&. A logical processor is outside SMX operation if GETSEC[SENTER]
has not been executed or if GETSEC[SEXIT] was executed after the
last execution of GETSEC[SENTER]\&. See Chapter 6, “Safer Mode
Extensions Reference.”

.RE

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
If executed outside VMX operation.
T}
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
The VMXOFF instruction is not recognized in real-address mode.
T}
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
The VMXOFF instruction is not recognized in virtual-8086 mode.
T}
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
The VMXOFF instruction is not recognized in compatibility mode.
T}
.TE

.SH 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If executed in VMX root operation with CPL &gt; 0.
T}
#UD	T{
If executed outside VMX operation.
T}
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
