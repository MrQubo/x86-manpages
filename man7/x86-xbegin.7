'\" t
.nh
.TH "X86-XBEGIN" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
XBEGIN - TRANSACTIONAL BEGIN
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
C7 F8 XBEGIN rel16	A	V/V	RTM	T{
Specifies the start of an RTM region. Provides a 16-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort.
T}
C7 F8 XBEGIN rel32	A	V/V	RTM	T{
Specifies the start of an RTM region. Provides a 32-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand2\fP	\fBOperand3\fP	\fBOperand4\fP
A	Offset	N/A	N/A	N/A
.TE

.SH DESCRIPTION
The XBEGIN instruction specifies the start of an RTM code region. If the
logical processor was not already in transactional execution, then the
XBEGIN instruction causes the logical processor to transition into
transactional execution. The XBEGIN instruction that transitions the
logical processor into transactional execution is referred to as the
outermost XBEGIN instruction. The instruction also specifies a relative
offset to compute the address of the fallback code path following a
transactional abort. (Use of the 16-bit operand size does not cause this
address to be truncated to 16 bits, unlike a near jump to a relative
offset.)

.PP
On an RTM abort, the logical processor discards all architectural
register and memory updates performed during the RTM execution and
restores architectural state to that corresponding to the outermost
XBEGIN instruction. The fallback address following an abort is computed
from the outermost XBEGIN instruction.

.PP
Execution of XBEGIN while in a suspend read address tracking region
causes a transactional abort.

.SH OPERATION
.SS XBEGIN
.EX
IF RTM_NEST_COUNT < MAX_RTM_NEST_COUNT AND SUSLDTRK_ACTIVE = 0
    THEN
        RTM_NEST_COUNT++
        IF RTM_NEST_COUNT = 1 THEN
            IF 64-bit Mode
                THEN
                    IF OperandSize = 16
                        THEN fallbackRIP := RIP + SignExtend64(rel16);
                        ELSE fallbackRIP := RIP + SignExtend64(rel32);
                    FI;
                    IF fallbackRIP is not canonical
                        THEN #GP(0);
                    FI;
                ELSE
                    IF OperandSize = 16
                        THEN fallbackEIP := EIP + SignExtend32(rel16);
                        ELSE fallbackEIP := EIP + rel32;
                    FI;
                    IF fallbackEIP outside code segment limit
                        THEN #GP(0);
                    FI;
            FI;
            RTM_ACTIVE := 1
            Enter RTM Execution (* record register state, start tracking memory state*)
        FI; (* RTM_NEST_COUNT = 1 *)
    ELSE (* RTM_NEST_COUNT = MAX_RTM_NEST_COUNT OR SUSLDTRK_ACTIVE = 1 *)
        GOTO RTM_ABORT_PROCESSING
FI;
(* For any RTM abort condition encountered during RTM execution *)
RTM_ABORT_PROCESSING:
    Restore architectural register state
    Discard memory updates performed in transaction
    Update EAX with status
    RTM_NEST_COUNT := 0
    RTM_ACTIVE := 0
    SUSLDTRK_ACTIVE := 0
    IF 64-bit mode
        THEN
            RIP := fallbackRIP
        ELSE
            EIP := fallbackEIP
    FI;
END
.EE

.SH FLAGS AFFECTED
None.

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="xbegin.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
XBEGIN unsigned int _xbegin( void );
.EE

.SH SIMD FLOATING-POINT EXCEPTIONS  href="xbegin.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
None.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	CPUID.(EAX=7, ECX=0):EBX.RTM[bit 11]=0.
	If LOCK prefix is used.
#GP(0)	T{
If the fallback address is outside the CS segment.
T}
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the fallback address is outside the address space 0000H and FFFFH.
T}
#UD	CPUID.(EAX=7, ECX=0):EBX.RTM[bit 11]=0.
	If LOCK prefix is used.
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the fallback address is outside the address space 0000H and FFFFH.
T}
#UD	CPUID.(EAX=7, ECX=0):EBX.RTM[bit 11]=0.
	If LOCK prefix is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	CPUID.(EAX=7, ECX=0):EBX.RTM[bit 11] = 0.
	If LOCK prefix is used.
#GP(0)	T{
If the fallback address is non-canonical.
T}
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
