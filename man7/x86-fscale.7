'\" t
.nh
.TH "X86-FSCALE" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
FSCALE - SCALE
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode\fP	\fB\fP	\fBMode\fP	\fBLeg Mode\fP	\fBDescription\fP
D9 FD				Scale ST(0) by ST(1).
.TE

.SH DESCRIPTION
Truncates the value in the source operand (toward 0) to an integral
value and adds that value to the exponent of the destination operand.
The destination and source operands are floating-point values located in
registers ST(0) and ST(1), respectively. This instruction provides rapid
multiplication or division by integral powers of 2. The following table
shows the results obtained when scaling various classes of numbers,
assuming that neither overflow nor underflow occurs.

.PP
.RS

.PP
F Meansfinitefloating-pointvalue.

.RE

.PP
In most cases, only the exponent is changed and the mantissa
(significand) remains unchanged. However, when the value being scaled in
ST(0) is a denormal value, the mantissa is also changed and the result
may turn out to be a normalized number. Similarly, if overflow or
underflow results from a scale operation, the resulting mantissa will
differ from the source’s mantissa.

.PP
The FSCALE instruction can also be used to reverse the action of the
FXTRACT instruction, as shown in the following example:

.PP
FXTRACT;

.PP
FSCALE;

.PP
FSTP ST(1);

.PP
In this example, the FXTRACT instruction extracts the significand and
exponent from the value in ST(0) and stores them in ST(0) and ST(1)
respectively. The FSCALE then scales the significand in ST(0) by the
exponent in ST(1), recreating the original value before the FXTRACT
operation was performed. The FSTP ST(1) instruction overwrites the
exponent (extracted by the FXTRACT instruction) with the recreated
value, which returns the stack to its original state with only one
register [ST(0)] occupied.

.PP
This instruction’s operation is the same in non-64-bit modes and 64-bit
mode.

.SH OPERATION
.EX
ST(0) := ST(0) ∗ 2RoundTowardZero(ST(1));
.EE

.SH FPU FLAGS AFFECTED
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
C1	T{
Set to 0 if stack underflow occurred.
T}
	T{
Set if result was rounded up; cleared otherwise.
T}
C0, C2, C3	Undefined.
.TE

.SH FLOATING-POINT EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#IS	Stack underflow occurred.
#IA	T{
Source operand is an SNaN value or unsupported format.
T}
#D	T{
Source operand is a denormal value.
T}
#U	T{
Result is too small for destination format.
T}
#O	T{
Result is too large for destination format.
T}
#P	T{
Value cannot be represented exactly in destination format.
T}
.TE

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#NM	CR0.EM[bit 2] or CR0.TS[bit 3] = 1.
#MF	T{
If there is a pending x87 FPU exception.
T}
#UD	If the LOCK prefix is used.
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH VIRTUAL-8086 MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH COMPATIBILITY MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH 64-BIT MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
