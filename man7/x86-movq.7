'\" t
.nh
.TH "X86-MOVQ" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
MOVQ - MOVE QUADWORD
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/ En\fP	\fB64/32-bit Mode\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
NP 0F 6F /r MOVQ mm, mm/m64	A	V/V	MMX	T{
Move quadword from mm/m64 to mm.
T}
NP 0F 7F /r MOVQ mm/m64, mm	B	V/V	MMX	T{
Move quadword from mm to mm/m64.
T}
T{
F3 0F 7E /r MOVQ xmm1, xmm2/m64
T}	A	V/V	SSE2	T{
Move quadword from xmm2/mem64 to xmm1.
T}
T{
VEX.128.F3.0F.WIG 7E /r VMOVQ xmm1, xmm2/m64
T}	A	V/V	AVX	T{
Move quadword from xmm2 to xmm1.
T}
T{
EVEX.128.F3.0F.W1 7E /r VMOVQ xmm1, xmm2/m64
T}	C	V/V	AVX512F	T{
Move quadword from xmm2/m64 to xmm1.
T}
T{
66 0F D6 /r MOVQ xmm2/m64, xmm1
T}	B	V/V	SSE2	T{
Move quadword from xmm1 to xmm2/mem64.
T}
T{
VEX.128.66.0F.WIG D6 /r VMOVQ xmm1/m64, xmm2
T}	B	V/V	AVX	T{
Move quadword from xmm2 register to xmm1/m64.
T}
T{
EVEX.128.66.0F.W1 D6 /r VMOVQ xmm1/m64, xmm2
T}	D	V/V	AVX512F	T{
Move quadword from xmm2 register to xmm1/m64.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple Type\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	N/A	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
B	N/A	ModRM:r/m (w)	ModRM:reg (r)	N/A	N/A
C	Tuple1 Scalar	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
D	Tuple1 Scalar	ModRM:r/m (w)	ModRM:reg (r)	N/A	N/A
.TE

.SH DESCRIPTION
Copies a quadword from the source operand (second operand) to the
destination operand (first operand). The source and destination operands
can be MMX technology registers, XMM registers, or 64-bit memory
locations. This instruction can be used to move a quadword between two
MMX technology registers or between an MMX technology register and a
64-bit memory location, or to move data between two XMM registers or
between an XMM register and a 64-bit memory location. The instruction
cannot be used to transfer data between memory locations.

.PP
When the source operand is an XMM register, the low quadword is moved;
when the destination operand is an XMM register, the quadword is stored
to the low quadword of the register, and the high quadword is cleared to
all 0s.

.PP
In 64-bit mode and if not encoded using VEX/EVEX, use of the REX prefix
in the form of REX.R permits this instruction to access additional
registers (XMM8-XMM15).

.PP
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise
instructions will #UD.

.PP
If VMOVQ is encoded with VEX.L= 1, an attempt to execute the instruction
encoded with VEX.L= 1 will cause an #UD exception.

.SH OPERATION
.SS MOVQ INSTRUCTION WHEN OPERATING ON MMX TECHNOLOGY REGISTERS AND MEMORY LOCATIONS <a
href="movq.html#movq-instruction-when-operating-on-mmx-technology-registers-and-memory-locations"
class="anchor">¶

.EX
DEST := SRC;
.EE

.SS MOVQ INSTRUCTION WHEN SOURCE AND DESTINATION OPERANDS ARE XMM REGISTERS <a
href="movq.html#movq-instruction-when-source-and-destination-operands-are-xmm-registers"
class="anchor">¶

.EX
DEST[63:0] := SRC[63:0];
DEST[127:64] := 0000000000000000H;
.EE

.SS MOVQ INSTRUCTION WHEN SOURCE OPERAND IS XMM REGISTER AND DESTINATION <a
href="movq.html#movq-instruction-when-source-operand-is-xmm-register-and-destination"
class="anchor">¶

.EX
operand is memory location:
    DEST := SRC[63:0];
.EE

.SS MOVQ INSTRUCTION WHEN SOURCE OPERAND IS MEMORY LOCATION AND DESTINATION <a
href="movq.html#movq-instruction-when-source-operand-is-memory-location-and-destination"
class="anchor">¶

.EX
operand is XMM register:
    DEST[63:0] := SRC;
    DEST[127:64] := 0000000000000000H;
.EE

.SS VMOVQ (VEX.128.F3.0F 7E) WITH XMM REGISTER SOURCE AND DESTINATION <a
href="movq.html#vmovq--vex-128-f3-0f-7e--with-xmm-register-source-and-destination"
class="anchor">¶

.EX
DEST[63:0] := SRC[63:0]
DEST[MAXVL-1:64] := 0
.EE

.SS VMOVQ (VEX.128.66.0F D6) WITH XMM REGISTER SOURCE AND DESTINATION <a
href="movq.html#vmovq--vex-128-66-0f-d6--with-xmm-register-source-and-destination"
class="anchor">¶

.EX
DEST[63:0] := SRC[63:0]
DEST[MAXVL-1:64] := 0
.EE

.SS VMOVQ (7E - EVEX ENCODED VERSION) WITH XMM REGISTER SOURCE AND DESTINATION <a
href="movq.html#vmovq--7e---evex-encoded-version--with-xmm-register-source-and-destination"
class="anchor">¶

.EX
DEST[63:0] := SRC[63:0]
DEST[MAXVL-1:64] := 0
.EE

.SS VMOVQ (D6 - EVEX ENCODED VERSION) WITH XMM REGISTER SOURCE AND DESTINATION <a
href="movq.html#vmovq--d6---evex-encoded-version--with-xmm-register-source-and-destination"
class="anchor">¶

.EX
DEST[63:0] := SRC[63:0]
DEST[MAXVL-1:64] := 0
.EE

.SS VMOVQ (7E) WITH MEMORY SOURCE
.EX
DEST[63:0] := SRC[63:0]
DEST[MAXVL-1:64] := 0
.EE

.SS VMOVQ (7E - EVEX ENCODED VERSION) WITH MEMORY SOURCE  href="movq.html#vmovq--7e---evex-encoded-version--with-memory-source"
class="anchor">¶

.EX
DEST[63:0] := SRC[63:0]
DEST[:MAXVL-1:64] := 0
.EE

.SS VMOVQ (D6) WITH MEMORY DEST
.EX
DEST[63:0] := SRC2[63:0]
.EE

.SH FLAGS AFFECTED
None.

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="movq.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
VMOVQ __m128i _mm_loadu_si64( void * s);

VMOVQ void _mm_storeu_si64( void * d, __m128i s);

MOVQ m128i _mm_move_epi64(__m128i a)
.EE

.SH SIMD FLOATING-POINT EXCEPTIONS
None.

.SH OTHER EXCEPTIONS
See Table 23-8, “Exception Conditions
for Legacy SIMD/MMX Instructions without FP Exception,” in the
Intel® 64 and IA-32 Architectures Software Developer’s
Manual, Volume 3B.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
