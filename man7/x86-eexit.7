'\" t
.nh
.TH "X86-EEXIT" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
EEXIT - EXITS AN ENCLAVE
.TS
allbox;
l 
l .
\fB\fP
\fBOpcode/Op/En 64/32 CPUID Description Instruction bit Mode Feature Support Flag\fP EAX = 04H IR V/V SGX1 This leaf function is used to exit an enclave. ENCLU[EEXIT]
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l 
l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP
Op/En	EAX	RBX	RCX
IR	EEXIT (In)	T{
Target address outside the enclave (In)
T}	T{
Address of the current AEP (Out)
T}
.TE

.SS DESCRIPTION
The ENCLU[EEXIT] instruction exits the currently executing enclave and
branches to the location specified in RBX. RCX receives the current AEP.
If RBX is not within the CS (32-bit mode) or is not canonical (64-bit
mode) a #GP(0) results.

.SH EEXIT MEMORY PARAMETER SEMANTICS  href="eexit.html#eexit-memory-parameter-semantics"
class="anchor">¶

.TS
allbox;
l 
l .
\fB\fP
Target Address
T{
Non-Enclave read and execute access
T}
.TE

.PP
If RBX specifies an address that is inside the enclave, the instruction
will complete normally. The fetch of the next instruction will occur in
non-enclave mode, but will attempt to fetch from inside the enclave.
This fetch returns a fixed data pattern.

.PP
If secrets are contained in any registers, it is responsibility of
enclave software to clear those registers.

.PP
If XCR0 was modified on enclave entry, it is restored to the value it
had at the time of the most recent EENTER or ERESUME.

.PP
If the enclave is opt-out, RFLAGS.TF is loaded from the value previously
saved on EENTER.

.PP
Code and data breakpoints are unsuppressed.

.PP
Performance monitoring counters are unsuppressed.

.SS CONCURRENCY RESTRICTIONS
.SS OPERATION
.SH TEMP VARIABLES IN EEXIT OPERATIONAL FLOW  href="eexit.html#temp-variables-in-eexit-operational-flow"
class="anchor">¶

.TS
allbox;
l l l l 
l l l l .
\fBName\fP	\fBType\fP	\fBSize (Bits)\fP	\fBDescription\fP
TMP_RIP	Effective Address	32/64	T{
Saved copy of CRIP for use when creating LBR.
T}
.TE

.PP
TMP_MODE64 := ((IA32_EFER.LMA = 1) && (CS.L = 1));

.PP
IF (TMP_MODE64 = 1)

.PP
THEN

.PP
IF (RBX is not canonical) THEN #GP(0); FI;

.PP
ELSE

.PP
IF (RBX &gt; CS limit) THEN #GP(0); FI;

.PP
FI;

.PP
TMP_RIP := CRIP;

.PP
RIP := RBX;

.PP
(* Return current AEP in RCX *)

.PP
RCX := CR_TCS_PA.AEP;

.PP
(* Do the FS/GS swap *)

.PP
FS.selector := CR_SAVE_FS.selector;

.PP
FS.base := CR_SAVE_FS.base;

.PP
FS.limit := CR_SAVE_FS.limit;

.PP
FS.access_rights := CR_SAVE_FS.access_rights;

.PP
GS.selector := CR_SAVE_GS.selector;

.PP
GS.base := CR_SAVE_GS.base;

.PP
GS.limit := CR_SAVE_GS.limit;

.PP
GS.access_rights := CR_SAVE_GS.access_rights;

.PP
(* Restore XCR0 if needed *)

.PP
IF (CR4.OSXSAVE = 1)

.PP
XCR0 := CR_SAVE__XCR0;

.PP
FI;

.PP
Unsuppress_all_code_breakpoints_that_are_outside_ELRANGE;

.PP
IF (CR_DBGOPTIN = 0)

.PP
THEN

.PP
UnSuppress_all_code_breakpoints_that_overlap_with_ELRANGE;

.PP
Restore suppressed breakpoint matches;

.PP
RFLAGS.TF := CR_SAVE_TF;

.PP
UnSuppress_montior_trap_flag;

.PP
UnSuppress_LBR_Generation;

.PP
UnSuppress_performance monitoring_activity;

.PP
Restore performance monitoring counter AnyThread demotion to MyThread in
enclave back to AnyThread

.PP
FI;

.PP
IF RFLAGS.TF = 1

.PP
THEN Pend Single-Step #DB at the end of EEXIT;

.PP
FI;

.PP
IF the “monitor trap flag” VM-execution control is set

.PP
THEN pend a MTF VM exit at the end of EEXIT;

.PP
FI;

.PP
IF (CPUID.(EAX=12H, ECX=1):EAX[6] = 1)

.PP
THEN

.PP
(* Record PREVSSP *)

.PP
IF (IA32_U_CET.SH_STK_EN == 1)

.PP
THEN CR_TCS_PA.PREVSSP = SSP; FI;

.PP
FI;

.PP
IF ((CPUID.(EAX=7H, ECX=0):EDX[CET_IBT] = 1) OR (CPUID.(EAX=7,
ECX=0):ECX[CET_SS] = 1)

.PP
THEN

.PP
(* Restore enclosing app’s CET state from the save registers *)

.PP
IA32_U_CET := CR_SAVE_IA32_U_CET;

.PP
IF CPUID.(EAX=07H, ECX=00h):ECX[CET_SS] = 1

.PP
THEN SSP := CR_SAVE_SSP; FI;

.PP
(* Update enclosing app’s TRACKER if enclosing app has indirect branch
tracking enabled *)

.PP
IF (CR4.CET = 1 AND IA32_U_CET.ENDBR_EN = 1)

.PP
THEN

.PP
IA32_U_CET.TRACKER := WAIT_FOR_ENDBRANCH;

.PP
IA32_U_CET.SUPPRESS := 0

.PP
FI;

.PP
FI;

.PP
CR_ENCLAVE_MODE := 0;

.PP
CR_TCS_PA.STATE := INACTIVE;

.PP
(* Assure consistent translations *)

.PP
Flush_linear_context;

.SS FLAGS AFFECTED
RFLAGS.TF is restored from the value previously saved in EENTER or
ERESUME.

.SS PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If executed outside an enclave.
T}
	T{
If RBX is outside the CS segment.
T}
#PF(error	T{
code) If a page fault occurs in accessing memory.
T}
.TE

.SS 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If executed outside an enclave.
T}
	If RBX is not canonical.
#PF(error	T{
code) If a page fault occurs in accessing memory operands.
T}
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
