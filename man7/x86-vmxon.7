'\" t
.nh
.TH "X86-VMXON" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
VMXON - ENTER VMX OPERATION
.TS
allbox;
l l l 
l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fBDescription\fP
F3 0F C7 /6 VMXON m64	M	Enter VMX root operation.
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
M	ModRM:r/m (r)	NA	NA	NA
.TE

.SH DESCRIPTION
Puts the logical processor in VMX operation with no current VMCS, blocks
INIT signals, disables A20M, and clears any address-range monitoring
established by the MONITOR instruction.1

.PP
The operand of this instruction is a 4KB-aligned physical address (the
VMXON pointer) that references the VMXON region, which the logical
processor may use to support VMX operation. This operand is always 64
bits and is always in memory.

.SH OPERATION
.EX
IF (register operand) or (CR0.PE = 0) or (CR4.VMXE = 0) or (RFLAGS.VM = 1) or (IA32_EFER.LMA = 1 and CS.L = 0)
    THEN #UD;
ELSIF not in VMX operation
    THEN
        IF (CPL > 0) or (in A20M mode) or
        (the values of CR0 and CR4 are not supported in VMX operation; see Section 24.8) or
        (bit 0 (lock bit) of IA32_FEATURE_CONTROL MSR is clear) or
        (in SMX operation2 and bit 1 of IA32_FEATURE_CONTROL MSR is clear) or
        (outside SMX operation and bit 2 of IA32_FEATURE_CONTROL MSR is clear)
            THEN #GP(0);
            ELSE
                addr := contents of 64-bit in-memory source operand;
                IF addr is not 4KB-aligned or
                addr sets any bits beyond the physical-address width3
                    THEN VMfailInvalid;
                    ELSE
                        rev := 32 bits located at physical address addr;
                        IF rev[30:0] ≠ VMCS revision identifier supported by processor OR rev[31] = 1
                            THEN VMfailInvalid;
                            ELSE
                                current-VMCS pointer := FFFFFFFF_FFFFFFFFH;
                                enter VMX operation;
                                block INIT signals;
                                block and disable A20M;
.EE

.PP
.RS

.PP
1\&. See the information on MONITOR/MWAIT in Chapter 9,
“Multiple-Processor Management,” of the Intel® 64 and IA-32
Architectures Software Developer’s Manual, Volume 3A.

.PP
2\&. A logical processor is in SMX operation if GETSEC[SEXIT] has not
been executed since the last execution of GETSEC[SENTER]\&. A logical
processor is outside SMX operation if GETSEC[SENTER] has not been
executed or if GETSEC[SEXIT] was executed after the last execution
of GETSEC[SENTER]\&. See Chapter 6, “Safer Mode Extensions Reference.”

.PP
3\&. If IA32_VMX_BASIC[48] is read as 1, VMfailInvalid occurs if
addr sets any bits in the range 63:32; see Appendix A.1.

.RE

.EX
                    clear address-range monitoring;
                    IF the processor supports Intel PT but does not allow it to be used in VMX operation1
                        THEN IA32_RTIT_CTL.TraceEn := 0;
                    FI;
                    VMsucceed;
                FI;
            FI;
        FI;
ELSIF in VMX non-root operation
    THEN VMexit;
ELSIF CPL > 0
    THEN #GP(0);
    ELSE VMfail(“VMXON executed in VMX root operation”);
FI;
.EE

.PP
.RS

.PP
1\&. Software should read the VMX capability MSR IA32_VMX_MISC to
determine whether the processor allows Intel PT to be used in VMX
operation (see Appendix A.6).

.RE

.SH FLAGS AFFECTED
See the operation section and Section 31.2.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If executed outside VMX operation with CPL&gt;0 or with invalid CR0 or CR4 fixed bits.
T}
	If executed in A20M mode.
	T{
If the memory source operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
	T{
If the DS, ES, FS, or GS register contains an unusable segment.
T}
	T{
If the source operand is located in an execute-only code segment.
T}
	If the value of the IA32_FEATURE_CONTROL MSR does not support entry to VMX operation in the current processor mode.
#PF(fault-code)	T{
If a page fault occurs in accessing the memory source operand.
T}
#SS(0)	T{
If the memory source operand effective address is outside the SS segment limit.
T}
	T{
If the SS register contains an unusable segment.
T}
#UD	If operand is a register.
	If executed with CR4.VMXE = 0.
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
The VMXON instruction is not recognized in real-address mode.
T}
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
The VMXON instruction is not recognized in virtual-8086 mode.
T}
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
The VMXON instruction is not recognized in compatibility mode.
T}
.TE

.SH 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If executed outside VMX operation with CPL &gt; 0 or with invalid CR0 or CR4 fixed bits.
T}
	If executed in A20M mode.
	T{
If the source operand is in the CS, DS, ES, FS, or GS segments and the memory address is in a non-canonical form.
T}
.TE

.PP
If the value of the IA32_FEATURE_CONTROL MSR does not support entry to
VMX operation in the current processor mode.

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#PF(fault-code)	T{
If a page fault occurs in accessing the memory source operand.
T}
#SS(0)	T{
If the source operand is in the SS segment and the memory address is in a non-canonical form.
T}
#UD	If operand is a register.
	If executed with CR4.VMXE = 0.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
