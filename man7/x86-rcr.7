'\" t
.nh
.TH "X86-RCL-RCR-ROL-ROR" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
RCL-RCR-ROL-ROR - ROTATE
\fBOpcode1\fP

.TS
allbox;
l l l l l l 
l l l l l l .
\fB\fP	\fBInstruction\fP	\fBOp/En\fP	\fB64-Bit Mode\fP	\fBCompat/Leg Mode\fP	\fBDescription\fP
D0 /2	RCL r/m8, 1	M1	Valid	Valid	T{
Rotate 9 bits (CF, r/m8) left once.
T}
REX + D0 /2	RCL r/m82, 1	M1	Valid	N.E.	T{
Rotate 9 bits (CF, r/m8) left once.
T}
D2 /2	RCL r/m8, CL	MC	Valid	Valid	T{
Rotate 9 bits (CF, r/m8) left CL times.
T}
REX + D2 /2	RCL r/m82, CL	MC	Valid	N.E.	T{
Rotate 9 bits (CF, r/m8) left CL times.
T}
C0 /2 ib	RCL r/m8, imm8	MI	Valid	Valid	T{
Rotate 9 bits (CF, r/m8) left imm8 times.
T}
REX + C0 /2 ib	RCL r/m82, imm8	MI	Valid	N.E.	T{
Rotate 9 bits (CF, r/m8) left imm8 times.
T}
D1 /2	RCL r/m16, 1	M1	Valid	Valid	T{
Rotate 17 bits (CF, r/m16) left once.
T}
D3 /2	RCL r/m16, CL	MC	Valid	Valid	T{
Rotate 17 bits (CF, r/m16) left CL times.
T}
C1 /2 ib	RCL r/m16, imm8	MI	Valid	Valid	T{
Rotate 17 bits (CF, r/m16) left imm8 times.
T}
D1 /2	RCL r/m32, 1	M1	Valid	Valid	T{
Rotate 33 bits (CF, r/m32) left once.
T}
REX.W + D1 /2	RCL r/m64, 1	M1	Valid	N.E.	T{
Rotate 65 bits (CF, r/m64) left once. Uses a 6 bit count.
T}
D3 /2	RCL r/m32, CL	MC	Valid	Valid	T{
Rotate 33 bits (CF, r/m32) left CL times.
T}
REX.W + D3 /2	RCL r/m64, CL	MC	Valid	N.E.	T{
Rotate 65 bits (CF, r/m64) left CL times. Uses a 6 bit count.
T}
C1 /2 ib	RCL r/m32, imm8	MI	Valid	Valid	T{
Rotate 33 bits (CF, r/m32) left imm8 times.
T}
REX.W + C1 /2 ib	RCL r/m64, imm8	MI	Valid	N.E.	T{
Rotate 65 bits (CF, r/m64) left imm8 times. Uses a 6 bit count.
T}
D0 /3	RCR r/m8, 1	M1	Valid	Valid	T{
Rotate 9 bits (CF, r/m8) right once.
T}
REX + D0 /3	RCR r/m82, 1	M1	Valid	N.E.	T{
Rotate 9 bits (CF, r/m8) right once.
T}
D2 /3	RCR r/m8, CL	MC	Valid	Valid	T{
Rotate 9 bits (CF, r/m8) right CL times.
T}
REX + D2 /3	RCR r/m82, CL	MC	Valid	N.E.	T{
Rotate 9 bits (CF, r/m8) right CL times.
T}
C0 /3 ib	RCR r/m8, imm8	MI	Valid	Valid	T{
Rotate 9 bits (CF, r/m8) right imm8 times.
T}
REX + C0 /3 ib	RCR r/m82, imm8	MI	Valid	N.E.	T{
Rotate 9 bits (CF, r/m8) right imm8 times.
T}
D1 /3	RCR r/m16, 1	M1	Valid	Valid	T{
Rotate 17 bits (CF, r/m16) right once.
T}
D3 /3	RCR r/m16, CL	MC	Valid	Valid	T{
Rotate 17 bits (CF, r/m16) right CL times.
T}
C1 /3 ib	RCR r/m16, imm8	MI	Valid	Valid	T{
Rotate 17 bits (CF, r/m16) right imm8 times.
T}
D1 /3	RCR r/m32, 1	M1	Valid	Valid	T{
Rotate 33 bits (CF, r/m32) right once. Uses a 6 bit count.
T}
REX.W + D1 /3	RCR r/m64, 1	M1	Valid	N.E.	T{
Rotate 65 bits (CF, r/m64) right once. Uses a 6 bit count.
T}
D3 /3	RCR r/m32, CL	MC	Valid	Valid	T{
Rotate 33 bits (CF, r/m32) right CL times.
T}
REX.W + D3 /3	RCR r/m64, CL	MC	Valid	N.E.	T{
Rotate 65 bits (CF, r/m64) right CL times. Uses a 6 bit count.
T}
C1 /3 ib	RCR r/m32, imm8	MI	Valid	Valid	T{
Rotate 33 bits (CF, r/m32) right imm8 times.
T}
REX.W + C1 /3 ib	RCR r/m64, imm8	MI	Valid	N.E.	T{
Rotate 65 bits (CF, r/m64) right imm8 times. Uses a 6 bit count.
T}
D0 /0	ROL r/m8, 1	M1	Valid	Valid	Rotate 8 bits r/m8 left once.
REX + D0 /0	ROL r/m82, 1	M1	Valid	N.E.	Rotate 8 bits r/m8 left once
D2 /0	ROL r/m8, CL	MC	Valid	Valid	T{
Rotate 8 bits r/m8 left CL times.
T}
REX + D2 /0	ROL r/m82, CL	MC	Valid	N.E.	T{
Rotate 8 bits r/m8 left CL times.
T}
C0 /0 ib	ROL r/m8, imm8	MI	Valid	Valid	T{
Rotate 8 bits r/m8 left imm8 times.
T}
.TE

.PP
\fBOpcode1\fP

.TS
allbox;
l l l l l l 
l l l l l l .
\fB\fP	\fBInstruction\fP	\fBOp/En\fP	\fB64-Bit Mode\fP	\fBCompat/Leg Mode\fP	\fBDescription\fP
REX + C0 /0 ib	ROL r/m82, imm8	MI	Valid	N.E.	T{
Rotate 8 bits r/m8 left imm8 times.
T}
D1 /0	ROL r/m16, 1	M1	Valid	Valid	T{
Rotate 16 bits r/m16 left once.
T}
D3 /0	ROL r/m16, CL	MC	Valid	Valid	T{
Rotate 16 bits r/m16 left CL times.
T}
C1 /0 ib	ROL r/m16, imm8	MI	Valid	Valid	T{
Rotate 16 bits r/m16 left imm8 times.
T}
D1 /0	ROL r/m32, 1	M1	Valid	Valid	T{
Rotate 32 bits r/m32 left once.
T}
REX.W + D1 /0	ROL r/m64, 1	M1	Valid	N.E.	T{
Rotate 64 bits r/m64 left once. Uses a 6 bit count.
T}
D3 /0	ROL r/m32, CL	MC	Valid	Valid	T{
Rotate 32 bits r/m32 left CL times.
T}
REX.W + D3 /0	ROL r/m64, CL	MC	Valid	N.E.	T{
Rotate 64 bits r/m64 left CL times. Uses a 6 bit count.
T}
C1 /0 ib	ROL r/m32, imm8	MI	Valid	Valid	T{
Rotate 32 bits r/m32 left imm8 times.
T}
REX.W + C1 /0 ib	ROL r/m64, imm8	MI	Valid	N.E.	T{
Rotate 64 bits r/m64 left imm8 times. Uses a 6 bit count.
T}
D0 /1	ROR r/m8, 1	M1	Valid	Valid	Rotate 8 bits r/m8 right once.
REX + D0 /1	ROR r/m82, 1	M1	Valid	N.E.	Rotate 8 bits r/m8 right once.
D2 /1	ROR r/m8, CL	MC	Valid	Valid	T{
Rotate 8 bits r/m8 right CL times.
T}
REX + D2 /1	ROR r/m82, CL	MC	Valid	N.E.	T{
Rotate 8 bits r/m8 right CL times.
T}
C0 /1 ib	ROR r/m8, imm8	MI	Valid	Valid	T{
Rotate 8 bits r/m16 right imm8 times.
T}
REX + C0 /1 ib	ROR r/m82, imm8	MI	Valid	N.E.	T{
Rotate 8 bits r/m16 right imm8 times.
T}
D1 /1	ROR r/m16, 1	M1	Valid	Valid	T{
Rotate 16 bits r/m16 right once.
T}
D3 /1	ROR r/m16, CL	MC	Valid	Valid	T{
Rotate 16 bits r/m16 right CL times.
T}
C1 /1 ib	ROR r/m16, imm8	MI	Valid	Valid	T{
Rotate 16 bits r/m16 right imm8 times.
T}
D1 /1	ROR r/m32, 1	M1	Valid	Valid	T{
Rotate 32 bits r/m32 right once.
T}
REX.W + D1 /1	ROR r/m64, 1	M1	Valid	N.E.	T{
Rotate 64 bits r/m64 right once. Uses a 6 bit count.
T}
D3 /1	ROR r/m32, CL	MC	Valid	Valid	T{
Rotate 32 bits r/m32 right CL times.
T}
REX.W + D3 /1	ROR r/m64, CL	MC	Valid	N.E.	T{
Rotate 64 bits r/m64 right CL times. Uses a 6 bit count.
T}
C1 /1 ib	ROR r/m32, imm8	MI	Valid	Valid	T{
Rotate 32 bits r/m32 right imm8 times.
T}
REX.W + C1 /1 ib	ROR r/m64, imm8	MI	Valid	N.E.	T{
Rotate 64 bits r/m64 right imm8 times. Uses a 6 bit count.
T}
.TE

.PP
.RS

.PP
1\&. See the IA-32 Architecture Compatibility section below.

.PP
2\&. In 64-bit mode, r/m8 can not be encoded to access the following
byte registers if a REX prefix is used: AH, BH, CH, DH.

.RE

.SH INSTRUCTION OPERAND ENCODING  href="./rcl:rcr:rol:ror.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
M1	ModRM:r/m (w)	1	N/A	N/A
MC	ModRM:r/m (w)	CL	N/A	N/A
MI	ModRM:r/m (w)	imm8	N/A	N/A
.TE

.SH DESCRIPTION
Shifts (rotates) the bits of the first operand (destination operand) the
number of bit positions specified in the second operand (count operand)
and stores the result in the destination operand. The destination
operand can be a register or a memory location; the count operand is an
unsigned integer that can be an immediate or a value in the CL register.
The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W =
1).

.PP
The rotate left (ROL) and rotate through carry left (RCL) instructions
shift all the bits toward more-significant bit positions, except for the
most-significant bit, which is rotated to the least-significant bit
location. The rotate right (ROR) and rotate through carry right (RCR)
instructions shift all the bits toward less significant bit positions,
except for the least-significant bit, which is rotated to the
most-significant bit location.

.PP
The RCL and RCR instructions include the CF flag in the rotation. The
RCL instruction shifts the CF flag into the least-significant bit and
shifts the most-significant bit into the CF flag. The RCR instruction
shifts the CF flag into the most-significant bit and shifts the
least-significant bit into the CF flag. For the ROL and ROR
instructions, the original value of the CF flag is not a part of the
result, but the CF flag receives a copy of the bit that was shifted from
one end to the other.

.PP
The OF flag is defined only for the 1-bit rotates; it is undefined in
all other cases (except RCL and RCR instructions only: a zero-bit rotate
does nothing, that is affects no flags). For left rotates, the OF flag
is set to the exclusive OR of the CF bit (after the rotate) and the
most-significant bit of the result. For right rotates, the OF flag is
set to the exclusive OR of the two most-significant bits of the result.

.PP
In 64-bit mode, using a REX prefix in the form of REX.R permits access
to additional registers (R8-R15). Use of REX.W promotes the first
operand to 64 bits and causes the count operand to become a 6-bit
counter.

.SH IA-32 ARCHITECTURE COMPATIBILITY  href="./rcl:rcr:rol:ror.html#ia-32-architecture-compatibility"
class="anchor">¶

.PP
The 8086 does not mask the rotation count. However, all other IA-32
processors (starting with the Intel 286 processor) do mask the rotation
count to 5 bits, resulting in a maximum count of 31. This masking is
done in all operating modes (including the virtual-8086 mode) to reduce
the maximum execution time of the instructions.

.SH OPERATION
.SS (* RCL AND RCR INSTRUCTIONS *)  href="./rcl:rcr:rol:ror.html#---rcl-and-rcr-instructions---"
class="anchor">¶

.EX
SIZE := OperandSize;
CASE (determine count) OF
    SIZE := 8:
        tempCOUNT := (COUNT AND 1FH) MOD 9;
    SIZE := 16:
        tempCOUNT := (COUNT AND 1FH) MOD 17;
    SIZE := 32:
        tempCOUNT := COUNT AND 1FH;
    SIZE := 64:
        tempCOUNT := COUNT AND 3FH;
ESAC;
IF OperandSize = 64
    THEN COUNTMASK = 3FH;
    ELSE COUNTMASK = 1FH;
FI;
.EE

.SS (* RCL INSTRUCTION OPERATION *)  href="./rcl:rcr:rol:ror.html#---rcl-instruction-operation---"
class="anchor">¶

.EX
WHILE (tempCOUNT ≠ 0)
    DO
        tempCF := MSB(DEST);
        DEST := (DEST ∗ 2) + CF;
        CF := tempCF;
        tempCOUNT := tempCOUNT – 1;
    OD;
ELIHW;
IF (COUNT & COUNTMASK) = 1
    THEN OF := MSB(DEST) XOR CF;
    ELSE OF is undefined;
FI;
.EE

.SS (* RCR INSTRUCTION OPERATION *)  href="./rcl:rcr:rol:ror.html#---rcr-instruction-operation---"
class="anchor">¶

.EX
IF (COUNT & COUNTMASK) = 1
    THEN OF := MSB(DEST) XOR CF;
    ELSE OF is undefined;
FI;
WHILE (tempCOUNT ≠ 0)
    DO
        tempCF := LSB(SRC);
        DEST := (DEST / 2) + (CF * 2SIZE);
        CF := tempCF;
        tempCOUNT := tempCOUNT – 1;
    OD;
.EE

.SS (* ROL INSTRUCTION OPERATION *)  href="./rcl:rcr:rol:ror.html#---rol-instruction-operation---"
class="anchor">¶

.EX
tempCOUNT := (COUNT & COUNTMASK) MOD SIZE
WHILE (tempCOUNT ≠ 0)
    DO
        tempCF := MSB(DEST);
        DEST := (DEST ∗ 2) + tempCF;
        tempCOUNT := tempCOUNT – 1;
    OD;
ELIHW;
IF (COUNT & COUNTMASK) ≠ 0
    THEN CF := LSB(DEST);
FI;
IF (COUNT & COUNTMASK) = 1
    THEN OF := MSB(DEST) XOR CF;
    ELSE OF is undefined;
FI;
.EE

.SS (* ROR INSTRUCTION OPERATION *)  href="./rcl:rcr:rol:ror.html#---ror-instruction-operation---"
class="anchor">¶

.EX
tempCOUNT := (COUNT & COUNTMASK) MOD SIZE
WHILE (tempCOUNT ≠ 0)
    DO
        tempCF := LSB(SRC);
        DEST := (DEST / 2) + (tempCF ∗ 2SIZE);
        tempCOUNT := tempCOUNT – 1;
    OD;
ELIHW;
IF (COUNT & COUNTMASK) ≠ 0
    THEN CF := MSB(DEST);
FI;
IF (COUNT & COUNTMASK) = 1
    THEN OF := MSB(DEST) XOR MSB − 1(DEST);
    ELSE OF is undefined;
FI;
.EE

.SH FLAGS AFFECTED
For RCL and RCR instructions, a zero-bit rotate does nothing, i.e.,
affects no flags. For ROL and ROR instructions, if the masked count is
0, the flags are not affected. If the masked count is 1, then the OF
flag is affected, otherwise (masked count is greater than 1) the OF flag
is undefined.

.PP
For all instructions, the CF flag is affected when the masked count is
non-zero. The SF, ZF, AF, and PF flags are always unaffected.

.SH PROTECTED MODE EXCEPTIONS  href="./rcl:rcr:rol:ror.html#protected-mode-exceptions"
class="anchor">¶

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the source operand is located in a non-writable segment.
T}
	T{
If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
	T{
If the DS, ES, FS, or GS register contains a NULL segment selector.
T}
#SS(0)	T{
If a memory operand effective address is outside the SS segment limit.
T}
#PF(fault-code)	If a page fault occurs.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
T}
#UD	If the LOCK prefix is used.
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS  href="./rcl:rcr:rol:ror.html#real-address-mode-exceptions"
class="anchor">¶

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP	T{
If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
#SS	T{
If a memory operand effective address is outside the SS segment limit.
T}
#UD	If the LOCK prefix is used.
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS  href="./rcl:rcr:rol:ror.html#virtual-8086-mode-exceptions"
class="anchor">¶

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
#SS(0)	T{
If a memory operand effective address is outside the SS segment limit.
T}
#PF(fault-code)	If a page fault occurs.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made.
T}
#UD	If the LOCK prefix is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS  href="./rcl:rcr:rol:ror.html#compatibility-mode-exceptions"
class="anchor">¶

.PP
Same exceptions as in protected mode.

.SH 64-BIT MODE EXCEPTIONS  href="./rcl:rcr:rol:ror.html#64-bit-mode-exceptions"
class="anchor">¶

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#SS(0)	T{
If a memory address referencing the SS segment is in a non-canonical form.
T}
#GP(0)	T{
If the source operand is located in a nonwritable segment.
T}
	T{
If the memory address is in a non-canonical form.
T}
#PF(fault-code)	If a page fault occurs.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
T}
#UD	If the LOCK prefix is used.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
