'\" t
.nh
.TH "X86-EDBGRD" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
EDBGRD - READ FROM A DEBUG ENCLAVE
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
EAX = 04H ENCLS[EDBGRD]	IR	V/V	SGX1	T{
This leaf function reads a dword/quadword from a debug enclave.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP
Op/En	EAX		RBX	RCX
IR	EDBGRD (In)	Return error code (Out)	T{
Data read from a debug enclave (Out)
T}	T{
Address of source memory in the EPC (In)
T}
.TE

.SS DESCRIPTION
This leaf function copies a quadword/doubleword from an EPC page
belonging to a debug enclave into the RBX register. Eight bytes are read
in 64-bit mode, four bytes are read in non-64-bit modes. The size of
data read cannot be overridden.

.PP
The effective address of the source location inside the EPC is provided
in the register RCX.

.SH EDBGRD MEMORY PARAMETER SEMANTICS  href="edbgrd.html#edbgrd-memory-parameter-semantics"
class="anchor">¶

.TS
allbox;
l 
l .
\fB\fP
EPCQW
T{
Read access permitted by Enclave
T}
.TE

.PP
The error codes are:

.PP
The instruction faults if any of the following:

.SH EDBGRD FAULTING CONDITIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
T{
RCX points into a page that is an SECS.
T}	T{
RCX does not resolve to a naturally aligned linear address.
T}
T{
RCX points to a page that does not belong to an enclave that is in debug mode.
T}	T{
RCX points to a location inside a TCS that is beyond the architectural size of the TCS (SGX_TCS_LIMIT).
T}
T{
An operand causing any segment violation.
T}	May page fault.
CPL &gt; 0.	
.TE

.PP
This instruction ignores the EPCM RWX attributes on the enclave page.
Consequently, violation of EPCM RWX attributes via EDBGRD does not
result in a #GP.

.SS CONCURRENCY RESTRICTIONS
.SS OPERATION
.SH TEMP VARIABLES IN EDBGRD OPERATIONAL FLOW  href="edbgrd.html#temp-variables-in-edbgrd-operational-flow"
class="anchor">¶

.TS
allbox;
l l l l 
l l l l .
\fBName\fP	\fBType\fP	\fBSize (Bits)\fP	\fBDescription\fP
TMP_MODE64	Binary	1	((IA32_EFER.LMA = 1) && (CS.L = 1))
TMP_SECS		64	T{
Physical address of SECS of the enclave to which source operand belongs.
T}
.TE

.PP
TMP_MODE64 := ((IA32_EFER.LMA = 1) && (CS.L = 1));

.PP
IF ( (TMP_MODE64 = 1) and (DS:RCX is not 8Byte Aligned) )

.PP
THEN #GP(0); FI;

.PP
IF ( (TMP_MODE64 = 0) and (DS:RCX is not 4Byte Aligned) )

.PP
THEN #GP(0); FI;

.PP
IF (DS:RCX does not resolve within an EPC)

.PP
THEN #PF(DS:RCX); FI;

.PP
(* make sure no other Intel SGX instruction is accessing the same EPCM
entry *)

.PP
IF (Another instruction modifying the same EPCM entry is executing)

.PP
THEN #GP(0); FI;

.PP
IF (EPCM(DS:RCX).VALID = 0)

.PP
THEN #PF(DS:RCX); FI;

.PP
(* make sure that DS:RCX (SOURCE) is pointing to a PT_REG or PT_TCS
or PT_VA or PT_SS_FIRST or PT_SS_REST *)

.PP
IF ( (EPCM(DS:RCX).PT ≠ PT_REG) and (EPCM(DS:RCX).PT ≠ PT_TCS) and
(EPCM(DS:RCX).PT ≠ PT_VA)

.PP
and (EPCM(DS:RCX).PT ≠ PT_SS_FIRST) and (EPCM(DS:RCX).PT ≠
PT_SS_REST))

.PP
THEN #PF(DS:RCX); FI;

.PP
(* make sure that DS:RCX points to an accessible EPC page *)

.PP
IF (EPCM(DS:RCX).PENDING is not 0 or (EPCM(DS:RCX).MODIFIED is not 0) )

.PP
THEN

.PP
RFLAGS.ZF := 1;

.PP
RAX := SGX_PAGE_NOT_DEBUGGABLE;

.PP
GOTO DONE;

.PP
FI;

.PP
(* If source is a TCS, then make sure that the offset into the page is
not beyond the TCS size*) IF ( ( EPCM(DS:RCX). PT = PT_TCS) and
((DS:RCX) & FFFH ≥ SGX_TCS_LIMIT) ) THEN #GP(0); FI;

.PP
(* make sure the enclave owning the PT_REG or PT_TCS page allow debug
*)

.PP
IF ( (EPCM(DS:RCX).PT = PT_REG) or (EPCM(DS:RCX).PT = PT_TCS) )

.PP
THEN

.PP
TMP_SECS := GET_SECS_ADDRESS;

.PP
IF (TMP_SECS.ATTRIBUTES.DEBUG = 0)

.PP
THEN #GP(0); FI;

.PP
IF ( (TMP_MODE64 = 1) )

.PP
THEN RBX[63:0] := (DS:RCX)[63:0];

.PP
ELSE EBX[31:0] := (DS:RCX)[31:0];

.PP
FI;

.PP
ELSE

.PP
TMP_64BIT_VAL[63:0] := (DS:RCX)[63:0] & (~07H); // Read contents
from VA slot

.PP
IF (TMP_MODE64 = 1)

.PP
THEN

.PP
IF (TMP_64BIT_VAL ≠ 0H)

.PP
THEN RBX[63:0] := 0FFFFFFFFFFFFFFFFH;

.PP
ELSE RBX[63:0] := 0H;

.PP
FI;

.PP
ELSE

.PP
IF (TMP_64BIT_VAL ≠ 0H)

.PP
THEN EBX[31:0] := 0FFFFFFFFH;

.PP
ELSE EBX[31:0] := 0H;

.PP
FI;

.PP
FI;

.PP
(* clear EAX and ZF to indicate successful completion *)

.PP
RAX := 0;

.PP
RFLAGS.ZF := 0;

.PP
DONE:

.PP
(* clear flags *)

.PP
RFLAGS.CF,PF,AF,OF,SF := 0;

.SS FLAGS AFFECTED
ZF is set if the page is MODIFIED or PENDING; RAX contains the error
code. Otherwise ZF is cleared and RAX is set to 0. CF, PF, AF, OF, SF
are cleared.

.SS PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the address in RCS violates DS limit or access rights.
T}
	If DS segment is unusable.
	T{
If RCX points to a memory location not 4Byte-aligned.
T}
	T{
If the address in RCX points to a page belonging to a non-debug enclave.
T}
	T{
If the address in RCX points to a page which is not PT_TCS, PT_REG or PT_VA.
T}
	T{
If the address in RCX points to a location inside TCS that is beyond SGX_TCS_LIMIT.
T}
#PF(error	T{
code) If a page fault occurs in accessing memory operands.
T}
	T{
If the address in RCX points to a non-EPC page.
T}
	T{
If the address in RCX points to an invalid EPC page.
T}
.TE

.SS 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	If RCX is non-canonical form.
	T{
If RCX points to a memory location not 8Byte-aligned.
T}
	T{
If the address in RCX points to a page belonging to a non-debug enclave.
T}
	T{
If the address in RCX points to a page which is not PT_TCS, PT_REG or PT_VA.
T}
	T{
If the address in RCX points to a location inside TCS that is beyond SGX_TCS_LIMIT.
T}
#PF(error	T{
code) If a page fault occurs in accessing memory operands.
T}
	T{
If the address in RCX points to a non-EPC page.
T}
	T{
If the address in RCX points to an invalid EPC page.
T}
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
