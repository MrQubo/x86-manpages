'\" t
.nh
.TH "X86-IDIV" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
IDIV - SIGNED DIVIDE
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOpcode\fP	\fBInstruction\fP	\fBOp/En\fP	\fB64-Bit Mode\fP	\fBCompat/Leg Mode\fP	\fBDescription\fP
F6 /7	IDIV r/m8	M	Valid	Valid	T{
Signed divide AX by r/m8, with result stored in: AL := Quotient, AH := Remainder.
T}
REX + F6 /7	IDIV r/m81	M	Valid	N.E.	T{
Signed divide AX by r/m8, with result stored in AL := Quotient, AH := Remainder.
T}
F7 /7	IDIV r/m16	M	Valid	Valid	T{
Signed divide DX:AX by r/m16, with result stored in AX := Quotient, DX := Remainder.
T}
F7 /7	IDIV r/m32	M	Valid	Valid	T{
Signed divide EDX:EAX by r/m32, with result stored in EAX := Quotient, EDX := Remainder.
T}
REX.W + F7 /7	IDIV r/m64	M	Valid	N.E.	T{
Signed divide RDX:RAX by r/m64, with result stored in RAX := Quotient, RDX := Remainder.
T}
.TE

.PP
.RS

.PP
1\&. In 64-bit mode, r/m8 can not be encoded to access the following
byte registers if a REX prefix is used: AH, BH, CH, DH.

.RE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
M	ModRM:r/m (r)	N/A	N/A	N/A
.TE

.SH DESCRIPTION
Divides the (signed) value in the AX, DX:AX, or EDX:EAX (dividend) by
the source operand (divisor) and stores the result in the AX (AH:AL),
DX:AX, or EDX:EAX registers. The source operand can be a general-purpose
register or a memory location. The action of this instruction depends on
the operand size (dividend/divisor).

.PP
Non-integral results are truncated (chopped) towards 0. The remainder is
always less than the divisor in magnitude. Overflow is indicated with
the #DE (divide error) exception rather than with the CF flag.

.PP
In 64-bit mode, the instruction’s default operation size is 32 bits. Use
of the REX.R prefix permits access to additional registers (R8-R15). Use
of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when
REX.W is applied, the instruction divides the signed value in RDX:RAX by
the source operand. RAX contains a 64-bit quotient; RDX contains a
64-bit remainder.

.PP
See the summary chart at the beginning of this section for encoding data
and limits. See Table 3-51
\[la]idiv.html#tbl\-3\-51\[ra]\&.

.SH OPERATION
.EX
IF SRC = 0
    THEN #DE; (* Divide error *)
FI;
IF OperandSize = 8 (* Word/byte operation *)
    THEN
        temp := AX / SRC; (* Signed division *)
        IF (temp > 7FH) or (temp < 80H)
        (* If a positive result is greater than 7FH or a negative result is less than 80H *)
            THEN #DE; (* Divide error *)
            ELSE
                AL := temp;
                AH := AX SignedModulus SRC;
        FI;
    ELSE IF OperandSize = 16 (* Doubleword/word operation *)
        THEN
            temp := DX:AX / SRC; (* Signed division *)
            IF (temp > 7FFFH) or (temp < 8000H)
            (* If a positive result is greater than 7FFFH
            or a negative result is less than 8000H *)
                THEN
                    #DE; (* Divide error *)
                ELSE
                    AX := temp;
                    DX := DX:AX SignedModulus SRC;
            FI;
        FI;
    ELSE IF OperandSize = 32 (* Quadword/doubleword operation *)
            temp := EDX:EAX / SRC; (* Signed division *)
            IF (temp > 7FFFFFFFH) or (temp < 80000000H)
            (* If a positive result is greater than 7FFFFFFFH
            or a negative result is less than 80000000H *)
                THEN
                    #DE; (* Divide error *)
                ELSE
                    EAX := temp;
                    EDX := EDXE:AX SignedModulus SRC;
            FI;
        FI;
    ELSE IF OperandSize = 64 (* Doublequadword/quadword operation *)
            temp := RDX:RAX / SRC; (* Signed division *)
            IF (temp > 7FFFFFFFFFFFFFFFH) or (temp < 8000000000000000H)
            (* If a positive result is greater than 7FFFFFFFFFFFFFFFH
            or a negative result is less than 8000000000000000H *)
                THEN
                    #DE; (* Divide error *)
                ELSE
                    RAX := temp;
                    RDX := RDE:RAX SignedModulus SRC;
            FI;
        FI;
FI;
.EE

.SH FLAGS AFFECTED
The CF, OF, SF, ZF, AF, and PF flags are undefined.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#DE	T{
If the source operand (divisor) is 0.
T}
	T{
The signed result (quotient) is too large for the destination.
T}
#GP(0)	T{
If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
	T{
If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.
T}
#SS(0)	T{
If a memory operand effective address is outside the SS segment limit.
T}
#PF(fault-code)	If a page fault occurs.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
T}
#UD	If the LOCK prefix is used.
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#DE	T{
If the source operand (divisor) is 0.
T}
	T{
The signed result (quotient) is too large for the destination.
T}
#GP	T{
If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
#SS	T{
If a memory operand effective address is outside the SS segment limit.
T}
#UD	If the LOCK prefix is used.
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#DE	T{
If the source operand (divisor) is 0.
T}
	T{
The signed result (quotient) is too large for the destination.
T}
#GP(0)	T{
If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
#SS(0)	T{
If a memory operand effective address is outside the SS segment limit.
T}
#PF(fault-code)	If a page fault occurs.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made.
T}
#UD	If the LOCK prefix is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#SS(0)	T{
If a memory address referencing the SS segment is in a non-canonical form.
T}
#GP(0)	T{
If the memory address is in a non-canonical form.
T}
#DE	T{
If the source operand (divisor) is 0
T}
	T{
If the quotient is too large for the designated register.
T}
#PF(fault-code)	If a page fault occurs.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
T}
#UD	If the LOCK prefix is used.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
