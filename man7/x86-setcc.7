'\" t
.nh
.TH "X86-SETCC" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
SETCC - SET BYTE ON CONDITION
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOpcode\fP	\fBInstruction\fP	\fBOp/En\fP	\fB64-Bit Mode\fP	\fBCompat/Leg Mode\fP	\fBDescription\fP
0F 97	SETA r/m8	M	Valid	Valid	T{
Set byte if above (CF=0 and ZF=0).
T}
REX + 0F 97	SETA r/m81	M	Valid	N.E.	T{
Set byte if above (CF=0 and ZF=0).
T}
0F 93	SETAE r/m8	M	Valid	Valid	T{
Set byte if above or equal (CF=0).
T}
REX + 0F 93	SETAE r/m81	M	Valid	N.E.	T{
Set byte if above or equal (CF=0).
T}
0F 92	SETB r/m8	M	Valid	Valid	Set byte if below (CF=1).
REX + 0F 92	SETB r/m81	M	Valid	N.E.	Set byte if below (CF=1).
0F 96	SETBE r/m8	M	Valid	Valid	T{
Set byte if below or equal (CF=1 or ZF=1).
T}
REX + 0F 96	SETBE r/m81	M	Valid	N.E.	T{
Set byte if below or equal (CF=1 or ZF=1).
T}
0F 92	SETC r/m8	M	Valid	Valid	Set byte if carry (CF=1).
REX + 0F 92	SETC r/m81	M	Valid	N.E.	Set byte if carry (CF=1).
0F 94	SETE r/m8	M	Valid	Valid	Set byte if equal (ZF=1).
REX + 0F 94	SETE r/m81	M	Valid	N.E.	Set byte if equal (ZF=1).
0F 9F	SETG r/m8	M	Valid	Valid	T{
Set byte if greater (ZF=0 and SF=OF).
T}
REX + 0F 9F	SETG r/m81	M	Valid	N.E.	T{
Set byte if greater (ZF=0 and SF=OF).
T}
0F 9D	SETGE r/m8	M	Valid	Valid	T{
Set byte if greater or equal (SF=OF).
T}
REX + 0F 9D	SETGE r/m81	M	Valid	N.E.	T{
Set byte if greater or equal (SF=OF).
T}
0F 9C	SETL r/m8	M	Valid	Valid	Set byte if less (SF≠ OF).
REX + 0F 9C	SETL r/m81	M	Valid	N.E.	Set byte if less (SF≠ OF).
0F 9E	SETLE r/m8	M	Valid	Valid	T{
Set byte if less or equal (ZF=1 or SF≠ OF).
T}
REX + 0F 9E	SETLE r/m81	M	Valid	N.E.	T{
Set byte if less or equal (ZF=1 or SF≠ OF).
T}
0F 96	SETNA r/m8	M	Valid	Valid	T{
Set byte if not above (CF=1 or ZF=1).
T}
REX + 0F 96	SETNA r/m81	M	Valid	N.E.	T{
Set byte if not above (CF=1 or ZF=1).
T}
0F 92	SETNAE r/m8	M	Valid	Valid	T{
Set byte if not above or equal (CF=1).
T}
REX + 0F 92	SETNAE r/m81	M	Valid	N.E.	T{
Set byte if not above or equal (CF=1).
T}
0F 93	SETNB r/m8	M	Valid	Valid	Set byte if not below (CF=0).
REX + 0F 93	SETNB r/m81	M	Valid	N.E.	Set byte if not below (CF=0).
0F 97	SETNBE r/m8	M	Valid	Valid	T{
Set byte if not below or equal (CF=0 and ZF=0).
T}
REX + 0F 97	SETNBE r/m81	M	Valid	N.E.	T{
Set byte if not below or equal (CF=0 and ZF=0).
T}
0F 93	SETNC r/m8	M	Valid	Valid	Set byte if not carry (CF=0).
REX + 0F 93	SETNC r/m81	M	Valid	N.E.	Set byte if not carry (CF=0).
0F 95	SETNE r/m8	M	Valid	Valid	Set byte if not equal (ZF=0).
REX + 0F 95	SETNE r/m81	M	Valid	N.E.	Set byte if not equal (ZF=0).
0F 9E	SETNG r/m8	M	Valid	Valid	T{
Set byte if not greater (ZF=1 or SF≠ OF)
T}
REX + 0F 9E	SETNG r/m81	M	Valid	N.E.	T{
Set byte if not greater (ZF=1 or SF≠ OF).
T}
0F 9C	SETNGE r/m8	M	Valid	Valid	T{
Set byte if not greater or equal (SF≠ OF).
T}
REX + 0F 9C	SETNGE r/m81	M	Valid	N.E.	T{
Set byte if not greater or equal (SF≠ OF).
T}
0F 9D	SETNL r/m8	M	Valid	Valid	Set byte if not less (SF=OF).
REX + 0F 9D	SETNL r/m81	M	Valid	N.E.	Set byte if not less (SF=OF).
0F 9F	SETNLE r/m8	M	Valid	Valid	T{
Set byte if not less or equal (ZF=0 and SF=OF).
T}
REX + 0F 9F	SETNLE r/m81	M	Valid	N.E.	T{
Set byte if not less or equal (ZF=0 and SF=OF).
T}
0F 91	SETNO r/m8	M	Valid	Valid	T{
Set byte if not overflow (OF=0).
T}
REX + 0F 91	SETNO r/m81	M	Valid	N.E.	T{
Set byte if not overflow (OF=0).
T}
0F 9B	SETNP r/m8	M	Valid	Valid	Set byte if not parity (PF=0).
REX + 0F 9B	SETNP r/m81	M	Valid	N.E.	Set byte if not parity (PF=0).
0F 99	SETNS r/m8	M	Valid	Valid	Set byte if not sign (SF=0).
REX + 0F 99	SETNS r/m81	M	Valid	N.E.	Set byte if not sign (SF=0).
0F 95	SETNZ r/m8	M	Valid	Valid	Set byte if not zero (ZF=0).
REX + 0F 95	SETNZ r/m81	M	Valid	N.E.	Set byte if not zero (ZF=0).
0F 90	SETO r/m8	M	Valid	Valid	Set byte if overflow (OF=1)
REX + 0F 90	SETO r/m81	M	Valid	N.E.	Set byte if overflow (OF=1).
0F 9A	SETP r/m8	M	Valid	Valid	Set byte if parity (PF=1).
REX + 0F 9A	SETP r/m81	M	Valid	N.E.	Set byte if parity (PF=1).
0F 9A	SETPE r/m8	M	Valid	Valid	T{
Set byte if parity even (PF=1).
T}
REX + 0F 9A	SETPE r/m81	M	Valid	N.E.	T{
Set byte if parity even (PF=1).
T}
0F 9B	SETPO r/m8	M	Valid	Valid	Set byte if parity odd (PF=0).
REX + 0F 9B	SETPO r/m81	M	Valid	N.E.	Set byte if parity odd (PF=0).
0F 98	SETS r/m8	M	Valid	Valid	Set byte if sign (SF=1).
REX + 0F 98	SETS r/m81	M	Valid	N.E.	Set byte if sign (SF=1).
0F 94	SETZ r/m8	M	Valid	Valid	Set byte if zero (ZF=1).
REX + 0F 94	SETZ r/m81	M	Valid	N.E.	Set byte if zero (ZF=1).
.TE

.PP
.RS

.PP
1\&. In 64-bit mode, r/m8 can not be encoded to access the following
byte registers if a REX prefix is used: AH, BH, CH, DH.

.RE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
M	ModRM:r/m (w)	N/A	N/A	N/A
.TE

.SH DESCRIPTION
Sets the destination operand to 0 or 1 depending on the settings of the
status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The
destination operand points to a byte register or a byte in memory. The
condition code suffix (\fIcc\fP) indicates the condition being tested for.

.PP
The terms “above” and “below” are associated with the CF flag and refer
to the relationship between two unsigned integer values. The terms
“greater” and “less” are associated with the SF and OF flags and refer
to the relationship between two signed integer values.

.PP
Many of the SET\fIcc\fP instruction opcodes have alternate mnemonics. For
example, SETG (set byte if greater) and SETNLE (set if not less or
equal) have the same opcode and test for the same condition: ZF equals 0
and SF equals OF. These alternate mnemonics are provided to make code
more intelligible. Appendix B, “EFLAGS Condition Codes,” in the
Intel® 64 and IA-32 Architectures Software Developer’s
Manual, Volume 1, shows the alternate mnemonics for various test
conditions.

.PP
Some languages represent a logical one as an integer with all bits set.
This representation can be obtained by choosing the logically opposite
condition for the SET\fIcc\fP instruction, then decrementing the result. For
example, to test for overflow, use the SETNO instruction, then decrement
the result.

.PP
The reg field of the ModR/M byte is not used for the SETCC instruction
and those opcode bits are ignored by the processor.

.PP
In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix
enable uniform addressing to additional byte registers. Otherwise, this
instruction’s operation is the same as in legacy mode and compatibility
mode.

.SH OPERATION
.EX
IF condition
    THEN DEST := 1;
    ELSE DEST := 0;
FI;
.EE

.SH FLAGS AFFECTED
None.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the destination is located in a non-writable segment.
T}
	T{
If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
	T{
If the DS, ES, FS, or GS register contains a NULL segment selector.
T}
#SS(0)	T{
If a memory operand effective address is outside the SS segment limit.
T}
#PF(fault-code)	If a page fault occurs.
#UD	If the LOCK prefix is used.
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP	T{
If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
#SS	T{
If a memory operand effective address is outside the SS segment limit.
T}
#UD	If the LOCK prefix is used.
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
#SS(0)	T{
If a memory operand effective address is outside the SS segment limit.
T}
#PF(fault-code)	If a page fault occurs.
#UD	If the LOCK prefix is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#SS(0)	T{
If a memory address referencing the SS segment is in a non-canonical form.
T}
#GP(0)	T{
If the memory address is in a non-canonical form.
T}
#PF(fault-code)	If a page fault occurs.
#UD	If the LOCK prefix is used.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
