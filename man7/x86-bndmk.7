'\" t
.nh
.TH "X86-BNDMK" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
BNDMK - MAKE BOUNDS
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
F3 0F 1B /r BNDMK bnd, m32	RM	N.E./V	MPX	T{
Make lower and upper bounds from m32 and store them in bnd.
T}
F3 0F 1B /r BNDMK bnd, m64	RM	V/N.E.	MPX	T{
Make lower and upper bounds from m64 and store them in bnd.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l 
l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP
RM	ModRM:reg (w)	ModRM:r/m (r)	N/A
.TE

.SH DESCRIPTION
Makes bounds from the second operand and stores the lower and upper
bounds in the bound register bnd. The second operand must be a memory
operand. The content of the base register from the memory operand is
stored in the lower bound bnd.LB. The 1's complement of the effective
address of m32/m64 is stored in the upper bound b.UB. Computation of
m32/m64 has identical behavior to LEA.

.PP
This instruction does not cause any memory access, and does not read or
write any flags.

.PP
If the instruction did not specify base register, the lower bound will
be zero. The reg-reg form of this instruction retains legacy behavior
(NOP).

.PP
The instruction causes an invalid-opcode exception (#UD) if executed in
64-bit mode with RIP-relative addressing.

.SH OPERATION
.EX
BND.LB := SRCMEM.base;
IF 64-bit mode Then
    BND.UB := NOT(LEA.64_bits(SRCMEM));
ELSE
    BND.UB := Zero_Extend.64_bits(NOT(LEA.32_bits(SRCMEM)));
FI;
.EE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="bndmk.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
BNDMKvoid * _bnd_set_ptr_bounds(const void * q, size_t size);
.EE

.SH FLAGS AFFECTED
None.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If the LOCK prefix is used.
	T{
If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.
T}
	T{
If 67H prefix is not used and CS.D=0.
T}
	T{
If 67H prefix is used and CS.D=1.
T}
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If the LOCK prefix is used.
	T{
If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.
T}
	If 16-bit addressing is used.
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If the LOCK prefix is used.
	T{
If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.
T}
	If 16-bit addressing is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If the LOCK prefix is used.
	T{
If ModRM.r/m and REX encodes BND4-BND15 when Intel MPX is enabled.
T}
	T{
If RIP-relative addressing is used.
T}
#SS(0)	T{
If the memory address referencing the SS segment is in a non-canonical form.
T}
#GP(0)	T{
If the memory address is in a non-canonical form.
T}
.TE

.PP
Same exceptions as in protected mode.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
