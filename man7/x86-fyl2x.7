'\" t
.nh
.TH "X86-FYL2X" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
FYL2X - COMPUTE Y ∗ LOG2X
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode\fP	\fBInstruction\fP	\fB64-Bit Mode\fP	\fBCompat/Leg Mode\fP	\fBDescription\fP
D9 F1	FYL2X	Valid	Valid	T{
Replace ST(1) with (ST(1) ∗ log2ST(0)) and pop the register stack.
T}
.TE

.SH DESCRIPTION
Computes (ST(1) ∗ log2 (ST(0))), stores the result in
register ST(1), and pops the FPU register stack. The source operand in
ST(0) must be a non-zero positive number.

.PP
The following table shows the results obtained when taking the log of
various classes of numbers, assuming that neither overflow nor underflow
occurs.

.PP
.RS

.PP
F Means finite floating-point value.

.PP
* Indicatesfloating-pointinvalid-operation(#IA)exception.

.PP
** Indicates floating-point zero-divide (#Z) exception.

.RE

.PP
If the divide-by-zero exception is masked and register ST(0) contains
±0, the instruction returns ∞ with a sign that is the opposite of the
sign of the source operand in register ST(1).

.PP
The FYL2X instruction is designed with a built-in multiplication to
optimize the calculation of logarithms with an arbitrary positive base
(b):

.PP
logbx := (log2b)–1 ∗ log2x

.PP
This instruction’s operation is the same in non-64-bit modes and 64-bit
mode.

.SH OPERATION
.EX
ST(1) := ST(1) ∗ log2ST(0);
PopRegisterStack;
.EE

.SH FPU FLAGS AFFECTED
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
C1	T{
Set to 0 if stack underflow occurred.
T}
	T{
Set if result was rounded up; cleared otherwise.
T}
C0, C2, C3	Undefined.
.TE

.SH FLOATING-POINT EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#IS	Stack underflow occurred.
#IA	T{
Either operand is an SNaN or unsupported format.
T}
	T{
Source operand in register ST(0) is a negative finite value (not -0).
T}
#Z	T{
Source operand in register ST(0) is ±0.
T}
#D	T{
Source operand is a denormal value.
T}
#U	T{
Result is too small for destination format.
T}
#O	T{
Result is too large for destination format.
T}
#P	T{
Value cannot be represented exactly in destination format.
T}
.TE

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#NM	CR0.EM[bit 2] or CR0.TS[bit 3] = 1.
#MF	T{
If there is a pending x87 FPU exception.
T}
#UD	If the LOCK prefix is used.
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH VIRTUAL-8086 MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH COMPATIBILITY MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH 64-BIT MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
