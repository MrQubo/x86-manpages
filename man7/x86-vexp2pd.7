'\" t
.nh
.TH "X86-VEXP2PD" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
VEXP2PD - APPROXIMATION TO THE EXPONENTIAL 2^X OF PACKED DOUBLE PRECISION FLOATING-POINTVALUES WITH LESS THAN 2^-23 RELATIVE ERROR
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
EVEX.512.66.0F38.W1 C8 /r VEXP2PD zmm1 {k1}{z}, zmm2/m512/m64bcst {sae}
T}	A	V/V	AVX512ER	T{
Computes approximations to the exponential 2^x (with less than 2^-23 of maximum relative error) of the packed double precision floating-point values from zmm2/m512/m64bcst and stores the floating-point result in zmm1with writemask k1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En Tuple Type Operand 1 Operand 2 Operand 3 Operand 4\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP
T{
A Full ModRM:reg (r, w) ModRM:r/m (r) N/A N/A
T}					
.TE

.SS DESCRIPTION
Computes the approximate base-2 exponential evaluation of the double
precision floating-point values in the source operand (the second
operand) and stores the results to the destination operand (the first
operand) using the writemask k1. The approximate base-2 exponential is
evaluated with less than 2^-23 of relative error.

.PP
Denormal input values are treated as zeros and do not signal #DE,
irrespective of MXCSR.DAZ. Denormal results are flushed to zeros and do
not signal #UE, irrespective of MXCSR.FTZ.

.PP
The source operand is a ZMM register, a 512-bit memory location or a
512-bit vector broadcasted from a 64-bit memory location. The
destination operand is a ZMM register, conditionally updated using
writemask k1.

.PP
EVEX.vvvv is reserved and must be 1111b otherwise instructions will
#UD.

.SS A NUMERICALLY EXACT IMPLEMENTATION OF VEXP2XX CAN BE FOUND AT HTTPS://SOFTWARE.INTEL.COM/EN-US/ARTICLES/REFER- <a
href="vexp2pd.html#a-numerically-exact-implementation-of-vexp2xx-can-be-found-at-https---software-intel-com-en-us-articles-refer-"
class="anchor">¶

.SS ENCE-IMPLEMENTATIONS-FOR-IA-APPROXIMATION-INSTRUCTIONS-VRCP14-VRSQRT14-VRCP28-VRSQRT28-VEXP2. <a
href="vexp2pd.html#ence-implementations-for-ia-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2-"
class="anchor">¶

.SS OPERATION
.SS VEXP2PD
.EX
(KL, VL) = (8, 512)
FOR j := 0 TO KL-1
    i := j * 64
    IF k1[j] OR *no writemask* THEN
            IF (EVEX.b = 1) AND (SRC *is memory*)
                THEN DEST[i+63:i] := EXP2_23_DP(SRC[63:0])
                ELSE DEST[i+63:i] := EXP2_23_DP(SRC[i+63:i])
            FI;
    ELSE
        IF *merging-masking* ; merging-masking
            THEN *DEST[i+63:i] remains unchanged*
            ELSE ; zeroing-masking
                DEST[i+63:i] := 0
        FI;
    FI;
ENDFOR;
.EE

.SS INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="vexp2pd.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
VEXP2PD __m512d _mm512_exp2a23_round_pd (__m512d a, int sae);

VEXP2PD __m512d _mm512_mask_exp2a23_round_pd (__m512d a, __mmask8 m, __m512d b, int sae);

VEXP2PD __m512d _mm512_maskz_exp2a23_round_pd ( __mmask8 m, __m512d b, int sae);
.EE

.SS SIMD FLOATING-POINT EXCEPTIONS  href="vexp2pd.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
Invalid (if SNaN input), Overflow.

.SS OTHER EXCEPTIONS
See Table 2-46, “Type E2 Class
Exception Conditions.”

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
