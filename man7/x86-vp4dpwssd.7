'\" t
.nh
.TH "X86-VP4DPWSSD" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
VP4DPWSSD - DOT PRODUCT OF SIGNED WORDS WITH DWORD ACCUMULATION (4-ITERATIONS)
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
EVEX.512.F2.0F38.W0 52 /r VP4DPWSSD zmm1{k1}{z}, zmm2+3, m128
T}	A	V/V	AVX512_4VNNIW	T{
Multiply signed words from source register block indicated by zmm2 by signed words from m128 and accumulate resulting signed dwords in zmm1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING  href="vp4dpwssd.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple\fP	\fBOperand 1\fP	\fBOperand 2 Operand 3 Operand 4\fP	\fB\fP	\fB\fP
A	Tuple1_4X	ModRM:reg (r, w)	T{
EVEX.vvvv (r) ModRM:r/m (r) N/A
T}		
.TE

.SS DESCRIPTION
This instruction computes 4 sequential register source-block
dot-products of two signed word operands with doubleword accumulation;
see Figure 8-1
\[la]vp4dpwssd.html#fig\-8\-1\[ra] below. The memory operand is
sequentially selected in each of the four steps.

.PP
In the above box, the notation of “+3”' is used to denote that the
instruction accesses 4 source registers based on that operand; sources
are consecutive, start in a multiple of 4 boundary, and contain the
encoded register operand.

.PP
This instruction supports memory fault suppression. The entire memory
operand is loaded if any bit of the lowest 16-bits of the mask is set to
1 or if a “no masking” encoding is used.

.PP
The tuple type Tuple1_4X implies that four 32-bit elements (16 bytes)
are referenced by the memory operation portion of this instruction.

.PP
.RS

.PP
1\&. For illustration purposes, one source-block dot product instance
is shown out of the four.

.RE

.SS OPERATION
.EX
src_reg_id is the 5 bit index of the vector register specified in the instruction as the src1 register.
VP4DPWSSD dest, src1, src2
(KL,VL) = (16,512)
N := 4
ORIGDEST := DEST
src_base := src_reg_id & ~ (N-1) // for src1 operand
FOR i := 0 to KL-1:
    IF k1[i] or *no writemask*:
        FOR m := 0 to N-1:
            t := SRC2.dword[m]
            p1dword := reg[src_base+m].word[2*i] * t.word[0]
            p2dword := reg[src_base+m].word[2*i+1] * t.word[1]
            DEST.dword[i] := DEST.dword[i] + p1dword + p2dword
    ELSE IF *zeroing*:
        DEST.dword[i] := 0
    ELSE
        DEST.dword[i] := ORIGDEST.dword[i]
DEST[MAX_VL-1:VL] := 0
.EE

.SS INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="vp4dpwssd.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
VP4DPWSSD __m512i _mm512_4dpwssd_epi32(__m512i, __m512ix4, __m128i *);

VP4DPWSSD __m512i _mm512_mask_4dpwssd_epi32(__m512i, __mmask16, __m512ix4, __m128i *);

VP4DPWSSD __m512i _mm512_maskz_4dpwssd_epi32(__mmask16, __m512i, __m512ix4, __m128i *);
.EE

.SS SIMD FLOATING-POINT EXCEPTIONS  href="vp4dpwssd.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
None.

.SS OTHER EXCEPTIONS
See Type E4; additionally:

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
If the EVEX broadcast bit is set to 1.
T}
#UD	If the MODRM.mod = 0b11.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
