'\" t
.nh
.TH "X86-VCVTPS2PHX" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
VCVTPS2PHX - CONVERT PACKED SINGLE PRECISION FLOATING-POINT VALUES TO PACKED FP16 VALUES
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp / En\fP	\fB64/32 Bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
EVEX.128.66.MAP5.W0 1D /r VCVTPS2PHX xmm1{k1}{z}, xmm2/m128/m32bcst
T}	A	V/V	AVX512-FP16 AVX512VL	T{
Convert four packed single precision floating-point values in xmm2/m128/m32bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1.
T}
T{
EVEX.256.66.MAP5.W0 1D /r VCVTPS2PHX xmm1{k1}{z}, ymm2/m256/m32bcst
T}	A	V/V	AVX512-FP16 AVX512VL	T{
Convert eight packed single precision floating-point values in ymm2/m256/m32bcst to packed FP16 values, and store the result in xmm1 subject to writemask k1.
T}
T{
EVEX.512.66.MAP5.W0 1D /r VCVTPS2PHX ymm1{k1}{z}, zmm2/m512/m32bcst {er}
T}	A	V/V	AVX512-FP16	T{
Convert sixteen packed single precision floating-point values in zmm2 /m512/m32bcst to packed FP16 values, and store the result in ymm1 subject to writemask k1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING  href="vcvtps2phx.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple Type\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	Full	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
.TE

.SS DESCRIPTION
This instruction converts packed single precision floating values in the
source operand to FP16 values and stores to the destination operand.

.PP
The VCVTPS2PHX instruction supports broadcasting.

.PP
This instruction uses MXCSR.DAZ for handling FP32 inputs. FP16 outputs
can be normal or denormal numbers, and are not conditionally flushed
based on MXCSR settings.

.SS OPERATION
.SS VCVTPS2PHX DEST, SRC (AVX512_FP16 LOAD VERSION WITH BROADCAST SUPPORT) <a
href="vcvtps2phx.html#vcvtps2phx-dest--src--avx512_fp16-load-version-with-broadcast-support-"
class="anchor">¶

.EX
VL = 128, 256, or 512
KL := VL / 32
IF *SRC is a register* and (VL == 512) and (EVEX.b = 1):
    SET_RM(EVEX.RC)
ELSE:
    SET_RM(MXCSR.RC)
FOR j := 0 TO KL-1:
    IF k1[j] OR *no writemask*:
        IF *SRC is memory* and EVEX.b = 1:
            tsrc := SRC.fp32[0]
        ELSE
            tsrc := SRC.fp32[j]
        DEST.fp16[j] := Convert_fp32_to_fp16(tsrc)
    ELSE IF *zeroing*:
        DEST.fp16[j] := 0
    // else dest.fp16[j] remains unchanged
DEST[MAXVL-1:VL/2] := 0
.EE

.SS FLAGS AFFECTED
None.

.SS INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="vcvtps2phx.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
VCVTPS2PHX __m256h _mm512_cvtx_roundps_ph (__m512 a, int rounding);

VCVTPS2PHX __m256h _mm512_mask_cvtx_roundps_ph (__m256h src, __mmask16 k, __m512 a, int rounding);

VCVTPS2PHX __m256h _mm512_maskz_cvtx_roundps_ph (__mmask16 k, __m512 a, int rounding);

VCVTPS2PHX __m128h _mm_cvtxps_ph (__m128 a);

VCVTPS2PHX __m128h _mm_mask_cvtxps_ph (__m128h src, __mmask8 k, __m128 a);

VCVTPS2PHX __m128h _mm_maskz_cvtxps_ph (__mmask8 k, __m128 a);

VCVTPS2PHX __m128h _mm256_cvtxps_ph (__m256 a);

VCVTPS2PHX __m128h _mm256_mask_cvtxps_ph (__m128h src, __mmask8 k, __m256 a);

VCVTPS2PHX __m128h _mm256_maskz_cvtxps_ph (__mmask8 k, __m256 a);

VCVTPS2PHX __m256h _mm512_cvtxps_ph (__m512 a);

VCVTPS2PHX __m256h _mm512_mask_cvtxps_ph (__m256h src, __mmask16 k, __m512 a);

VCVTPS2PHX __m256h _mm512_maskz_cvtxps_ph (__mmask16 k, __m512 a);
.EE

.SS SIMD FLOATING-POINT EXCEPTIONS  href="vcvtps2phx.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
Invalid, Underflow, Overflow, Precision, Denormal (if MXCSR.DAZ=0).

.SS OTHER EXCEPTIONS
EVEX-encoded instructions, see Table
2-46, “Type E2 Class Exception Conditions.”

.PP
Additionally:

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If VEX.W=1.
#UD	T{
If VEX.vvvv != 1111B or EVEX.vvvv != 1111B.
T}
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
