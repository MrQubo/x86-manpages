'\" t
.nh
.TH "X86-VPBLENDD" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
VPBLENDD - BLEND PACKED DWORDS
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 -bit Mode\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
VEX.128.66.0F3A.W0 02 /r ib VPBLENDD xmm1, xmm2, xmm3/m128, imm8
T}	RVMI	V/V	AVX2	T{
Select dwords from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1.
T}
T{
VEX.256.66.0F3A.W0 02 /r ib VPBLENDD ymm1, ymm2, ymm3/m256, imm8
T}	RVMI	V/V	AVX2	T{
Select dwords from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING  href="vpblendd.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
RVMI	ModRM:reg (w)	VEX.vvvv (r)	ModRM:r/m (r)	imm8
.TE

.SH DESCRIPTION
Dword elements from the source operand (second operand) are
conditionally written to the destination operand (first operand)
depending on bits in the immediate operand (third operand). The
immediate bits (bits 7:0) form a mask that determines whether the
corresponding dword in the destination is copied from the source. If a
bit in the mask, corresponding to a dword, is “1", then the dword is
copied, else the dword is unchanged.

.PP
VEX.128 encoded version: The second source operand can be an XMM
register or a 128-bit memory location. The first source and destination
operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM
register are zeroed.

.PP
VEX.256 encoded version: The first source operand is a YMM register. The
second source operand is a YMM register or a 256-bit memory location.
The destination operand is a YMM register.

.SH OPERATION
.SS VPBLENDD (VEX.256 ENCODED VERSION)  href="vpblendd.html#vpblendd--vex-256-encoded-version-"
class="anchor">¶

.EX
IF (imm8[0] == 1) THEN DEST[31:0] := SRC2[31:0]
ELSE DEST[31:0] := SRC1[31:0]
IF (imm8[1] == 1) THEN DEST[63:32] := SRC2[63:32]
ELSE DEST[63:32] := SRC1[63:32]
IF (imm8[2] == 1) THEN DEST[95:64] := SRC2[95:64]
ELSE DEST[95:64] := SRC1[95:64]
IF (imm8[3] == 1) THEN DEST[127:96] := SRC2[127:96]
ELSE DEST[127:96] := SRC1[127:96]
IF (imm8[4] == 1) THEN DEST[159:128] := SRC2[159:128]
ELSE DEST[159:128] := SRC1[159:128]
IF (imm8[5] == 1) THEN DEST[191:160] := SRC2[191:160]
ELSE DEST[191:160] := SRC1[191:160]
IF (imm8[6] == 1) THEN DEST[223:192] := SRC2[223:192]
ELSE DEST[223:192] := SRC1[223:192]
IF (imm8[7] == 1) THEN DEST[255:224] := SRC2[255:224]
ELSE DEST[255:224] := SRC1[255:224]
.EE

.SS VPBLENDD (VEX.128 ENCODED VERSION)  href="vpblendd.html#vpblendd--vex-128-encoded-version-"
class="anchor">¶

.EX
IF (imm8[0] == 1) THEN DEST[31:0] := SRC2[31:0]
ELSE DEST[31:0] := SRC1[31:0]
IF (imm8[1] == 1) THEN DEST[63:32] := SRC2[63:32]
ELSE DEST[63:32] := SRC1[63:32]
IF (imm8[2] == 1) THEN DEST[95:64] := SRC2[95:64]
ELSE DEST[95:64] := SRC1[95:64]
IF (imm8[3] == 1) THEN DEST[127:96] := SRC2[127:96]
ELSE DEST[127:96] := SRC1[127:96]
DEST[MAXVL-1:128] := 0
.EE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="vpblendd.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
VPBLENDD: __m128i _mm_blend_epi32 (__m128i v1, __m128i v2, const int mask)

VPBLENDD: __m256i _mm256_blend_epi32 (__m256i v1, __m256i v2, const int mask)
.EE

.SH SIMD FLOATING-POINT EXCEPTIONS  href="vpblendd.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
None.

.SH OTHER EXCEPTIONS
See Table 2-21, “Type 4 Class
Exception Conditions.”

.PP
Additionally:

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If VEX.W = 1.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
