'\" t
.nh
.TH "X86-INVVPID" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
INVVPID - INVALIDATE TRANSLATIONS BASED ON VPID
.TS
allbox;
l l l 
l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fBDescription\fP
66 0F 38 81 INVVPID r64, m128	RM	T{
Invalidates entries in the TLBs and paging-structure caches based on VPID (in 64-bit mode).
T}
66 0F 38 81 INVVPID r32, m128	RM	T{
Invalidates entries in the TLBs and paging-structure caches based on VPID (outside 64-bit mode).
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP
Op/En	Operand 1	Operand 2	Operand 3	Operand 4
RM	ModRM:reg (r)	ModRM:r/m (r)	NA	NA
.TE

.SH DESCRIPTION
Invalidates mappings in the translation lookaside buffers (TLBs) and
paging-structure caches based on \fBvirtualprocessor identifier\fP (VPID).
(See Chapter 29, “VMX Support for Address Translation.”) Invalidation is
based on the \fBINVVPID type\fP specified in the register operand and the
\fBINVVPID descriptor\fP specified in the memory operand.

.PP
Outside IA-32e mode, the register operand is always 32 bits, regardless
of the value of CS.D; in 64-bit mode, the register operand has 64 bits
(the instruction cannot be executed in compatibility mode).

.PP
The INVVPID types supported by a logical processors are reported in the
IA32_VMX_EPT_VPID_CAP MSR (see Appendix A, “VMX Capability Reporting
Facility”). There are four INVVPID types currently defined:
.IP \(bu 2
Individual-address invalidation: If the INVVPID type is 0, the
logical processor invalidates mappings for the linear address and
VPID specified in the INVVPID descriptor. In some cases, it may
invalidate mappings for other linear addresses (or other VPIDs) as
well.
.IP \(bu 2
Single-context invalidation: If the INVVPID type is 1, the logical
processor invalidates all mappings tagged with the VPID specified in
the INVVPID descriptor. In some cases, it may invalidate mappings
for other VPIDs as well.
.IP \(bu 2
All-contexts invalidation: If the INVVPID type is 2, the logical
processor invalidates all mappings tagged with all VPIDs except VPID
0000H. In some cases, it may invalidate translations with VPID 0000H
as well.
.IP \(bu 2
Single-context invalidation, retaining global translations: If the
INVVPID type is 3, the logical processor invalidates all mappings
tagged with the VPID specified in the INVVPID descriptor except
global translations. In some cases, it may invalidate global
translations (and mappings with other VPIDs) as well. See the
“Caching Translation Information” section in Chapter 4 of the
Intel® 64 and IA-32 Architectures Software Developer’s
Manual, Volume 3A, for information about global translations.

.PP
If an unsupported INVVPID type is specified, the instruction fails.

.PP
INVVPID invalidates all the specified mappings for the indicated VPID(s)
regardless of the EPTP and PCID values with which those mappings may be
associated.

.PP
The INVVPID descriptor comprises 128 bits and consists of a VPID and a
linear address as shown in Figure 31-2
\[la]invvpid.html#fig\-31\-2\[ra]\&.

.SH OPERATION
.EX
IF (not in VMX operation) or (CR0.PE = 0) or (RFLAGS.VM = 1) or (IA32_EFER.LMA = 1 and CS.L = 0)
    THEN #UD;
ELSIF in VMX non-root operation
    THEN VM exit;
ELSIF CPL > 0
    THEN #GP(0);
    ELSE
        INVVPID_TYPE := value of register operand;
        IF IA32_VMX_EPT_VPID_CAP MSR indicates that processor does not support
        INVVPID_TYPE
            THEN VMfail(Invalid operand to INVEPT/INVVPID);
            ELSE // INVVPID_TYPE must be in the range 0–3
                INVVPID_DESC := value of memory operand;
                IF INVVPID_DESC[63:16] ≠ 0
                    THEN VMfail(Invalid operand to INVEPT/INVVPID);
                    ELSE
                        CASE INVVPID_TYPE OF
                            0:
                                            // individual-address invalidation
                                VPID := INVVPID_DESC[15:0];
                                IF VPID = 0
                                    THEN VMfail(Invalid operand to INVEPT/INVVPID);
                                    ELSE
                                        GL_ADDR := INVVPID_DESC[127:64];
                                        IF (GL_ADDR is not in a canonical form)
                                            THEN
                                                VMfail(Invalid operand to INVEPT/INVVPID);
                                            ELSE
                                                Invalidate mappings for GL_ADDR tagged with VPID;
                                                VMsucceed;
                                        FI;
                                FI;
                                BREAK;
                            1:
                                            // single-context invalidation
                                VPID := INVVPID_DESC[15:0];
                                IF VPID = 0
                                    THEN VMfail(Invalid operand to INVEPT/INVVPID);
                                    ELSE
                                        Invalidate all mappings tagged with VPID;
                                        VMsucceed;
                                FI;
                                BREAK;
                            2:
                                            // all-context invalidation
                                Invalidate all mappings tagged with all non-zero VPIDs;
                                VMsucceed;
                                BREAK;
                            3:
                                            // single-context invalidation retaining globals
                                VPID := INVVPID_DESC[15:0];
                                IF VPID = 0
                                    THEN VMfail(Invalid operand to INVEPT/INVVPID);
                                    ELSE
                                        Invalidate all mappings tagged with VPID except global translations;
                                        VMsucceed;
                                FI;
                                BREAK;
                        ESAC;
                FI;
        FI;
FI;
.EE

.SH FLAGS AFFECTED
See the operation section and Section 31.2.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the current privilege level is not 0.
T}
	T{
If the memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
	T{
If the DS, ES, FS, or GS register contains an unusable segment.
T}
	T{
If the source operand is located in an execute-only code segment.
T}
#PF(fault-code)	T{
If a page fault occurs in accessing the memory operand.
T}
#SS(0)	T{
If the memory operand effective address is outside the SS segment limit.
T}
	T{
If the SS register contains an unusable segment.
T}
#UD	If not in VMX operation.
	T{
If the logical processor does not support VPIDs (IA32_VMX_PROCBASED_CTLS2[37]=0).
T}
	T{
If the logical processor supports VPIDs (IA32_VMX_PROCBASED_CTLS2[37]=1) but does not support the INVVPID instruction (IA32_VMX_EPT_VPID_CAP[32]=0).
T}
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
The INVVPID instruction is not recognized in real-address mode.
T}
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
The INVVPID instruction is not recognized in virtual-8086 mode.
T}
.TE

.SH COMPATIBILITY MODE EXCEPTIONS  href="invvpid.html#compatibility-mode-exceptions"
class="anchor">¶

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
The INVVPID instruction is not recognized in compatibility mode.
T}
.TE

.SH 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the current privilege level is not 0.
T}
	T{
If the memory operand is in the CS, DS, ES, FS, or GS segments and the memory address is in a non-canonical form.
T}
#PF(fault-code)	T{
If a page fault occurs in accessing the memory operand.
T}
#SS(0)	T{
If the memory destination operand is in the SS segment and the memory address is in a non-canonical form.
T}
#UD	If not in VMX operation.
	T{
If the logical processor does not support VPIDs (IA32_VMX_PROCBASED_CTLS2[37]=0).
T}
	T{
If the logical processor supports VPIDs (IA32_VMX_PROCBASED_CTLS2[37]=1) but does not support the INVVPID instruction (IA32_VMX_EPT_VPID_CAP[32]=0).
T}
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
