'\" t
.nh
.TH "X86-ENCLU" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
ENCLU - EXECUTE AN ENCLAVE USER FUNCTION OF SPECIFIED LEAF NUMBER
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
NP 0F 01 D7 ENCLU	ZO	V/V	NA	T{
This instruction is used to execute non-privileged Intel SGX leaf functions.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP
Op/En	Operand 1	Operand 2	Operand 3	Implicit Register Operands
ZO	NA	NA	NA	See Section 38.4
.TE

.SS DESCRIPTION
The ENCLU instruction invokes the specified non-privileged Intel SGX
leaf functions. Software specifies the leaf function by setting the
appropriate value in the register EAX as input. The registers RBX, RCX,
and RDX have leaf-specific purpose, and may act as input, as output, or
may be unused. In 64-bit mode, the instruction ignores upper 32 bits of
the RAX register.

.PP
The ENCLU instruction produces an invalid-opcode exception (#UD) if
CR0.PE = 0 or RFLAGS.VM = 1, or if it is executed in system-management
mode (SMM). Additionally, any attempt to execute this instruction when
CPL &lt; 3 results in #UD. The instruction produces a
general-protection exception (#GP) if either CR0.PG or CR0.NE is 0, or
if an attempt is made to invoke an undefined leaf function. The ENCLU
instruction produces a device not available exception (#NM) if CR0.TS =
1.

.PP
Addresses and operands are 32 bits outside 64-bit mode (IA32_EFER.LMA =
0 or CS.L = 0) and are 64 bits in 64-bit mode (IA32_EFER.LMA = 1 and
CS.L = 1). CS.D value has no impact on address calculation. The DS
segment is used to create linear addresses.

.PP
Segment override prefixes and address-size override prefixes are
ignored, as is the REX prefix in 64-bit mode.

.SS OPERATION
.EX
IN_64BIT_MODE := 0;
IF TSX_ACTIVE
        THEN GOTO TSX_ABORT_PROCESSING; FI;
(* If enclosing app has CET indirect branch tracking enabled then if it is not ERESUME leaf cause a #CP fault *)
(* If the ERESUME is not successful it will leave tracker in WAIT_FOR_ENDBRANCH *)
TRACKER = (CPL == 3) ? IA32_U_CET.TRACKER : IA32_S_CET.TRACKER
IF EndbranchEnabledAndNotSuppressed(CPL) and TRACKER = WAIT_FOR_ENDBRANCH and
    (EAX != ERESUME or CR0.TS or (in SMM) or (CPUID.SGX_LEAF.0:EAX.SE1 = 0) or (CPL < 3))
        THEN
            Handle CET State machine violation (* see Section 17.3.6, “Legacy Compatibility Treatment,” in the
                Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. *)
FI;
IF CR0.PE= 0 or RFLAGS.VM = 1 or in SMM or CPUID.SGX_LEAF.0:EAX.SE1 = 0
        THEN #UD; FI;
IF CR0.TS = 1
        THEN #NM; FI;
IF CPL < 3
        THEN #UD; FI;
IF IA32_FEATURE_CONTROL.LOCK = 0 or IA32_FEATURE_CONTROL.SGX_ENABLE = 0
        THEN #GP(0); FI;
IF EAX is invalid leaf number
        THEN #GP(0); FI;
IF CR0.PG = 0 or CR0.NE = 0
        THEN #GP(0); FI;
IN_64BIT_MODE := IA32_EFER.LMA AND CS.L ? 1 : 0;
(* Check not in 16-bit mode and DS is not a 16-bit segment *)
IF not in 64-bit mode and CS.D = 0
        THEN #GP(0); FI;
IF CR_ENCLAVE_MODE = 1 and (EAX = 2 or EAX = 3) (* EENTER or ERESUME *)
        THEN #GP(0); FI;
IF CR_ENCLAVE_MODE = 0 and (EAX = 0 or EAX = 1 or EAX = 4 or EAX = 5 or EAX = 6 or EAX = 7 or EAX = 9)
(* EREPORT, EGETKEY, EEXIT, EACCEPT, EMODPE, EACCEPTCOPY, or EDECCSSA *)
        THEN #GP(0); FI;
Jump to leaf specific flow
.EE

.SS FLAGS AFFECTED
See individual leaf functions

.SS PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
If any of the LOCK/66H/REP/VEX prefixes are used.
T}
	T{
If current privilege level is not 3.
T}
	T{
If CPUID.(EAX=12H,ECX=0):EAX.SGX1 [bit 0] = 0.
T}
	T{
If logical processor is in SMM.
T}
#GP(0)	If IA32_FEATURE_CONTROL.LOCK = 0.
	If IA32_FEATURE_CONTROL.SGX_ENABLE = 0.
	T{
If input value in EAX encodes an unsupported leaf.
T}
	T{
If input value in EAX encodes EENTER/ERESUME and ENCLAVE_MODE = 1.
T}
	T{
If input value in EAX encodes EGETKEY/EREPORT/EEXIT/EACCEPT/EACCEPTCOPY/EMODPE and ENCLAVE_MODE = 0.
T}
	If operating in 16-bit mode.
	T{
If data segment is in 16-bit mode.
T}
	If CR0.PG = 0 or CR0.NE= 0.
#NM	If CR0.TS = 1.
.TE

.SS REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
ENCLS is not recognized in real mode.
T}
.TE

.SS VIRTUAL-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
ENCLS is not recognized in virtual-8086 mode.
T}
.TE

.SS COMPATIBILITY MODE EXCEPTIONS
Same exceptions as in protected mode.

.SS 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
If any of the LOCK/66H/REP/VEX prefixes are used.
T}
	T{
If current privilege level is not 3.
T}
	T{
If CPUID.(EAX=12H,ECX=0):EAX.SGX1 [bit 0] = 0.
T}
	T{
If logical processor is in SMM.
T}
#GP(0)	If IA32_FEATURE_CONTROL.LOCK = 0.
	If IA32_FEATURE_CONTROL.SGX_ENABLE = 0.
	T{
If input value in EAX encodes an unsupported leaf.
T}
	T{
If input value in EAX encodes EENTER/ERESUME and ENCLAVE_MODE = 1.
T}
	T{
If input value in EAX encodes EGETKEY/EREPORT/EEXIT/EACCEPT/EACCEPTCOPY/EMODPE and ENCLAVE_MODE = 0.
T}
	If CR0.NE= 0.
#NM	If CR0.TS = 1.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
