'\" t
.nh
.TH "X86-XEND" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
XEND - TRANSACTIONAL END
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
NP 0F 01 D5 XEND	A	V/V	RTM	T{
Specifies the end of an RTM code region.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand2\fP	\fBOperand3\fP	\fBOperand4\fP
A	N/A	N/A	N/A	N/A
.TE

.SH DESCRIPTION
The instruction marks the end of an RTM code region. If this corresponds
to the outermost scope (that is, including this XEND instruction, the
number of XBEGIN instructions is the same as number of XEND
instructions), the logical processor will attempt to commit the logical
processor state atomically. If the commit fails, the logical processor
will rollback all architectural register and memory updates performed
during the RTM execution. The logical processor will resume execution at
the fallback address computed from the outermost XBEGIN instruction. The
EAX register is updated to reflect RTM abort information.

.PP
Execution of XEND outside a transactional region causes a
general-protection exception (#GP). Execution of XEND while in a suspend
read address tracking region causes a transactional abort.

.SH OPERATION
.SS XEND
.EX
IF (RTM_ACTIVE = 0) THEN
    SIGNAL #GP
ELSE
    IF SUSLDTRK_ACTIVE = 1
        THEN GOTO RTM_ABORT_PROCESSING;
    FI;
    RTM_NEST_COUNT--
    IF (RTM_NEST_COUNT = 0) THEN
        Try to commit transaction
        IF fail to commit transactional execution
            THEN
                GOTO RTM_ABORT_PROCESSING;
            ELSE (* commit success *)
                RTM_ACTIVE := 0
        FI;
    FI;
FI;
(* For any RTM abort condition encountered during RTM execution *)
RTM_ABORT_PROCESSING:
    Restore architectural register state
    Discard memory updates performed in transaction
    Update EAX with status
    RTM_NEST_COUNT := 0
    RTM_ACTIVE := 0
    SUSLDTRK_ACTIVE := 0
    IF 64-bit Mode
        THEN
            RIP := fallbackRIP
        ELSE
            EIP := fallbackEIP
    FI;
END
.EE

.SH FLAGS AFFECTED
None.

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="xend.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
XEND void _xend( void );
.EE

.SH SIMD FLOATING-POINT EXCEPTIONS
None.

.SH OTHER EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	CPUID.(EAX=7, ECX=0):EBX.RTM[bit 11] = 0.
	If LOCK prefix is used.
#GP(0)	If RTM_ACTIVE = 0.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
