'\" t
.nh
.TH "X86-LZCNT" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
LZCNT - COUNT THE NUMBER OF LEADING ZERO BITS
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32-bit Mode\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
F3 0F BD /r LZCNT r16, r/m16	RM	V/V	LZCNT	T{
Count the number of leading zero bits in r/m16, return result in r16.
T}
F3 0F BD /r LZCNT r32, r/m32	RM	V/V	LZCNT	T{
Count the number of leading zero bits in r/m32, return result in r32.
T}
T{
F3 REX.W 0F BD /r LZCNT r64, r/m64
T}	RM	V/N.E.	LZCNT	T{
Count the number of leading zero bits in r/m64, return result in r64.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
RM	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
.TE

.SH DESCRIPTION
Counts the number of leading most significant zero bits in a source
operand (second operand) returning the result into a destination (first
operand).

.PP
LZCNT differs from BSR. For example, LZCNT will produce the operand size
when the input operand is zero. It should be noted that on processors
that do not support LZCNT, the instruction byte encoding is executed as
BSR.

.PP
In 64-bit mode 64-bit operand size requires REX.W=1.

.SH OPERATION
.EX
temp := OperandSize - 1
DEST := 0
WHILE (temp >= 0) AND (Bit(SRC, temp) = 0)
DO
    temp := temp - 1
    DEST := DEST+ 1
OD
IF DEST = OperandSize
    CF := 1
ELSE
    CF := 0
FI
IF DEST = 0
    ZF := 1
ELSE
    ZF := 0
FI
.EE

.SH FLAGS AFFECTED
ZF flag is set to 1 in case of zero output (most significant bit of the
source is set), and to 0 otherwise, CF flag is set to 1 if input was
zero and cleared otherwise. OF, SF, PF, and AF flags are undefined.

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="lzcnt.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
LZCNT unsigned __int32 _lzcnt_u32(unsigned __int32 src);

LZCNT unsigned __int64 _lzcnt_u64(unsigned __int64 src);
.EE

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.
T}
	T{
If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.
T}
#SS(0)	T{
For an illegal address in the SS segment.
T}
#PF	(fault-code) For a page fault.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
T}
#UD	If LOCK prefix is used.
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If any part of the operand lies outside of the effective address space from 0 to 0FFFFH.
T}
#SS(0)	T{
For an illegal address in the SS segment.
T}
#UD	If LOCK prefix is used.
.TE

.SH VIRTUAL 8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If any part of the operand lies outside of the effective address space from 0 to 0FFFFH.
T}
#SS(0)	T{
For an illegal address in the SS segment.
T}
#PF	(fault-code) For a page fault.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
T}
#UD	If LOCK prefix is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
Same exceptions as in Protected Mode.

.SH 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the memory address is in a non-canonical form.
T}
#SS(0)	T{
If a memory address referencing the SS segment is in a non-canonical form.
T}
#PF	(fault-code) For a page fault.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
T}
#UD	If LOCK prefix is used.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
