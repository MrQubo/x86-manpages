'\" t
.nh
.TH "X86-VTESTPD-VTESTPS" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
VTESTPD-VTESTPS - PACKED BIT TEST
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp /En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
VEX.128.66.0F38.W0 0E /r VTESTPS xmm1, xmm2/m128
T}	RM	V/V	AVX	T{
Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources.
T}
T{
VEX.256.66.0F38.W0 0E /r VTESTPS ymm1, ymm2/m256
T}	RM	V/V	AVX	T{
Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources.
T}
T{
VEX.128.66.0F38.W0 0F /r VTESTPD xmm1, xmm2/m128
T}	RM	V/V	AVX	T{
Set ZF and CF depending on sign bit AND and ANDN of packed double precision floating-point sources.
T}
T{
VEX.256.66.0F38.W0 0F /r VTESTPD ymm1, ymm2/m256
T}	RM	V/V	AVX	T{
Set ZF and CF depending on sign bit AND and ANDN of packed double precision floating-point sources.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING  href="./vtestpd:vtestps.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
RM	ModRM:reg (r)	ModRM:r/m (r)	N/A	N/A
.TE

.SH DESCRIPTION
VTESTPS performs a bitwise comparison of all the sign bits of the packed
single-precision elements in the first source operation and
corresponding sign bits in the second source operand. If the AND of the
source sign bits with the dest sign bits produces all zeros, the ZF is
set else the ZF is clear. If the AND of the source sign bits with the
inverted dest sign bits produces all zeros the CF is set else the CF is
clear. An attempt to execute VTESTPS with VEX.W=1 will cause #UD.

.PP
VTESTPD performs a bitwise comparison of all the sign bits of the double
precision elements in the first source operation and corresponding sign
bits in the second source operand. If the AND of the source sign bits
with the dest sign bits produces all zeros, the ZF is set else the ZF is
clear. If the AND the source sign bits with the inverted dest sign bits
produces all zeros the CF is set else the CF is clear. An attempt to
execute VTESTPS with VEX.W=1 will cause #UD.

.PP
The first source register is specified by the ModR/M \fIreg\fP field.

.PP
128-bit version: The first source register is an XMM register. The
second source register can be an XMM register or a 128-bit memory
location. The destination register is not modified.

.PP
VEX.256 encoded version: The first source register is a YMM register.
The second source register can be a YMM register or a 256-bit memory
location. The destination register is not modified.

.PP
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b,
otherwise instructions will #UD.

.SH OPERATION
.SS VTESTPS (128-BIT VERSION)  href="./vtestpd:vtestps.html#vtestps--128-bit-version-"
class="anchor">¶

.EX
TEMP[127:0] := SRC[127:0] AND DEST[127:0]
IF (TEMP[31] = TEMP[63] = TEMP[95] = TEMP[127] = 0)
    THEN ZF := 1;
    ELSE ZF := 0;
TEMP[127:0] := SRC[127:0] AND NOT DEST[127:0]
IF (TEMP[31] = TEMP[63] = TEMP[95] = TEMP[127] = 0)
    THEN CF := 1;
    ELSE CF := 0;
DEST (unmodified)
AF := OF := PF := SF := 0;
.EE

.SS VTESTPS (VEX.256 ENCODED VERSION)  href="./vtestpd:vtestps.html#vtestps--vex-256-encoded-version-"
class="anchor">¶

.EX
TEMP[255:0] := SRC[255:0] AND DEST[255:0]
IF (TEMP[31] = TEMP[63] = TEMP[95] = TEMP[127]= TEMP[160] =TEMP[191] = TEMP[224] = TEMP[255] = 0)
    THEN ZF := 1;
    ELSE ZF := 0;
TEMP[255:0] := SRC[255:0] AND NOT DEST[255:0]
IF (TEMP[31] = TEMP[63] = TEMP[95] = TEMP[127]= TEMP[160] =TEMP[191] = TEMP[224] = TEMP[255] = 0)
    THEN CF := 1;
    ELSE CF := 0;
DEST (unmodified)
AF := OF := PF := SF := 0;
.EE

.SS VTESTPD (128-BIT VERSION)  href="./vtestpd:vtestps.html#vtestpd--128-bit-version-"
class="anchor">¶

.EX
TEMP[127:0] := SRC[127:0] AND DEST[127:0]
IF ( TEMP[63] = TEMP[127] = 0)
    THEN ZF := 1;
    ELSE ZF := 0;
TEMP[127:0] := SRC[127:0] AND NOT DEST[127:0]
IF ( TEMP[63] = TEMP[127] = 0)
    THEN CF := 1;
    ELSE CF := 0;
DEST (unmodified)
AF := OF := PF := SF := 0;
.EE

.SS VTESTPD (VEX.256 ENCODED VERSION)  href="./vtestpd:vtestps.html#vtestpd--vex-256-encoded-version-"
class="anchor">¶

.EX
TEMP[255:0] := SRC[255:0] AND DEST[255:0]
IF (TEMP[63] = TEMP[127] = TEMP[191] = TEMP[255] = 0)
    THEN ZF := 1;
    ELSE ZF := 0;
TEMP[255:0] := SRC[255:0] AND NOT DEST[255:0]
IF (TEMP[63] = TEMP[127] = TEMP[191] = TEMP[255] = 0)
    THEN CF := 1;
    ELSE CF := 0;
DEST (unmodified)
AF := OF := PF := SF := 0;
.EE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT <a
href="./vtestpd:vtestps.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
VTESTPS int _mm256_testz_ps (__m256 s1, __m256 s2);

int _mm256_testc_ps (__m256 s1, __m256 s2);

int _mm256_testnzc_ps (__m256 s1, __m128 s2);

int _mm_testz_ps (__m128 s1, __m128 s2);

int _mm_testc_ps (__m128 s1, __m128 s2);

int _mm_testnzc_ps (__m128 s1, __m128 s2);

VTESTPD int _mm256_testz_pd (__m256d s1, __m256d s2);

int _mm256_testc_pd (__m256d s1, __m256d s2);

int _mm256_testnzc_pd (__m256d s1, __m256d s2);

int _mm_testz_pd (__m128d s1, __m128d s2);

int _mm_testc_pd (__m128d s1, __m128d s2);

int _mm_testnzc_pd (__m128d s1, __m128d s2);
.EE

.SH FLAGS AFFECTED
The OF, AF, PF, SF flags are cleared and the ZF, CF flags are set
according to the operation.

.SH SIMD FLOATING-POINT EXCEPTIONS  href="./vtestpd:vtestps.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
None.

.SH OTHER EXCEPTIONS
See Table 2-21, “Type 4 Class
Exception Conditions.”

.PP
Additionally:

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If VEX.vvvv ≠ 1111B.
	T{
If VEX.W = 1 for VTESTPS or VTESTPD.
T}
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
