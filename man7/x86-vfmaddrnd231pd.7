'\" t
.nh
.TH "X86-VFMADDRND231PD" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
VFMADDRND231PD - FUSED MULTIPLY-ADD OF PACKED DOUBLE-PRECISION FLOATING-POINT VALUESWITH ROUNDING CONTROL
.TS
allbox;
l 
l .
\fB\fP
T{
Opcode/ Mode CPUID Description Instruction Support Feature Flag VEX.DDS.128.66.0F3A.W1 B8 /r /ib V/V FMA Multiply packed double-precision floating-point values from xmm1 VFMADDRND231PD xmm0, and xmm2/mem, add to xmm0 and xmm1, xmm2/m128, imm8 put result in xmm0. VEX.DDS.256.66.0F3A.W1 B8 /r /ib V/V FMA Multiply packed double-precision floating-point values from ymm1 VFMADDRND231PD ymm0, and ymm2/mem, add to ymm0 and ymm1, ymm2/m256, imm8 put result in ymm0.
T}
.TE

.SH DESCRIPTION
Multiplies the two or four packed double-precision floating-point values
from the second source operand to the two or four packed
double-precision floating-point values in the third source operand, adds
the infinite precision intermediate result to the two or four packed
double-precision floating-point values in the first source operand,
performs rounding and stores the resulting two or four packed
double-precision floating-point values to the destination operand (first
source operand).

.PP
The immediate byte defines several bit fields that control rounding,
DAZ, FTZ, and exception suppression (SeeTable
5-3
\[la]vfmaddrnd231pd.html#tbl\-5\-3\[ra]).The rounding mode specified in
MXCSR.RC may be bypassed if the immediate bit called MS1 (MXCSR.RC
Override) is set. Likewise, the MXCSR.FTZ and MXCSR.DAZ may also be
bypassed if the immediate bit called MS2 (MXCSR.FTZ/DAZ Override) is
set. In case SAE (Suppress All Exceptions) bit is set (i.e. imm8[3] =
1), the status flags in MXCSR are not updated and no SIMD floating-point
exceptions are raised. When SAE bit is not set (i.e. imm8[3] = 0) then
SIMD floating-point exceptions are signaled according to the MXCSR. If
any result operand is an SNaN then it will be converted to a QNaN.

.PP
VEX.256 encoded version: The destination operand (also first source
operand) is a YMM register and encoded in reg_field. The second source
operand is a YMM register and encoded in VEX.vvvv. The third source
operand is a YMM register or a 256-bit memory location and encoded in
rm_field.

.PP
VEX.128 encoded version: The destination operand (also first source
operand) is a XMM register and encoded in reg_field. The second source
operand is a XMM register and encoded in VEX.vvvv. The third source
operand is a XMM register or a 128-bit memory location and encoded in
rm_field. The upper 128 bits of the YMM destination register are
zeroed.

.PP
Compiler tools may optionally support the complementary mnemonic
VMADDRND321PD. The behavior of the complementary mnemonic in situations
involving NANs are governed by the definition of the instruction
mnemonic defined in the opcode/instruction column. See also Section
2.3.1, “FMA Instruction Operand Order and Arithmetic Behavior”

.SH OPERATION
.EX
In the operations below, “+” and “*” symbols represent multiplication and addition with infinite precision inputs and outputs (no rounding)
.EE

.SS VFMADDRND231PD DEST, SRC2, SRC3, IMM8  href="vfmaddrnd231pd.html#vfmaddrnd231pd-dest--src2--src3--imm8"
class="anchor">¶

.EX
IF (VEX.128) THEN
    MAXVL =2
ELSEIF (VEX.256)
    MAXVL = 4
FI
IF (imm8[3] = 1) THEN
    Suppress_SIMD_Exception_Signaling_Reporting();
FI
For i = 0 to MAXVL-1 {
    n = 64*i;
    DEST[n+63:n]←RoundFPControl_Imm((SRC2[n+63:n]*SRC3[n+63:n] + DEST[n+63:n]), imm8)
}
IF (VEX.128) THEN
DEST[255:128] ← 0
FI
IF (imm8[3] = 1) THEN
    Resume_SIMD_Exception_Signaling_Reporting();
FI
.EE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="vfmaddrnd231pd.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
VFMADDRND231PD __m128d _mm_fmaddround_pd (__m128d a, __m128d b, __m128d c, const int ctrl);

VFMADDRND231PD __m256d _mm256_fmaddround_pd (__m256d a, __m256d b, __m256d c, const int ctrl);
.EE

.SH SIMD FLOATING-POINT EXCEPTIONS  href="vfmaddrnd231pd.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
IF imm[3] = 1 Then

.PP
None

.PP
Else

.PP
Overflow, Underflow, Invalid, Precision, Denormal

.PP
FI

.SH OTHER EXCEPTIONS
See Exceptions Type 2

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
