'\" t
.nh
.TH "X86-LEA" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
LEA - LOAD EFFECTIVE ADDRESS
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOpcode\fP	\fBInstruction\fP	\fBOp/En\fP	\fB64-Bit Mode\fP	\fBCompat/Leg Mode\fP	\fBDescription\fP
8D /r	LEA r16,m	RM	Valid	Valid	T{
Store effective address for m in register r16.
T}
8D /r	LEA r32,m	RM	Valid	Valid	T{
Store effective address for m in register r32.
T}
REX.W + 8D /r	LEA r64,m	RM	Valid	N.E.	T{
Store effective address for m in register r64.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
RM	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
.TE

.SH DESCRIPTION
Computes the effective address of the second operand (the source
operand) and stores it in the first operand (destination operand). The
source operand is a memory address (offset part) specified with one of
the processors addressing modes; the destination operand is a
general-purpose register. The address-size and operand-size attributes
affect the action performed by this instruction, as shown in the
following table. The operand-size attribute of the instruction is
determined by the chosen register; the address-size attribute is
determined by the attribute of the code segment.

.PP
Different assemblers may use different algorithms based on the size
attribute and symbolic reference of the source operand.

.PP
In 64-bit mode, the instruction’s destination operand is governed by
operand size attribute, the default operand size is 32 bits. Address
calculation is governed by address size attribute, the default address
size is 64-bits. In 64-bit mode, address size of 16 bits is not
encodable. See Table 3-55
\[la]lea.html#tbl\-3\-55\[ra]\&.

.SH OPERATION
.EX
IF OperandSize = 16 and AddressSize = 16
    THEN
        DEST := EffectiveAddress(SRC); (* 16-bit address *)
    ELSE IF OperandSize = 16 and AddressSize = 32
        THEN
            temp := EffectiveAddress(SRC); (* 32-bit address *)
            DEST := temp[0:15]; (* 16-bit address *)
        FI;
    ELSE IF OperandSize = 32 and AddressSize = 16
        THEN
            temp := EffectiveAddress(SRC); (* 16-bit address *)
            DEST := ZeroExtend(temp); (* 32-bit address *)
        FI;
    ELSE IF OperandSize = 32 and AddressSize = 32
        THEN
            DEST := EffectiveAddress(SRC); (* 32-bit address *)
        FI;
    ELSE IF OperandSize = 16 and AddressSize = 64
        THEN
            temp := EffectiveAddress(SRC); (* 64-bit address *)
            DEST := temp[0:15]; (* 16-bit address *)
        FI;
    ELSE IF OperandSize = 32 and AddressSize = 64
        THEN
            temp := EffectiveAddress(SRC); (* 64-bit address *)
            DEST := temp[0:31]; (* 16-bit address *)
        FI;
    ELSE IF OperandSize = 64 and AddressSize = 64
        THEN
            DEST := EffectiveAddress(SRC); (* 64-bit address *)
        FI;
FI;
.EE

.SH FLAGS AFFECTED
None.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
If source operand is not a memory location.
T}
	If the LOCK prefix is used.
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH VIRTUAL-8086 MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH COMPATIBILITY MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH 64-BIT MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
