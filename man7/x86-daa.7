'\" t
.nh
.TH "X86-DAA" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
DAA - DECIMAL ADJUST AL AFTER ADDITION
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOpcode\fP	\fBInstruction\fP	\fBOp/En\fP	\fB64-Bit Mode\fP	\fBCompat/Leg Mode\fP	\fBDescription\fP
27	DAA	ZO	Invalid	Valid	T{
Decimal adjust AL after addition.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
ZO	N/A	N/A	N/A	N/A
.TE

.SH DESCRIPTION
Adjusts the sum of two packed BCD values to create a packed BCD result.
The AL register is the implied source and destination operand. The DAA
instruction is only useful when it follows an ADD instruction that adds
(binary addition) two 2-digit, packed BCD values and stores a byte
result in the AL register. The DAA instruction then adjusts the contents
of the AL register to contain the correct 2-digit, packed BCD result. If
a decimal carry is detected, the CF and AF flags are set accordingly.

.PP
This instruction executes as described above in compatibility mode and
legacy mode. It is not valid in 64-bit mode.

.SH OPERATION
.EX
IF 64-Bit Mode
    THEN
        #UD;
    ELSE
        old_AL := AL;
        old_CF := CF;
        CF := 0;
        IF (((AL AND 0FH) > 9) or AF = 1)
                THEN
                    AL := AL + 6;
                    CF := old_CF or (Carry from AL := AL + 6);
                    AF := 1;
                ELSE
                    AF := 0;
        FI;
        IF ((old_AL > 99H) or (old_CF = 1))
            THEN
                    AL := AL + 60H;
                    CF := 1;
            ELSE
                    CF := 0;
        FI;
FI;
.EE

.SH EXAMPLE
ADD AL, BL Before: AL=79H BL=35H EFLAGS(OSZAPC)=XXXXXX

.PP
After: AL=AEH BL=35H EFLAGS(0SZAPC)=110000

.PP
DAA Before: AL=AEH BL=35H EFLAGS(OSZAPC)=110000

.PP
After: AL=14H BL=35H EFLAGS(0SZAPC)=X00111

.PP
DAA Before: AL=2EH BL=35H EFLAGS(OSZAPC)=110000

.PP
After: AL=34H BL=35H EFLAGS(0SZAPC)=X00101

.SH FLAGS AFFECTED
The CF and AF flags are set if the adjustment of the value results in a
decimal carry in either digit of the result (see the “Operation” section
above). The SF, ZF, and PF flags are set according to the result. The OF
flag is undefined.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If the LOCK prefix is used.
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If the LOCK prefix is used.
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If the LOCK prefix is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If the LOCK prefix is used.
.TE

.SH 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If in 64-bit mode.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
