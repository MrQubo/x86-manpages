'\" t
.nh
.TH "X86-VFPCLASSPH" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
VFPCLASSPH - TEST TYPES OF PACKED FP16 VALUES
.TS
allbox;
l l l l l 
l l l l l .
\fBInstruction En Bit Mode Flag Support Instruction En Bit Mode Flag Support 64/32 CPUID Feature Instruction En Bit Mode Flag CPUID Feature Instruction En Bit Mode Flag Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag 64/32 CPUID Feature Instruction En Bit Mode Flag CPUID Feature Instruction En Bit Mode Flag Op/ 64/32 CPUID Feature\fP	\fB\fP	\fBSupport\fP	\fB\fP	\fBDescription\fP
T{
EVEX.128.NP.0F3A.W0 66 /r /ib VFPCLASSPH k1{k2}, xmm1/m128/m16bcst, imm8
T}	A	V/V	AVX512-FP16 AVX512VL	T{
Test the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bitforeachofthesecategorytests. Themasked test results are OR-ed together to form a mask result.
T}
T{
EVEX.256.NP.0F3A.W0 66 /r /ib VFPCLASSPH k1{k2}, ymm1/m256/m16bcst, imm8
T}	A	V/V	AVX512-FP16 AVX512VL	T{
Test the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bitforeachofthesecategorytests. Themasked test results are OR-ed together to form a mask result.
T}
T{
EVEX.512.NP.0F3A.W0 66 /r /ib VFPCLASSPH k1{k2}, zmm1/m512/m16bcst, imm8
T}	A	V/V	AVX512-FP16	T{
Test the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bitforeachofthesecategorytests. Themasked test results are OR-ed together to form a mask result.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING  href="vfpclassph.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	Full	ModRM:reg (w)	ModRM:r/m (r)	imm8 (r)	N/A
.TE

.SS DESCRIPTION
This instruction checks the packed FP16 values in the source operand for
special categories, specified by the set bits in the imm8 byte. Each set
bit in imm8 specifies a category of floating-point values that the input
data element is classified against; see Table
5-9
\[la]vfpclassph.html#tbl\-5\-9\[ra] for the categories. The classified results
of all specified categories of an input value are ORed together to form
the final boolean result for the input element. The result is written to
the corresponding bits in the destination mask register according to the
writemask.

.SS OPERATION
.EX
def check_fp_class_fp16(tsrc, imm8):
    negative := tsrc[15]
    exponent_all_ones := (tsrc[14:10] == 0x1F)
    exponent_all_zeros := (tsrc[14:10] == 0)
    mantissa_all_zeros := (tsrc[9:0] == 0)
    zero := exponent_all_zeros and mantissa_all_zeros
    signaling_bit := tsrc[9]
    snan := exponent_all_ones and not(mantissa_all_zeros) and not(signaling_bit)
    qnan := exponent_all_ones and not(mantissa_all_zeros) and signaling_bit
    positive_zero := not(negative) and zero
    negative_zero := negative and zero
    positive_infinity := not(negative) and exponent_all_ones and mantissa_all_zeros
    negative_infinity := negative and exponent_all_ones and mantissa_all_zeros
    denormal := exponent_all_zeros and not(mantissa_all_zeros)
    finite_negative := negative and not(exponent_all_ones) and not(zero)
    return (imm8[0] and qnan) OR
        (imm8[1] and positive_zero) OR
        (imm8[2] and negative_zero) OR
        (imm8[3] and positive_infinity) OR
        (imm8[4] and negative_infinity) OR
        (imm8[5] and denormal) OR
        (imm8[6] and finite_negative) OR
        (imm8[7] and snan)
.EE

.SS VFPCLASSPH DEST{K2}, SRC, IMM8  href="vfpclassph.html#vfpclassph-dest-k2---src--imm8"
class="anchor">¶

.EX
VL = 128, 256 or 512
KL := VL/16
FOR i := 0 to KL-1:
    IF k2[i] or *no writemask*:
        IF SRC is memory and (EVEX.b = 1):
            tsrc := SRC.fp16[0]
        ELSE:
            tsrc := SRC.fp16[i]
        DEST.bit[i] := check_fp_class_fp16(tsrc, imm8)
    ELSE:
        DEST.bit[i] := 0
DEST[MAXKL-1:kl] := 0
.EE

.SS INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="vfpclassph.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
VFPCLASSPH __mmask8 _mm_fpclass_ph_mask (__m128h a, int imm8);

VFPCLASSPH __mmask8 _mm_mask_fpclass_ph_mask (__mmask8 k1, __m128h a, int imm8);

VFPCLASSPH __mmask16 _mm256_fpclass_ph_mask (__m256h a, int imm8);

VFPCLASSPH __mmask16 _mm256_mask_fpclass_ph_mask (__mmask16 k1, __m256h a, int imm8);

VFPCLASSPH __mmask32 _mm512_fpclass_ph_mask (__m512h a, int imm8);

VFPCLASSPH __mmask32 _mm512_mask_fpclass_ph_mask (__mmask32 k1, __m512h a, int imm8);
.EE

.SS SIMD FLOATING-POINT EXCEPTIONS  href="vfpclassph.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
None.

.SS OTHER EXCEPTIONS
EVEX-encoded instructions, see Table
2-49, “Type E4 Class Exception Conditions.”

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
