'\" t
.nh
.TH "X86-AESDEC" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
AESDEC - PERFORM ONE ROUND OF AN AES DECRYPTION FLOW
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32-bit Mode\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
66 0F 38 DE /r AESDEC xmm1, xmm2/m128
T}	A	V/V	AES	T{
Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm1 with one 128-bit round key from xmm2/m128.
T}
T{
VEX.128.66.0F38.WIG DE /r VAESDEC xmm1, xmm2, xmm3/m128
T}	B	V/V	AES AVX	T{
Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1.
T}
T{
VEX.256.66.0F38.WIG DE /r VAESDEC ymm1, ymm2, ymm3/m256
T}	B	V/V	VAES	T{
Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1.
T}
T{
EVEX.128.66.0F38.WIG DE /r VAESDEC xmm1, xmm2, xmm3/m128
T}	C	V/V	VAES AVX512VL	T{
Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1.
T}
T{
EVEX.256.66.0F38.WIG DE /r VAESDEC ymm1, ymm2, ymm3/m256
T}	C	V/V	VAES AVX512VL	T{
Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1.
T}
T{
EVEX.512.66.0F38.WIG DE /r VAESDEC zmm1, zmm2, zmm3/m512
T}	C	V/V	VAES AVX512F	T{
Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using four 128-bit data (state) from zmm2 with four 128-bit round keys from zmm3/m512; store the result in zmm1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	N/A	ModRM:reg (r, w)	ModRM:r/m (r)	N/A	N/A
B	N/A	ModRM:reg (w)	VEX.vvvv (r)	ModRM:r/m (r)	N/A
C	Full Mem	ModRM:reg (w)	EVEX.vvvv (r)	ModRM:r/m (r)	N/A
.TE

.SH DESCRIPTION
This instruction performs a single round of the AES decryption flow
using the Equivalent Inverse Cipher, using one/two/four (depending on
vector length) 128-bit data (state) from the first source operand with
one/two/four (depending on vector length) round key(s) from the second
source operand, and stores the result in the destination operand.

.PP
Use the AESDEC instruction for all but the last decryption round. For
the last decryption round, use the AESDECLAST instruction.

.PP
VEX and EVEX encoded versions of the instruction allow 3-operand
(non-destructive) operation. The legacy encoded versions of the
instruction require that the first source operand and the destination
operand are the same and must be an XMM register.

.PP
The EVEX encoded form of this instruction does not support memory fault
suppression.

.SH OPERATION
.SS AESDEC
.EX
STATE := SRC1;
RoundKey := SRC2;
STATE := InvShiftRows( STATE );
STATE := InvSubBytes( STATE );
STATE := InvMixColumns( STATE );
DEST[127:0] := STATE XOR RoundKey;
DEST[MAXVL-1:128] (Unmodified)
.EE

.SS VAESDEC (128B AND 256B VEX ENCODED VERSIONS)  href="aesdec.html#vaesdec--128b-and-256b-vex-encoded-versions-"
class="anchor">¶

.EX
(KL,VL) = (1,128), (2,256)
FOR i = 0 to KL-1:
    STATE := SRC1.xmm[i]
    RoundKey := SRC2.xmm[i]
    STATE := InvShiftRows( STATE )
    STATE := InvSubBytes( STATE )
    STATE := InvMixColumns( STATE )
    DEST.xmm[i] := STATE XOR RoundKey
DEST[MAXVL-1:VL] := 0
.EE

.SS VAESDEC (EVEX ENCODED VERSION)  href="aesdec.html#vaesdec--evex-encoded-version-"
class="anchor">¶

.EX
(KL,VL) = (1,128), (2,256), (4,512)
FOR i = 0 to KL-1:
    STATE := SRC1.xmm[i]
    RoundKey := SRC2.xmm[i]
    STATE := InvShiftRows( STATE )
    STATE := InvSubBytes( STATE )
    STATE := InvMixColumns( STATE )
    DEST.xmm[i] := STATE XOR RoundKey
DEST[MAXVL-1:VL] :=0
.EE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="aesdec.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
(V)AESDEC __m128i _mm_aesdec (__m128i, __m128i)

VAESDEC __m256i _mm256_aesdec_epi128(__m256i, __m256i);

VAESDEC __m512i _mm512_aesdec_epi128(__m512i, __m512i);
.EE

.SH SIMD FLOATING-POINT EXCEPTIONS  href="aesdec.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
None.

.SH OTHER EXCEPTIONS
See Table 2-21, “Type 4 Class
Exception Conditions.”

.PP
EVEX-encoded: See Table 2-50, “Type
E4NF Class Exception Conditions.”

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
