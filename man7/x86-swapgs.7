'\" t
.nh
.TH "X86-SWAPGS" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
SWAPGS - SWAP GS BASE REGISTER
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOpcode\fP	\fBInstruction\fP	\fBOp/En\fP	\fB64-Bit Mode\fP	\fBCompat/Leg Mode\fP	\fBDescription\fP
0F 01 F8	SWAPGS	ZO	Valid	Invalid	T{
Exchanges the current GS base register value with the value contained in MSR address C0000102H.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
ZO	N/A	N/A	N/A	N/A
.TE

.SH DESCRIPTION
SWAPGS exchanges the current GS base register value with the value
contained in MSR address C0000102H (IA32_KERNEL_GS_BASE). The SWAPGS
instruction is a privileged instruction intended for use by system
software.

.PP
When using SYSCALL to implement system calls, there is no kernel stack
at the OS entry point. Neither is there a straightforward method to
obtain a pointer to kernel structures from which the kernel stack
pointer could be read. Thus, the kernel cannot save general purpose
registers or reference memory.

.PP
By design, SWAPGS does not require any general purpose registers or
memory operands. No registers need to be saved before using the
instruction. SWAPGS exchanges the CPL 0 data pointer from the
IA32_KERNEL_GS_BASE MSR with the GS base register. The kernel can
then use the GS prefix on normal memory references to access kernel data
structures. Similarly, when the OS kernel is entered using an interrupt
or exception (where the kernel stack is already set up), SWAPGS can be
used to quickly get a pointer to the kernel data structures.

.PP
The IA32_KERNEL_GS_BASE MSR itself is only accessible using
RDMSR/WRMSR instructions. Those instructions are only accessible at
privilege level 0. The WRMSR instruction ensures that the
IA32_KERNEL_GS_BASE MSR contains a canonical address.

.SH OPERATION
.EX
IF CS.L ≠ 1 (* Not in 64-Bit Mode *)
    THEN
        #UD; FI;
IF CPL ≠ 0
    THEN #GP(0); FI;
tmp := GS.base;
GS.base := IA32_KERNEL_GS_BASE;
IA32_KERNEL_GS_BASE := tmp;
.EE

.SH FLAGS AFFECTED
None.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If Mode ≠ 64-Bit.
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If Mode ≠ 64-Bit.
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If Mode ≠ 64-Bit.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If Mode ≠ 64-Bit.
.TE

.SH 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	If CPL ≠ 0.
#UD	If the LOCK prefix is used.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
