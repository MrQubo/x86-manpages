'\" t
.nh
.TH "X86-FCMOVCC" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
FCMOVCC - FLOATING-POINT CONDITIONAL MOVE
\fBOpcode1\fP

.TS
allbox;
l l l l l 
l l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP
	\fBInstruction\fP	\fB64-Bit Mode\fP	\fBCompat/ 1\fP \fBLeg Mode\fP	\fBDescription\fP
DA C0+i	FCMOVB ST(0), ST(i)	Valid	Valid	Move if below (CF=1).
DA C8+i	FCMOVE ST(0), ST(i)	Valid	Valid	Move if equal (ZF=1).
DA D0+i	FCMOVBE ST(0), ST(i)	Valid	Valid	T{
Move if below or equal (CF=1 or ZF=1).
T}
DA D8+i	FCMOVU ST(0), ST(i)	Valid	Valid	Move if unordered (PF=1).
DB C0+i	FCMOVNB ST(0), ST(i)	Valid	Valid	Move if not below (CF=0).
DB C8+i	FCMOVNE ST(0), ST(i)	Valid	Valid	Move if not equal (ZF=0).
DB D0+i	FCMOVNBE ST(0), ST(i)	Valid	Valid	T{
Move if not below or equal (CF=0 and ZF=0).
T}
DB D8+i	FCMOVNU ST(0), ST(i)	Valid	Valid	Move if not unordered (PF=0).
.TE

.PP
.RS

.PP
1\&. See IA-32 Architecture Compatibility section below.

.RE

.SH DESCRIPTION
Tests the status flags in the EFLAGS register and moves the source
operand (second operand) to the destination operand (first operand) if
the given test condition is true. The condition for each mnemonic os
given in the Description column above and in Chapter 8 in the
Intel® 64 and IA-32 Architectures Software Developer’s
Manual, Volume 1. The source operand is always in the ST(i) register and
the destination operand is always ST(0).

.PP
The FCMOV\fIcc\fP instructions are useful for optimizing small IF
constructions. They also help eliminate branching overhead for IF
operations and the possibility of branch mispredictions by the
processor.

.PP
A processor may not support the FCMOV\fIcc\fP instructions. Software can
check if the FCMOV\fIcc\fP instructions are supported by checking the
processor’s feature information with the CPUID instruction (see
“COMISS—Compare Scalar Ordered Single Precision Floating-Point Values
and Set EFLAGS” in this chapter). If both the CMOV and FPU feature bits
are set, the FCMOV\fIcc\fP instructions are supported.

.PP
This instruction’s operation is the same in non-64-bit modes and 64-bit
mode.

.SH IA-32 ARCHITECTURE COMPATIBILITY  href="fcmovcc.html#ia-32-architecture-compatibility"
class="anchor">¶

.PP
The FCMOVcc instructions were introduced to the IA-32 Architecture in
the P6 family processors and are not available in earlier IA-32
processors.

.SH OPERATION
.EX
IF condition TRUE
    THEN ST(0) := ST(i);
FI;
.EE

.SH FPU FLAGS AFFECTED
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
C1	T{
Set to 0 if stack underflow occurred.
T}
C0, C2, C3	Undefined.
.TE

.SH FLOATING-POINT EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#IS	Stack underflow occurred.
.TE

.SH INTEGER FLAGS AFFECTED
None.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#NM	CR0.EM[bit 2] or CR0.TS[bit 3] = 1.
#UD	If the LOCK prefix is used.
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH VIRTUAL-8086 MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH COMPATIBILITY MODE EXCEPTIONS  href="fcmovcc.html#compatibility-mode-exceptions"
class="anchor">¶

.PP
Same exceptions as in protected mode.

.SH 64-BIT MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
