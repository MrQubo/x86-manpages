'\" t
.nh
.TH "X86-AESDECWIDE128KL" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
AESDECWIDE128KL - PERFORM TEN ROUNDS OF AES DECRYPTION FLOW WITH KEY LOCKER ON 8 BLOCKSUSING 128-BIT KEY
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32-bit Mode\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
F3 0F 38 D8 !(11):001:bbb AESDECWIDE128KL m384, &lt;XMM0-7&gt;
T}	A	V/V	AESKLEWIDE_KL	T{
Decrypt XMM0-7 using 128-bit AES key indicated by handle at m384 and store each resultant block back to its corresponding register.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING  href="aesdecwide128kl.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l 
l l l l .
\fBOp/En\fP	\fBTuple\fP	\fBOperand 1\fP	\fBOperands 2—9\fP
A	N/A	ModRM:r/m (r)	Implicit XMM0-7 (r, w)
.TE

.SH DESCRIPTION
The AESDECWIDE128KL1 instruction performs ten rounds of AES
to decrypt each of the eight blocks in XMM0-7 using the 128-bit key
indicated by the handle from the second operand. It replaces each input
block in XMM0-7 with its corresponding decrypted block if the operation
succeeds (e.g., does not run into a handle violation failure).

.SH OPERATION
.SS AESDECWIDE128KL
.EX
Handle := UnalignedLoad of 384 bit (SRC); // Load is not guaranteed to be atomic.
Illegal Handle = (HandleReservedBitSet (Handle) ||
                (Handle[0] AND (CPL > 0)) ||
                Handle [2] ||
                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES128);
IF (Illegal Handle)
    THEN RFLAGS.ZF := 1;
    ELSE
        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey);
        IF Authentic == 0 {
            THEN RFLAGS.ZF := 1;
            ELSE
                    XMM0 := AES128Decrypt (XMM0, UnwrappedKey) ;
                    XMM1 := AES128Decrypt (XMM1, UnwrappedKey) ;
                    XMM2 := AES128Decrypt (XMM2, UnwrappedKey) ;
                    XMM3 := AES128Decrypt (XMM3, UnwrappedKey) ;
                    XMM4 := AES128Decrypt (XMM4, UnwrappedKey) ;
                    XMM5 := AES128Decrypt (XMM5, UnwrappedKey) ;
                    XMM6 := AES128Decrypt (XMM6, UnwrappedKey) ;
                    XMM7 := AES128Decrypt (XMM7, UnwrappedKey) ;
                    RFLAGS.ZF := 0;
        FI;
FI;
RFLAGS.OF, SF, AF, PF, CF := 0;
.EE

.SH FLAGS AFFECTED
ZF is set to 0 if the operation succeeded and set to 1 if the operation
failed due to a handle violation. The other arithmetic flags (OF, SF,
AF, PF, CF) are cleared to 0.

.PP
1\&. Further details on Key Locker and usage of this instruction can be
found here:

.SS HTTPS://SOFTWARE.INTEL.COM/CONTENT/WWW/US/EN/DEVELOP/DOWNLOAD/INTEL-KEY-LOCKER-SPECIFICATION.HTML. <a
href="aesdecwide128kl.html#https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-"
class="anchor">¶

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="aesdecwide128kl.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
AESDECWIDE128KLunsigned char _mm_aesdecwide128kl_u8(__m128i odata[8], const __m128i idata[8], const void* h);
.EE

.SH EXCEPTIONS (ALL OPERATING MODES)  href="aesdecwide128kl.html#exceptions--all-operating-modes-"
class="anchor">¶

.PP
#UD If the LOCK prefix is used.

.PP
If CPUID.07H:ECX.KL[bit 23] = 0.

.PP
If CR4.KL = 0.

.PP
If CPUID.19H:EBX.AESKLE[bit 0] = 0.

.PP
If CR0.EM = 1.

.PP
If CR4.OSFXSR = 0.

.PP
If CPUID.19H:EBX.WIDE_KL[bit 2] = 0.

.PP
#NM If CR0.TS = 1.

.PP
#PF If a page fault occurs.

.PP
#GP(0) If a memory operand effective address is outside the CS, DS, ES,
FS, or GS segment limit.

.PP
If the DS, ES, FS, or GS register is used to access memory and it
contains a NULL segment selector.

.PP
If the memory address is in a non-canonical form.

.PP
#SS(0) If a memory operand effective address is outside the SS segment
limit.

.PP
If a memory address referencing the SS segment is in a non-canonical
form.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
