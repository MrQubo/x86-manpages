'\" t
.nh
.TH "X86-LDMXCSR" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
LDMXCSR - LOAD MXCSR REGISTER
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32-bit Mode\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
NP 0F AE /2 LDMXCSR m32	M	V/V	SSE	Load MXCSR register from m32.
T{
VEX.LZ.0F.WIG AE /2 VLDMXCSR m32
T}	M	V/V	AVX	Load MXCSR register from m32.
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
M	ModRM:r/m (r)	N/A	N/A	N/A
.TE

.SH DESCRIPTION
Loads the source operand into the MXCSR control/status register. The
source operand is a 32-bit memory location. See “MXCSR Control and
Status Register” in Chapter 10, of the Intel® 64 and IA-32
Architectures Software Developer’s Manual, Volume 1, for a description
of the MXCSR register and its contents.

.PP
The LDMXCSR instruction is typically used in conjunction with the
(V)STMXCSR instruction, which stores the contents of the MXCSR register
in memory.

.PP
The default MXCSR value at reset is 1F80H.

.PP
If a (V)LDMXCSR instruction clears a SIMD floating-point exception mask
bit and sets the corresponding exception flag bit, a SIMD floating-point
exception will not be immediately generated. The exception will be
generated only upon the execution of the next instruction that meets
both conditions below:
.IP \(bu 2
the instruction must operate on an XMM or YMM register operand,
.IP \(bu 2
the instruction causes that particular SIMD floating-point exception
to be reported.

.PP
This instruction’s operation is the same in non-64-bit modes and 64-bit
mode.

.PP
If VLDMXCSR is encoded with VEX.L= 1, an attempt to execute the
instruction encoded with VEX.L= 1 will cause an #UD exception.

.PP
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b,
otherwise instructions will #UD.

.SH OPERATION
.EX
MXCSR := m32;
.EE

.SH C/C++ COMPILER INTRINSIC EQUIVALENT  href="ldmxcsr.html#c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
_mm_setcsr(unsigned int i)
.EE

.SH NUMERIC EXCEPTIONS
None.

.SH OTHER EXCEPTIONS
See Table 2-22, “Type 5 Class
Exception Conditions,” additionally:

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP	T{
For an attempt to set reserved bits in MXCSR.
T}
#UD	If VEX.vvvv ≠ 1111B.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
