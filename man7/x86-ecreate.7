'\" t
.nh
.TH "X86-ECREATE" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
ECREATE - CREATE AN SECS PAGE IN THE ENCLAVE PAGE CACHE
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
EAX = 00H ENCLS[ECREATE]	IR	V/V	SGX1	T{
This leaf function begins an enclave build by creating an SECS page in EPC.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l 
l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP
Op/En	EAX	RBX	RCX
IR	ECREATE (In)	Address of a PAGEINFO (In)	T{
Address of the destination SECS page (In)
T}
.TE

.SS DESCRIPTION
ENCLS[ECREATE] is the first instruction executed in the enclave build
process. ECREATE copies an SECS structure outside the EPC into an SECS
page inside the EPC. The internal structure of SECS is not accessible to
software.

.PP
ECREATE will set up fields in the protected SECS and mark the page as
valid inside the EPC. ECREATE initializes or checks unused fields.

.PP
Software sets the following fields in the source structure:
SECS:BASEADDR, SECS:SIZE in bytes, ATTRIBUTES, CONFIGID, and CONFIGSVN.
SECS:BASEADDR must be naturally aligned on an SECS.SIZE boundary.
SECS.SIZE must be at least 2 pages (8192).

.PP
The source operand RBX contains an effective address of a PAGEINFO
structure. PAGEINFO contains an effective address of a source SECS and
an effective address of an SECINFO. The SECS field in PAGEINFO is not
used.

.PP
The RCX register is the effective address of the destination SECS. It is
an address of an empty slot in the EPC. The SECS structure must be page
aligned. SECINFO flags must specify the page as an SECS page.

.SH ECREATE MEMORY PARAMETER SEMANTICS  href="ecreate.html#ecreate-memory-parameter-semantics"
class="anchor">¶

.TS
allbox;
l l l l 
l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP
PAGEINFO	PAGEINFO.SRCPGE	PAGEINFO.SECINFO	EPCPAGE
T{
Read access permitted by Non Enclave
T}	T{
Read access permitted by Non Enclave
T}	T{
Read access permitted by Non Enclave
T}	T{
Write access permitted by Enclave
T}
.TE

.PP
ECREATE will fault if the SECS target page is in use; already valid;
outside the EPC. It will also fault if addresses are not aligned; unused
PAGEINFO fields are not zero.

.PP
If the amount of space needed to store the SSA frame is greater than the
amount specified in SECS.SSAFRAMESIZE, a #GP(0) results. The amount of
space needed for an SSA frame is computed based on
DS:TMP_SECS.ATTRIBUTES.XFRM size. Details of computing the size can be
found Section 39.7.

.SS CONCURRENCY RESTRICTIONS
.SS OPERATION
.SH TEMP VARIABLES IN ECREATE OPERATIONAL FLOW  href="ecreate.html#temp-variables-in-ecreate-operational-flow"
class="anchor">¶

.TS
allbox;
l l l l 
l l l l .
\fBName\fP	\fBType\fP	\fBSize (Bits)\fP	\fBDescription\fP
TMP_SRCPGE	Effective Address	32/64	T{
Effective address of the SECS source page.
T}
TMP_SECS	Effective Address	32/64	T{
Effective address of the SECS destination page.
T}
TMP_SECINFO	Effective Address	32/64	T{
Effective address of an SECINFO structure which contains security attributes of the SECS page to be added.
T}
TMP_XSIZE	SSA Size	64	T{
The size calculation of SSA frame.
T}
TMP_MISC_SIZE	MISC Field Size	64	T{
Size of the selected MISC field components.
T}
TMPUPDATEFIELD	SHA256 Buffer	512	T{
Buffer used to hold data being added to TMP_SECS.MRENCLAVE.
T}
.TE

.PP
IF (DS:RBX is not 32Byte Aligned)

.PP
THEN #GP(0); FI;

.PP
IF (DS:RCX is not 4KByte Aligned)

.PP
THEN #GP(0); FI;

.PP
IF (DS:RCX does not resolve within an EPC)

.PP
THEN #PF(DS:RCX); FI;

.PP
TMP_SRCPGE := DS:RBX.SRCPGE;

.PP
TMP_SECINFO := DS:RBX.SECINFO;

.PP
IF (DS:TMP_SRCPGE is not 4KByte aligned or DS:TMP_SECINFO is not
64Byte aligned)

.PP
THEN #GP(0); FI;

.PP
IF (DS:RBX.LINADDR ! = 0 or DS:RBX.SECS ≠ 0)

.PP
THEN #GP(0); FI;

.PP
(* Check for misconfigured SECINFO flags*)

.PP
IF (DS:TMP_SECINFO reserved fields are not zero or
DS:TMP_SECINFO.FLAGS.PT ≠ PT_SECS)

.PP
THEN #GP(0); FI;

.PP
TMP_SECS := RCX;

.PP
IF (EPC entry in use)

.PP
THEN

.PP
IF (&lt;&lt;VMX non-root operation&gt;&gt; AND
&lt;&lt;ENABLE_EPC_VIRTUALIZATION_EXTENSIONS&gt;&gt;)

.PP
THEN

.PP
VMCS.Exit_reason := SGX_CONFLICT;

.PP
VMCS.Exit_qualification.code := EPC_PAGE_CONFLICT_EXCEPTION;

.PP
VMCS.Exit_qualification.error := 0;

.PP
VMCS.Guest-physical_address :=

.PP
&lt;&lt; translation of DS:TMP_SECS produced by paging &gt;&gt;;

.PP
VMCS.Guest-linear_address := DS:TMP_SECS;

.PP
Deliver VMEXIT;

.PP
ELSE

.PP
#GP(0);

.PP
FI;

.PP
FI;

.PP
IF (EPC entry in use)

.PP
THEN #GP(0); FI;

.PP
IF (EPCM(DS:RCX).VALID = 1)

.PP
THEN #PF(DS:RCX); FI;

.PP
(* Copy 4KBytes from source page to EPC page*)

.PP
DS:RCX[32767:0] := DS:TMP_SRCPGE[32767:0];

.PP
(* Check lower 2 bits of XFRM are set *)

.PP
IF ( ( DS:TMP_SECS.ATTRIBUTES.XFRM BitwiseAND 03H) ≠ 03H)

.PP
THEN #GP(0); FI;

.PP
IF (XFRM is illegal)

.PP
THEN #GP(0); FI;

.PP
(* Check legality of CET_ATTRIBUTES *)

.PP
IF ((DS:TMP_SECS.ATTRIBUTES.CET = 0 and DS:TMP_SECS.CET_ATTRIBUTES ≠
0) ||

.PP
(DS:TMP_SECS.ATTRIBUTES.CET = 0 and
DS:TMP_SECS.CET_LEG_BITMAP_OFFSET ≠ 0) ||

.PP
(CPUID.(EAX=7, ECX=0):EDX[CET_IBT] = 0 and
DS:TMP_SECS.CET_LEG_BITMAP_OFFSET ≠ 0) ||

.PP
(CPUID.(EAX=7, ECX=0):EDX[CET_IBT] = 0 and
DS:TMP_SECS.CET_ATTRIBUTES[5:2] ≠ 0) ||

.PP
(CPUID.(EAX=7, ECX=0):ECX[CET_SS] = 0 and
DS:TMP_SECS.CET_ATTRIBUTES[1:0] ≠ 0) ||

.PP
(DS:TMP_SECS.ATTRIBUTES.MODE64BIT = 1 and

.PP
(DS:TMP_SECS.BASEADDR + DS:TMP_SECS.CET_LEG_BITMAP_OFFSET) not
canonical) ||

.PP
(DS:TMP_SECS.ATTRIBUTES.MODE64BIT = 0 and

.PP
(DS:TMP_SECS.BASEADDR + DS:TMP_SECS.CET_LEG_BITMAP_OFFSET) &
0xFFFFFFFF00000000) ||

.PP
(DS:TMP_SECS.CET_ATTRIBUTES.reserved fields not 0) or

.PP
(DS:TMP_SECS.CET_LEG_BITMAP_OFFSET) is not page aligned))

.PP
THEN

.PP
#GP(0);

.PP
FI;

.PP
(* Make sure that the SECS does not have any unsupported MISCSELECT
options*)

.PP
IF ( !(CPUID.(EAX=12H, ECX=0):EBX[31:0] &
DS:TMP_SECS.MISCSELECT[31:0]) )

.PP
THEN

.PP
EPCM(DS:TMP_SECS).EntryLock.Release();

.PP
#GP(0);

.PP
FI;

.PP
( * Compute size of MISC area *)

.PP
TMP_MISC_SIZE := compute_misc_region_size();

.PP
(* Compute the size required to save state of the enclave on async
exit, see Section 39.7.2.2*)

.PP
TMP_XSIZE := compute_xsave_size(DS:TMP_SECS.ATTRIBUTES.XFRM) +
GPR_SIZE + TMP_MISC_SIZE;

.PP
(* Ensure that the declared area is large enough to hold XSAVE and GPR
stat *)

.PP
IF ( DS:TMP_SECS.SSAFRAMESIZE*4096 &lt; TMP_XSIZE)

.PP
THEN #GP(0); FI;

.PP
IF ( (DS:TMP_SECS.ATTRIBUTES.MODE64BIT = 1) and (DS:TMP_SECS.BASEADDR
is not canonical) )

.PP
THEN #GP(0); FI;

.PP
IF ( (DS:TMP_SECS.ATTRIBUTES.MODE64BIT = 0) and (DS:TMP_SECS.BASEADDR
and 0FFFFFFFF00000000H) )

.PP
THEN #GP(0); FI;

.PP
IF ( (DS:TMP_SECS.ATTRIBUTES.MODE64BIT = 0) and (DS:TMP_SECS.SIZE ≥ 2
^ (CPUID.(EAX=12H, ECX=0):.EDX[7:0]) ) ) THEN #GP(0); FI;

.PP
IF ( (DS:TMP_SECS.ATTRIBUTES.MODE64BIT = 1) and (DS:TMP_SECS.SIZE ≥ 2
^ (CPUID.(EAX=12H, ECX=0):.EDX[15:8]) ) ) THEN #GP(0); FI;

.PP
(* Enclave size must be at least 8192 bytes and must be power of 2 in
bytes*)

.PP
IF (DS:TMP_SECS.SIZE &lt; 8192 or popcnt(DS:TMP_SECS.SIZE) &gt; 1)

.PP
THEN #GP(0); FI;

.PP
(* Ensure base address of an enclave is aligned on size*)

.PP
IF ( ( DS:TMP_SECS.BASEADDR and (DS:TMP_SECS.SIZE-1) ) )

.PP
THEN #GP(0); FI;

.PP
(* Ensure the SECS does not have any unsupported attributes*)

.PP
IF ( DS:TMP_SECS.ATTRIBUTES and (~CR_SGX_ATTRIBUTES_MASK) )

.PP
THEN #GP(0); FI;

.PP
IF ( DS:TMP_SECS reserved fields are not zero)

.PP
THEN #GP(0); FI;

.PP
(* Verify that CONFIGID/CONFIGSVN are not set with attribute *)

.PP
IF ( ((DS:TMP_SECS.CONFIGID ≠ 0) or (DS:TMP_SECS.CONFIGSVN ≠0)) AND
(DS:TMP_SECS.ATTRIBUTES.KSS == 0 ))

.PP
THEN #GP(0); FI;

.PP
Clear DS:TMP_SECS to Uninitialized;

.PP
DS:TMP_SECS.MRENCLAVE := SHA256INITIALIZE(DS:TMP_SECS.MRENCLAVE);

.PP
DS:TMP_SECS.ISVSVN := 0;

.PP
DS:TMP_SECS.ISVPRODID := 0;

.PP
(* Initialize hash updates etc*)

.PP
Initialize enclave’s MRENCLAVE update counter;

.PP
(* Add “ECREATE” string and SECS fields to MRENCLAVE *)

.PP
TMPUPDATEFIELD[63:0] := 0045544145524345H; // “ECREATE”

.PP
TMPUPDATEFIELD[95:64] := DS:TMP_SECS.SSAFRAMESIZE;

.PP
TMPUPDATEFIELD[159:96] := DS:TMP_SECS.SIZE;

.PP
IF (CPUID.(EAX=7, ECX=0):EDX[CET_IBT] = 1)

.PP
THEN

.PP
TMPUPDATEFIELD[223:160] := DS:TMP_SECS.CET_LEG_BITMAP_OFFSET;

.PP
ELSE

.PP
TMPUPDATEFIELD[223:160] := 0;

.PP
FI;

.PP
TMPUPDATEFIELD[511:160] := 0;

.PP
DS:TMP_SECS.MRENCLAVE := SHA256UPDATE(DS:TMP_SECS.MRENCLAVE,
TMPUPDATEFIELD)

.PP
INC enclave’s MRENCLAVE update counter;

.PP
(* Set EID *)

.PP
DS:TMP_SECS.EID := LockedXAdd(CR_NEXT_EID, 1);

.PP
(* Initialize the virtual child count to zero *)

.PP
DS:TMP_SECS.VIRTCHILDCNT := 0;

.PP
(* Load ENCLAVECONTEXT with Address out of paging of SECS *)

.PP
&lt;&lt; store translation of DS:RCX produced by paging in
SECS(DS:RCX).ENCLAVECONTEXT &gt;&gt;

.PP
(* Set the EPCM entry, first create SECS identifier and store the
identifier in EPCM *)

.PP
EPCM(DS:TMP_SECS).PT := PT_SECS;

.PP
EPCM(DS:TMP_SECS).ENCLAVEADDRESS := 0;

.PP
EPCM(DS:TMP_SECS).R := 0;

.PP
EPCM(DS:TMP_SECS).W := 0;

.PP
EPCM(DS:TMP_SECS).X := 0;

.PP
(* Set EPCM entry fields *)

.PP
EPCM(DS:RCX).BLOCKED := 0;

.PP
EPCM(DS:RCX).PENDING := 0;

.PP
EPCM(DS:RCX).MODIFIED := 0;

.PP
EPCM(DS:RCX).PR := 0;

.PP
EPCM(DS:RCX).VALID := 1;

.SS FLAGS AFFECTED
None

.SS PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If a memory operand effective address is outside the DS segment limit.
T}
	T{
If a memory operand is not properly aligned.
T}
	T{
If the reserved fields are not zero.
T}
	If PAGEINFO.SECS is not zero.
	T{
If PAGEINFO.LINADDR is not zero.
T}
	T{
If the SECS destination is locked.
T}
	T{
If SECS.SSAFRAMESIZE is insufficient.
T}
#PF(error	T{
code) If a page fault occurs in accessing memory operands.
T}
	T{
If the SECS destination is outside the EPC.
T}
.TE

.SS 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If a memory address is non-canonical form.
T}
	T{
If a memory operand is not properly aligned.
T}
	T{
If the reserved fields are not zero.
T}
	If PAGEINFO.SECS is not zero.
	T{
If PAGEINFO.LINADDR is not zero.
T}
	T{
If the SECS destination is locked.
T}
	T{
If SECS.SSAFRAMESIZE is insufficient.
T}
#PF(error	T{
code) If a page fault occurs in accessing memory operands.
T}
	T{
If the SECS destination is outside the EPC.
T}
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
