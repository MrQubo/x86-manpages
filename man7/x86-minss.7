'\" t
.nh
.TH "X86-MINSS" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
MINSS - RETURN MINIMUM SCALAR SINGLE PRECISION FLOATING-POINT VALUE
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp / En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
F3 0F 5D /r MINSS xmm1,xmm2/m32
T}	A	V/V	SSE	T{
Return the minimum scalar single precision floating-point value between xmm2/m32 and xmm1.
T}
T{
VEX.LIG.F3.0F.WIG 5D /r VMINSS xmm1,xmm2, xmm3/m32
T}	B	V/V	AVX	T{
Return the minimum scalar single precision floating-point value between xmm3/m32 and xmm2.
T}
T{
EVEX.LLIG.F3.0F.W0 5D /r VMINSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}
T}	C	V/V	AVX512F	T{
Return the minimum scalar single precision floating-point value between xmm3/m32 and xmm2.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple Type\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	N/A	ModRM:reg (r, w)	ModRM:r/m (r)	N/A	N/A
B	N/A	ModRM:reg (w)	VEX.vvvv (r)	ModRM:r/m (r)	N/A
C	Tuple1 Scalar	ModRM:reg (w)	EVEX.vvvv (r)	ModRM:r/m (r)	N/A
.TE

.SH DESCRIPTION
Compares the low single precision floating-point values in the first
source operand and the second source operand and returns the minimum
value to the low doubleword of the destination operand.

.PP
If the values being compared are both 0.0s (of either sign), the value
in the second source operand is returned. If a value in the second
operand is an SNaN, that SNaN is returned unchanged to the destination
(that is, a QNaN version of the SNaN is not returned).

.PP
If only one value is a NaN (SNaN or QNaN) for this instruction, the
second source operand, either a NaN or a valid floating-point value, is
written to the result. If instead of this behavior, it is required that
the NaN in either source operand be returned, the action of MINSD can be
emulated using a sequence of instructions, such as, a comparison
followed by AND, ANDN, and OR.

.PP
The second source operand can be an XMM register or a 32-bit memory
location. The first source and destination operands are XMM registers.

.PP
128-bit Legacy SSE version: The destination and first source operand are
the same. Bits (MAXVL:32) of the corresponding destination register
remain unchanged.

.PP
VEX.128 and EVEX encoded version: The first source operand is an xmm
register encoded by (E)VEX.vvvv. Bits (127:32) of the XMM register
destination are copied from corresponding bits in the first source
operand. Bits (MAXVL-1:128) of the destination register are zeroed.

.PP
EVEX encoded version: The low doubleword element of the destination
operand is updated according to the writemask.

.PP
Software should ensure VMINSS is encoded with VEX.L=0. Encoding VMINSS
with VEX.L=1 may encounter unpredictable behavior across different
processor generations.

.SH OPERATION
.EX
MIN(SRC1, SRC2)
{
    IF ((SRC1 = 0.0) and (SRC2 = 0.0)) THEN DEST := SRC2;
        ELSE IF (SRC1 = NaN) THEN DEST := SRC2; FI;
        ELSE IF (SRC2 = NaN) THEN DEST := SRC2; FI;
        ELSE IF (SRC1 < SRC2) THEN DEST := SRC1;
        ELSE DEST := SRC2;
    FI;
}
.EE

.SS MINSS (EVEX ENCODED VERSION)
.EX
IF k1[0] or *no writemask*
    THEN DEST[31:0] := MIN(SRC1[31:0], SRC2[31:0])
    ELSE
        IF *merging-masking* ; merging-masking
            THEN *DEST[31:0] remains unchanged*
            ELSE ; zeroing-masking
                THEN DEST[31:0] := 0
        FI;
FI;
DEST[127:32] := SRC1[127:32]
DEST[MAXVL-1:128] := 0
.EE

.SS VMINSS (VEX.128 ENCODED VERSION)  href="minss.html#vminss--vex-128-encoded-version-"
class="anchor">¶

.EX
DEST[31:0] := MIN(SRC1[31:0], SRC2[31:0])
DEST[127:32] := SRC1[127:32]
DEST[MAXVL-1:128] := 0
.EE

.SS MINSS (128-BIT LEGACY SSE VERSION)  href="minss.html#minss--128-bit-legacy-sse-version-"
class="anchor">¶

.EX
DEST[31:0] := MIN(SRC1[31:0], SRC2[31:0])
DEST[MAXVL-1:128] (Unmodified)
.EE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="minss.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
VMINSS __m128 _mm_min_round_ss( __m128 a, __m128 b, int);

VMINSS __m128 _mm_mask_min_round_ss(__m128 s, __mmask8 k, __m128 a, __m128 b, int);

VMINSS __m128 _mm_maskz_min_round_ss( __mmask8 k, __m128 a, __m128 b, int);

MINSS __m128 _mm_min_ss(__m128 a, __m128 b)
.EE

.SH SIMD FLOATING-POINT EXCEPTIONS
Invalid (Including QNaN Source Operand), Denormal.

.SH OTHER EXCEPTIONS
Non-EVEX-encoded instruction, see Table
2-19, “Type 2 Class Exception Conditions.”

.PP
EVEX-encoded instruction, see Table
2-46, “Type E2 Class Exception Conditions.”

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
