'\" t
.nh
.TH "X86-CPUID" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
CPUID - CPU IDENTIFICATION
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOpcode\fP	\fBInstruction\fP	\fBOp/En\fP	\fB64-Bit Mode\fP	\fBCompat/Leg Mode\fP	\fBDescription\fP
0F A2	CPUID	ZO	Valid	Valid	T{
Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well).
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
ZO	N/A	N/A	N/A	N/A
.TE

.SH DESCRIPTION
The ID flag (bit 21) in the EFLAGS register indicates support for the
CPUID instruction. If a software procedure can set and clear this flag,
the processor executing the procedure supports the CPUID instruction.
This instruction operates the same in non-64-bit modes and 64-bit mode.

.PP
CPUID returns processor identification and feature information in the
EAX, EBX, ECX, and EDX registers.1 The instruction’s output
is dependent on the contents of the EAX register upon execution (in some
cases, ECX as well). For example, the following pseudocode loads EAX
with 00H and causes CPUID to return a Maximum Return Value and the
Vendor Identification String in the appropriate registers:

.PP
MOV EAX, 00H

.PP
CPUID

.PP
Table 3-8
\[la]cmpss.html#tbl\-3\-8\[ra] shows information returned, depending on
the initial value loaded into the EAX register.

.PP
Two types of information are returned: basic and extended function
information. If a value entered for CPUID.EAX is higher than the maximum
input value for basic or extended function for that processor then the
data for the highest basic information leaf is returned. For example,
using some Intel processors, the following is true:

.PP
CPUID.EAX = 05H (* Returns MONITOR/MWAIT leaf. *)

.PP
CPUID.EAX = 0AH (* Returns Architectural Performance Monitoring leaf.
*) CPUID.EAX = 0BH (* Returns Extended Topology Enumeration leaf.
*)2 CPUID.EAX =1FH (* Returns V2 Extended Topology
Enumeration leaf. *)2

.PP
CPUID.EAX = 80000008H (* Returns linear/physical address size data. *)

.PP
CPUID.EAX = 8000000AH (* INVALID: Returns same information as CPUID.EAX
= 0BH. *)

.PP
If a value entered for CPUID.EAX is less than or equal to the maximum
input value and the leaf is not supported on that processor then 0 is
returned in all the registers.

.PP
When CPUID returns the highest basic leaf information as a result of an
invalid input EAX value, any dependence on input ECX value in the basic
leaf is honored.

.PP
CPUID can be executed at any privilege level to serialize instruction
execution. Serializing instruction execution guarantees that any
modifications to flags, registers, and memory for previous instructions
are completed before the next instruction is fetched and executed.

.PP
\fBSee also:\fP

.PP
“Serializing Instructions” in Chapter 9, “Multiple-Processor
Management,” in the Intel® 64 and IA-32 Architectures
Software Developer’s Manual, Volume 3A.

.PP
“Caching Translation Information” in Chapter 4, “Paging,” in the
Intel® 64 and IA-32 Architectures Software Developer’s
Manual, Volume 3A.

.PP
.RS

.PP
1\&. On Intel 64 processors, CPUID clears the high 32 bits of the
RAX/RBX/RCX/RDX registers in all modes.

.PP
2\&. CPUID leaf 1FH is a preferred superset to leaf 0BH. Intel
recommends first checking for the existence of CPUID leaf 1FH before
using leaf 0BH.

.RE

.SH INPUT EAX = 0: RETURNS CPUID’S HIGHEST VALUE FOR BASIC PROCESSOR INFORMATION AND THE VENDOR IDENTIFICATION STRING <a
href="cpuid.html#input-eax-=-0--returns-cpuid’s-highest-value-for-basic-processor-information-and-the-vendor-identification-string"
class="anchor">¶

.PP
When CPUID executes with EAX set to 0, the processor returns the highest
value the CPUID recognizes for returning basic processor information.
The value is returned in the EAX register and is processor specific.

.PP
A vendor identification string is also returned in EBX, EDX, and ECX.
For Intel processors, the string is “GenuineIntel” and is expressed:

.PP
EBX := 756e6547h (* “Genu”, with G in the low eight bits of BL *)

.PP
EDX := 49656e69h (* “ineI”, with i in the low eight bits of DL *)

.PP
ECX := 6c65746eh (* “ntel”, with n in the low eight bits of CL *)

.SH INPUT EAX = 80000000H: RETURNS CPUID’S HIGHEST VALUE FOR EXTENDED PROCESSOR INFORMATION <a
href="cpuid.html#input-eax-=-80000000h--returns-cpuid’s-highest-value-for-extended-processor-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 80000000H, the processor returns the
highest value the processor recognizes for returning extended processor
information. The value is returned in the EAX register and is processor
specific.

.SH IA32_BIOS_SIGN_ID RETURNS MICROCODE UPDATE SIGNATURE <a
href="cpuid.html#ia32_bios_sign_id-returns-microcode-update-signature"
class="anchor">¶

.PP
For processors that support the microcode update facility, the
IA32_BIOS_SIGN_ID MSR is loaded with the update signature whenever
CPUID executes. The signature is returned in the upper DWORD. For
details, see Chapter 10 in the Intel® 64 and IA-32
Architectures Software Developer’s Manual, Volume 3A.

.SH INPUT EAX = 01H: RETURNS MODEL, FAMILY, STEPPING INFORMATION <a
href="cpuid.html#input-eax-=-01h--returns-model--family--stepping-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 01H, version information is returned
in EAX (see Figure 3-6
\[la]cpuid.html#fig\-3\-6\[ra]). For example: model,
family, and processor type for the Intel Xeon processor 5100 series is
as follows:
.IP \(bu 2
Model — 1111B
.IP \(bu 2
Family — 0101B
.IP \(bu 2
Processor Type — 00B

.PP
See Table 3-9
\[la]cmpss.html#tbl\-3\-9\[ra] for available processor type values.
Stepping IDs are provided as needed.

.PP
.RS

.PP
See Chapter 20 in the Intel® 64 and IA-32 Architectures
Software Developer’s Manual, Volume 1, for information on identifying
earlier IA-32 processors.

.RE

.PP
The Extended Family ID needs to be examined only when the Family ID is
0FH. Integrate the fields into a display using the following rule:

.PP
IF Family_ID ≠ 0FH

.PP
THEN DisplayFamily = Family_ID;

.PP
ELSE DisplayFamily = Extended_Family_ID + Family_ID;

.PP
FI;

.PP
(* Show DisplayFamily as HEX field. *)

.PP
The Extended Model ID needs to be examined only when the Family ID is
06H or 0FH. Integrate the field into a display using the following rule:

.PP
IF (Family_ID = 06H or Family_ID = 0FH)

.PP
THEN DisplayModel = (Extended_Model_ID « 4) + Model_ID;

.PP
(* Right justify and zero-extend 4-bit field; display Model_ID as HEX
field.*)

.PP
ELSE DisplayModel = Model_ID;

.PP
FI;

.PP
(* Show DisplayModel as HEX field. *)

.SH INPUT EAX = 01H: RETURNS ADDITIONAL INFORMATION IN EBX <a
href="cpuid.html#input-eax-=-01h--returns-additional-information-in-ebx"
class="anchor">¶

.PP
When CPUID executes with EAX set to 01H, additional information is
returned to the EBX register:
.IP \(bu 2
Brand index (low byte of EBX) — this number provides an entry into a
brand string table that contains brand strings for IA-32 processors.
More information about this field is provided later in this section.
.IP \(bu 2
CLFLUSH instruction cache line size (second byte of EBX) — this
number indicates the size of the cache line flushed by the CLFLUSH
and CLFLUSHOPT instructions in 8-byte increments. This field was
introduced in the Pentium 4 processor.
.IP \(bu 2
Local APIC ID (high byte of EBX) — this number is the 8-bit ID that
is assigned to the local APIC on the processor during power up. This
field was introduced in the Pentium 4 processor.

.SH INPUT EAX = 01H: RETURNS FEATURE INFORMATION IN ECX AND EDX <a
href="cpuid.html#input-eax-=-01h--returns-feature-information-in-ecx-and-edx"
class="anchor">¶

.PP
When CPUID executes with EAX set to 01H, feature information is returned
in ECX and EDX.
.IP \(bu 2
Figure 3-7
\[la]cpuid.html#fig\-3\-7\[ra] and Table
3-10
\[la]cpuid.html#tbl\-3\-10\[ra] show encodings for ECX.
.IP \(bu 2
Figure 3-8
\[la]cpuid.html#fig\-3\-8\[ra] and Table
3-11
\[la]cpuid.html#tbl\-3\-11\[ra] show encodings for EDX.

.PP
For all feature flags, a 1 indicates that the feature is supported. Use
Intel to properly interpret feature flags.

.PP
.RS

.PP
Software must confirm that a processor feature is present using
feature flags returned by CPUID prior to using the feature. Software
should not depend on future offerings retaining all features.

.RE

.SH INPUT EAX = 02H: TLB/CACHE/PREFETCH INFORMATION RETURNED IN EAX, EBX, ECX, EDX <a
href="cpuid.html#input-eax-=-02h--tlb-cache-prefetch-information-returned-in-eax--ebx--ecx--edx"
class="anchor">¶

.PP
When CPUID executes with EAX set to 02H, the processor returns
information about the processor’s internal TLBs, cache, and prefetch
hardware in the EAX, EBX, ECX, and EDX registers. The information is
reported in encoded form and fall into the following categories:
.IP \(bu 2
The least-significant byte in register EAX (register AL) will always
return 01H. Software should ignore this value and not interpret it
as an informational descriptor.
.IP \(bu 2
The most significant bit (bit 31) of each register indicates whether
the register contains valid information (set to 0) or is reserved
(set to 1).
.IP \(bu 2
If a register contains valid information, the information is
contained in 1 byte descriptors. There are four types of encoding
values for the byte descriptor, the encoding type is noted in the
second column of Table 3-12
\[la]cpuid.html#tbl\-3\-12\[ra]\&. Table 3-12 lists
the encoding of these descriptors. Note that the order of
descriptors in the EAX, EBX, ECX, and EDX registers is not defined;
that is, specific bytes are not designated to contain descriptors
for specific cache, prefetch, or TLB types. The descriptors may
appear in any order. Note also a processor may report a general
descriptor type (FFH) and not report any byte descriptor of “cache
type” via CPUID leaf 2.

.SH EXAMPLE 3-1. EXAMPLE OF CACHE AND TLB INTERPRETATION <a
href="cpuid.html#example-3-1--example-of-cache-and-tlb-interpretation"
class="anchor">¶

.PP
The first member of the family of Pentium 4 processors returns the
following information about caches and TLBs when the CPUID executes with
an input value of 2:

.PP
EAX 66 5B 50 01H EBX 0H ECX 0H EDX 00 7A 70 00H

.PP
Which means:
.IP \(bu 2
The least-significant byte (byte 0) of register EAX is set to 01H.
This value should be ignored.
.IP \(bu 2
The most-significant bit of all four registers (EAX, EBX, ECX, and
EDX) is set to 0, indicating that each register contains valid
1-byte descriptors.
.IP \(bu 2
Bytes 1, 2, and 3 of register EAX indicate that the processor has:
.RS
.IP \(bu 2
50H - a 64-entry instruction TLB, for mapping 4-KByte and
2-MByte or 4-MByte pages.
.IP \(bu 2
50H - a 64-entry instruction TLB, for mapping 4-KByte and
2-MByte or 4-MByte pages.
.IP \(bu 2
5BH - a 64-entry data TLB, for mapping 4-KByte and 4-MByte
pages.
.IP \(bu 2
5BH - a 64-entry data TLB, for mapping 4-KByte and 4-MByte
pages.
.IP \(bu 2
66H - an 8-KByte 1st level data cache, 4-way set associative,
with a 64-Byte cache line size.
.IP \(bu 2
66H - an 8-KByte 1st level data cache, 4-way set associative,
with a 64-Byte cache line size.
.RE
.IP \(bu 2
The descriptors in registers EBX and ECX are valid, but contain NULL
descriptors.
.IP \(bu 2
Bytes 0, 1, 2, and 3 of register EDX indicate that the processor
has:
.RS
.IP \(bu 2
00H - NULL descriptor.
.IP \(bu 2
00H - NULL descriptor.
.IP \(bu 2
70H - Trace cache: 12 K-μop, 8-way set associative.
.IP \(bu 2
70H - Trace cache: 12 K-μop, 8-way set associative.
.IP \(bu 2
7AH - a 256-KByte 2nd level cache, 8-way set associative, with a
sectored, 64-byte cache line size.
.IP \(bu 2
7AH - a 256-KByte 2nd level cache, 8-way set associative, with a
sectored, 64-byte cache line size.
.IP \(bu 2
00H - NULL descriptor.
.IP \(bu 2
00H - NULL descriptor.
.RE

.SH INPUT EAX = 04H: RETURNS DETERMINISTIC CACHE PARAMETERS FOR EACH LEVEL <a
href="cpuid.html#input-eax-=-04h--returns-deterministic-cache-parameters-for-each-level"
class="anchor">¶

.PP
When CPUID executes with EAX set to 04H and ECX contains an index value,
the processor returns encoded data that describe a set of deterministic
cache parameters (for the cache level associated with the input in ECX).
Valid index values start from 0.

.PP
Software can enumerate the deterministic cache parameters for each level
of the cache hierarchy starting with an index value of 0, until the
parameters report the value associated with the cache type field is 0.
The architecturally defined fields reported by deterministic cache
parameters are documented in Table 3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.PP
This Cache Size in Bytes

.PP
= (Ways + 1) * (Partitions + 1) * (Line_Size + 1) * (Sets + 1)

.PP
= (EBX[31:22] + 1) * (EBX[21:12] + 1) * (EBX[11:0] + 1) *
(ECX + 1)

.PP
The CPUID leaf 04H also reports data that can be used to derive the
topology of processor cores in a physical package. This information is
constant for all valid index values. Software can query the raw data
reported by executing CPUID with EAX=04H and ECX=0 and use it as part of
the topology enumeration algorithm described in Chapter 9,
“Multiple-Processor Management,” in the Intel® 64 and IA-32
Architectures Software Developer’s Manual, Volume 3A.

.SH INPUT EAX = 05H: RETURNS MONITOR AND MWAIT FEATURES  href="cpuid.html#input-eax-=-05h--returns-monitor-and-mwait-features"
class="anchor">¶

.PP
When CPUID executes with EAX set to 05H, the processor returns
information about features available to MONITOR/MWAIT instructions. The
MONITOR instruction is used for address-range monitoring in conjunction
with MWAIT instruction. The MWAIT instruction optionally provides
additional extensions for advanced power management. See Table
3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 06H: RETURNS THERMAL AND POWER MANAGEMENT FEATURES <a
href="cpuid.html#input-eax-=-06h--returns-thermal-and-power-management-features"
class="anchor">¶

.PP
When CPUID executes with EAX set to 06H, the processor returns
information about thermal and power management features. See Table
3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 07H: RETURNS STRUCTURED EXTENDED FEATURE ENUMERATION INFORMATION <a
href="cpuid.html#input-eax-=-07h--returns-structured-extended-feature-enumeration-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 07H and ECX = 0, the processor
returns information about the maximum input value for sub-leaves that
contain extended feature flags. See Table 3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.PP
When CPUID executes with EAX set to 07H and the input value of ECX is
invalid (see leaf 07H entry in Table 3-8
\[la]cmpss.html#tbl\-3\-8\[ra]), the
processor returns 0 in EAX/EBX/ECX/EDX. In subleaf 0, EAX returns the
maximum input value of the highest leaf 7 sub-leaf, and EBX, ECX & EDX
contain information of extended feature flags.

.SH INPUT EAX = 09H: RETURNS DIRECT CACHE ACCESS INFORMATION <a
href="cpuid.html#input-eax-=-09h--returns-direct-cache-access-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 09H, the processor returns
information about Direct Cache Access capabilities. See Table
3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 0AH: RETURNS ARCHITECTURAL PERFORMANCE MONITORING FEATURES <a
href="cpuid.html#input-eax-=-0ah--returns-architectural-performance-monitoring-features"
class="anchor">¶

.PP
When CPUID executes with EAX set to 0AH, the processor returns
information about support for architectural performance monitoring
capabilities. Architectural performance monitoring is supported if the
version ID (see Table 3-8) is greater than Pn 0. See Table
3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.PP
For each version of architectural performance monitoring capability,
software must enumerate this leaf to discover the programming facilities
and the architectural performance events available in the processor. The
details are described in Chapter 24, “Introduction to Virtual Machine
Extensions,” in the Intel® 64 and IA-32 Architectures
Software Developer’s Manual, Volume 3C.

.SH INPUT EAX = 0BH: RETURNS EXTENDED TOPOLOGY INFORMATION <a
href="cpuid.html#input-eax-=-0bh--returns-extended-topology-information"
class="anchor">¶

.PP
\fICPUID leaf 1FH is a preferred superset to leaf 0BH. Intel recommends
first checking for the existence of Leaf 1FH before using leaf 0BH.\fP

.PP
When CPUID executes with EAX set to 0BH, the processor returns
information about extended topology enumeration data. Software must
detect the presence of CPUID leaf 0BH by verifying (a) the highest leaf
index supported by CPUID is &gt;= 0BH, and (b) CPUID.0BH:EBX[15:0]
reports a non-zero value. See Table 3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 0DH: RETURNS PROCESSOR EXTENDED STATES ENUMERATION INFORMATION <a
href="cpuid.html#input-eax-=-0dh--returns-processor-extended-states-enumeration-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 0DH and ECX = 0, the processor
returns information about the bit-vector representation of all processor
state extensions that are supported in the processor and storage size
requirements of the XSAVE/XRSTOR area. See Table
3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.PP
When CPUID executes with EAX set to 0DH and ECX = n (n &gt; 1, and is a
valid sub-leaf index), the processor returns information about the size
and offset of each processor extended state save area within the
XSAVE/XRSTOR area. See Table 3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&. Software can use
the forward-extendable technique depicted below to query the valid
sub-leaves and obtain size and offset information for each processor
extended state save area:

.PP
For i = 2 to 62 // sub-leaf 1 is reserved IF (CPUID.(EAX=0DH,
ECX=0H):VECTOR[i] = 1 ) // VECTOR is the 64-bit value of EDX:EAX
Execute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf
i; FI;

.SH INPUT EAX = 0FH: RETURNS INTEL RESOURCE DIRECTOR TECHNOLOGY (INTEL RDT) MONITORING ENUMERATION INFORMATION <a
href="cpuid.html#input-eax-=-0fh--returns-intel-resource-director-technology--intel-rdt--monitoring-enumeration-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 0FH and ECX = 0, the processor
returns information about the bit-vector representation of QoS
monitoring resource types that are supported in the processor and
maximum range of RMID values the processor can use to monitor of any
supported resource types. Each bit, starting from bit 1, corresponds to
a specific resource type if the bit is set. The bit position corresponds
to the sub-leaf index (or ResID) that software must use to query QoS
monitoring capability available for that type. See Table
3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.PP
When CPUID executes with EAX set to 0FH and ECX = n (n &gt;= 1, and is a
valid ResID), the processor returns information software can use to
program IA32_PQR_ASSOC, IA32_QM_EVTSEL MSRs before reading QoS data
from the IA32_QM_CTR MSR.

.SH INPUT EAX = 10H: RETURNS INTEL RESOURCE DIRECTOR TECHNOLOGY (INTEL RDT) ALLOCATION ENUMERATION INFORMATION <a
href="cpuid.html#input-eax-=-10h--returns-intel-resource-director-technology--intel-rdt--allocation-enumeration-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 10H and ECX = 0, the processor
returns information about the bit-vector representation of QoS
Enforcement resource types that are supported in the processor. Each
bit, starting from bit 1, corresponds to a specific resource type if the
bit is set. The bit position corresponds to the sub-leaf index (or
ResID) that software must use to query QoS enforcement capability
available for that type. See Table 3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.PP
When CPUID executes with EAX set to 10H and ECX = n (n &gt;= 1, and is a
valid ResID), the processor returns information about available classes
of service and range of QoS mask MSRs that software can use to configure
each class of services using capability bit masks in the QoS Mask
registers, IA32_resourceType_Mask_n.

.SH INPUT EAX = 12H: RETURNS INTEL SGX ENUMERATION INFORMATION <a
href="cpuid.html#input-eax-=-12h--returns-intel-sgx-enumeration-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 12H and ECX = 0H, the processor
returns information about Intel SGX capabilities. See Table
3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.PP
When CPUID executes with EAX set to 12H and ECX = 1H, the processor
returns information about Intel SGX attributes. See Table
3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.PP
When CPUID executes with EAX set to 12H and ECX = n (n &gt; 1), the
processor returns information about Intel SGX Enclave Page Cache. See
Table 3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 14H: RETURNS INTEL PROCESSOR TRACE ENUMERATION INFORMATION <a
href="cpuid.html#input-eax-=-14h--returns-intel-processor-trace-enumeration-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 14H and ECX = 0H, the processor
returns information about Intel Processor Trace extensions. See Table
3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.PP
When CPUID executes with EAX set to 14H and ECX = n (n &gt; 0 and less
than the number of non-zero bits in CPUID.(EAX=14H, ECX= 0H).EAX), the
processor returns information about packet generation in Intel Processor
Trace. See Table 3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 15H: RETURNS TIME STAMP COUNTER AND NOMINAL CORE CRYSTAL CLOCK INFORMATION <a
href="cpuid.html#input-eax-=-15h--returns-time-stamp-counter-and-nominal-core-crystal-clock-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 15H and ECX = 0H, the processor
returns information about Time Stamp Counter and Core Crystal Clock. See
Table 3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 16H: RETURNS PROCESSOR FREQUENCY INFORMATION <a
href="cpuid.html#input-eax-=-16h--returns-processor-frequency-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 16H, the processor returns
information about Processor Frequency Information. See Table
3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 17H: RETURNS SYSTEM-ON-CHIP INFORMATION  href="cpuid.html#input-eax-=-17h--returns-system-on-chip-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 17H, the processor returns
information about the System-On-Chip Vendor Attribute Enumeration. See
Table 3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 18H: RETURNS DETERMINISTIC ADDRESS TRANSLATION PARAMETERS INFORMATION <a
href="cpuid.html#input-eax-=-18h--returns-deterministic-address-translation-parameters-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 18H, the processor returns
information about the Deterministic Address Translation Parameters. See
Table 3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 19H: RETURNS KEY LOCKER INFORMATION  href="cpuid.html#input-eax-=-19h--returns-key-locker-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 19H, the processor returns
information about Key Locker. See Table 3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 1AH: RETURNS NATIVE MODEL ID INFORMATION <a
href="cpuid.html#input-eax-=-1ah--returns-native-model-id-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 1AH, the processor returns
information about Native Model Identification. See Table
3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 1BH: RETURNS PCONFIG INFORMATION  href="cpuid.html#input-eax-=-1bh--returns-pconfig-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 1BH, the processor returns
information about PCONFIG capabilities. This information is enumerated
in sub-leaves selected by the value of ECX (starting with 0).

.PP
Each sub-leaf of CPUID function 1BH enumerates its \fBsub-leaf type\fP in
EAX. If a sub-leaf type is 0, the sub-leaf is invalid and zero is
returned in EBX, ECX, and EDX. In this case, all subsequent sub-leaves
(selected by larger input values of ECX) are also invalid.

.PP
The only valid sub-leaf type currently defined is 1, indicating that the
sub-leaf enumerates target identifiers for the PCONFIG instruction. Any
non-zero value returned in EBX, ECX, or EDX indicates a valid target
identifier of the PCONFIG instruction (any value of zero should be
ignored). The only target identifier currently defined is 1, indicating
TME-MK. See the “PCONFIG—Platform Configuration” instruction in Chapter
4 of the Intel® 64 and IA-32 Architectures Software
Developer’s Manual, Volume 2B, for more information.

.SH INPUT EAX = 1CH: RETURNS LAST BRANCH RECORD INFORMATION <a
href="cpuid.html#input-eax-=-1ch--returns-last-branch-record-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 1CH, the processor returns
information about LBRs (the architectural feature). See Table
3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 1DH: RETURNS TILE INFORMATION  href="cpuid.html#input-eax-=-1dh--returns-tile-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 1DH and ECX = 0H, the processor
returns information about tile architecture. See Table
3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.PP
When CPUID executes with EAX set to 1DH and ECX = 1H, the processor
returns information about tile palette 1. See Table
3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 1EH: RETURNS TMUL INFORMATION  href="cpuid.html#input-eax-=-1eh--returns-tmul-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 1EH and ECX = 0H, the processor
returns information about TMUL capabilities. See Table
3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 1FH: RETURNS V2 EXTENDED TOPOLOGY INFORMATION <a
href="cpuid.html#input-eax-=-1fh--returns-v2-extended-topology-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 1FH, the processor returns
information about extended topology enumeration data. Software must
detect the presence of CPUID leaf 1FH by verifying (a) the highest leaf
index supported by CPUID is &gt;= 1FH, and (b) CPUID.1FH:EBX[15:0]
reports a non-zero value. See Table 3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH INPUT EAX = 20H: RETURNS HISTORY RESET INFORMATION  href="cpuid.html#input-eax-=-20h--returns-history-reset-information"
class="anchor">¶

.PP
When CPUID executes with EAX set to 20H, the processor returns
information about History Reset. See Table 3-8
\[la]cmpss.html#tbl\-3\-8\[ra]\&.

.SH METHODS FOR RETURNING BRANDING INFORMATION  href="cpuid.html#methods-for-returning-branding-information"
class="anchor">¶

.PP
Use the following techniques to access branding information:

.PP
1\&. Processor brand string method.

.PP
2\&. Processor brand index; this method uses a software supplied brand
string table.

.PP
These two methods are discussed in the following sections. For methods
that are available in early processors, see Section: “Identification of
Earlier IA-32 Processors” in Chapter 20 of the Intel® 64 and
IA-32 Architectures Software Developer’s Manual, Volume 1.

.SH THE PROCESSOR BRAND STRING METHOD  href="cpuid.html#the-processor-brand-string-method"
class="anchor">¶

.PP
Figure 3-9
\[la]cpuid.html#fig\-3\-9\[ra] describes the algorithm used for
detection of the brand string. Processor brand identification software
should execute this algorithm on all Intel 64 and IA-32 processors.

.PP
This method (introduced with Pentium 4 processors) returns an ASCII
brand identification string and the Processor Base frequency of the
processor to the EAX, EBX, ECX, and EDX registers.

.SH HOW BRAND STRINGS WORK
To use the brand string method, execute CPUID with EAX input of 8000002H
through 80000004H. For each input value, CPUID returns 16 ASCII
characters using EAX, EBX, ECX, and EDX. The returned string will be
NULL-terminated.

.PP
Table 3-13
\[la]cpuid.html#tbl\-3\-13\[ra] shows the brand string that is
returned by the first processor in the Pentium 4 processor family.

.SH EXTRACTING THE PROCESSOR FREQUENCY FROM BRAND STRINGS <a
href="cpuid.html#extracting-the-processor-frequency-from-brand-strings"
class="anchor">¶

.PP
Figure 3-10
\[la]cpuid.html#fig\-3\-10\[ra] provides an algorithm which software
can use to extract the Processor Base frequency from the processor brand
string.

.SH THE PROCESSOR BRAND INDEX METHOD  href="cpuid.html#the-processor-brand-index-method"
class="anchor">¶

.PP
The brand index method (introduced with Pentium® III
Xeon® processors) provides an entry point into a brand
identification table that is maintained in memory by system software and
is accessible from system- and user-level code. In this table, each
brand index is associate with an ASCII brand identification string that
identifies the official Intel family and model number of a processor.

.PP
When CPUID executes with EAX set to 1, the processor returns a brand
index to the low byte in EBX. Software can then use this index to locate
the brand identification string for the processor in the brand
identification table. The first entry (brand index 0) in this table is
reserved, allowing for backward compatibility with processors that do
not support the brand identification feature. Starting with processor
signature family ID = 0FH, model = 03H, brand index method is no longer
supported. Use brand string method instead.

.PP
Table 3-14
\[la]cpuid.html#tbl\-3\-14\[ra] shows brand indices that have
identification strings associated with them.

.PP
NOTES:

.PP
1\&. Indicates versions of these processors that were introduced after
the Pentium III

.SH IA-32 ARCHITECTURE COMPATIBILITY  href="cpuid.html#ia-32-architecture-compatibility"
class="anchor">¶

.PP
CPUID is not supported in early models of the Intel486 processor or in
any IA-32 processor earlier than the Intel486 processor.

.SH OPERATION
.EX
IA32_BIOS_SIGN_ID MSR := Update with installed microcode revision number;
CASE (EAX) OF
    EAX = 0:
        EAX := Highest basic function input value understood by CPUID;
        EBX := Vendor identification string;
        EDX := Vendor identification string;
        ECX := Vendor identification string;
    BREAK;
    EAX = 1H:
        EAX[3:0] := Stepping ID;
        EAX[7:4] := Model;
        EAX[11:8] := Family;
        EAX[13:12] := Processor type;
        EAX[15:14] := Reserved;
        EAX[19:16] := Extended Model;
        EAX[27:20] := Extended Family;
        EAX[31:28] := Reserved;
        EBX[7:0] := Brand Index; (* Reserved if the value is zero. *)
        EBX[15:8] := CLFLUSH Line Size;
        EBX[16:23] := Reserved; (* Number of threads enabled = 2 if MT enable fuse set. *)
        EBX[24:31] := Initial APIC ID;
        ECX := Feature flags; (* See Figure 3-7. *)
        EDX := Feature flags; (* See Figure 3-8. *)
    BREAK;
    EAX = 2H:
        EAX := Cache and TLB information;
        EBX := Cache and TLB information;
        ECX := Cache and TLB information;
        EDX := Cache and TLB information;
    BREAK;
    EAX = 3H:
        EAX := Reserved;
        EBX := Reserved;
        ECX := ProcessorSerialNumber[31:0];
        (* Pentium III processors only, otherwise reserved. *)
        EDX := ProcessorSerialNumber[63:32];
        (* Pentium III processors only, otherwise reserved. *
    BREAK
    EAX = 4H:
        EAX := Deterministic Cache Parameters Leaf; (* See Table 3-8. *)
        EBX := Deterministic Cache Parameters Leaf;
        ECX := Deterministic Cache Parameters Leaf;
        EDX := Deterministic Cache Parameters Leaf;
    BREAK;
    EAX = 5H:
        EAX := MONITOR/MWAIT Leaf; (* See Table 3-8. *)
        EBX := MONITOR/MWAIT Leaf;
        ECX := MONITOR/MWAIT Leaf;
        EDX := MONITOR/MWAIT Leaf;
    BREAK;
    EAX = 6H:
        EAX := Thermal and Power Management Leaf; (* See Table 3-8. *)
        EBX := Thermal and Power Management Leaf;
        ECX := Thermal and Power Management Leaf;
        EDX := Thermal and Power Management Leaf;
    BREAK;
    EAX = 7H:
        EAX := Structured Extended Feature Flags Enumeration Leaf; (* See Table 3-8. *)
        EBX := Structured Extended Feature Flags Enumeration Leaf;
        ECX := Structured Extended Feature Flags Enumeration Leaf;
        EDX := Structured Extended Feature Flags Enumeration Leaf;
    BREAK;
    EAX = 8H:
        EAX := Reserved = 0;
        EBX := Reserved = 0;
        ECX := Reserved = 0;
        EDX := Reserved = 0;
    BREAK;
    EAX = 9H:
        EAX := Direct Cache Access Information Leaf; (* See Table 3-8. *)
        EBX := Direct Cache Access Information Leaf;
        ECX := Direct Cache Access Information Leaf;
        EDX := Direct Cache Access Information Leaf;
    BREAK;
    EAX = AH:
        EAX := Architectural Performance Monitoring Leaf; (* See Table 3-8. *)
        EBX := Architectural Performance Monitoring Leaf;
        ECX := Architectural Performance Monitoring Leaf;
        EDX := Architectural Performance Monitoring Leaf;
        BREAK
    EAX = BH:
        EAX := Extended Topology Enumeration Leaf; (* See Table 3-8. *)
        EBX := Extended Topology Enumeration Leaf;
        ECX := Extended Topology Enumeration Leaf;
        EDX := Extended Topology Enumeration Leaf;
    BREAK;
    EAX = CH:
        EAX := Reserved = 0;
        EBX := Reserved = 0;
        ECX := Reserved = 0;
        EDX := Reserved = 0;
    BREAK;
    EAX = DH:
        EAX := Processor Extended State Enumeration Leaf; (* See Table 3-8. *)
        EBX := Processor Extended State Enumeration Leaf;
        ECX := Processor Extended State Enumeration Leaf;
        EDX := Processor Extended State Enumeration Leaf;
    BREAK;
    EAX = EH:
        EAX := Reserved = 0;
        EBX := Reserved = 0;
        ECX := Reserved = 0;
        EDX := Reserved = 0;
    BREAK;
    EAX = FH:
        EAX := Intel Resource Director Technology Monitoring Enumeration Leaf; (* See Table 3-8. *)
        EBX := Intel Resource Director Technology Monitoring Enumeration Leaf;
        ECX := Intel Resource Director Technology Monitoring Enumeration Leaf;
        EDX := Intel Resource Director Technology Monitoring Enumeration Leaf;
    BREAK;
    EAX = 10H:
        EAX := Intel Resource Director Technology Allocation Enumeration Leaf; (* See Table 3-8. *)
        EBX := Intel Resource Director Technology Allocation Enumeration Leaf;
        ECX := Intel Resource Director Technology Allocation Enumeration Leaf;
        EDX := Intel Resource Director Technology Allocation Enumeration Leaf;
    BREAK;
    EAX = 12H:
        EAX := Intel SGX Enumeration Leaf; (* See Table 3-8. *)
        EBX := Intel SGX Enumeration Leaf;
        ECX := Intel SGX Enumeration Leaf;
        EDX := Intel SGX Enumeration Leaf;
    BREAK;
    EAX = 14H:
        EAX := Intel Processor Trace Enumeration Leaf; (* See Table 3-8. *)
        EBX := Intel Processor Trace Enumeration Leaf;
        ECX := Intel Processor Trace Enumeration Leaf;
        EDX := Intel Processor Trace Enumeration Leaf;
    BREAK;
    EAX = 15H:
        EAX := Time Stamp Counter and Nominal Core Crystal Clock Information Leaf; (* See Table 3-8. *)
        EBX := Time Stamp Counter and Nominal Core Crystal Clock Information Leaf;
        ECX := Time Stamp Counter and Nominal Core Crystal Clock Information Leaf;
        EDX := Time Stamp Counter and Nominal Core Crystal Clock Information Leaf;
    BREAK;
    EAX = 16H:
        EAX := Processor Frequency Information Enumeration Leaf; (* See Table 3-8. *)
        EBX := Processor Frequency Information Enumeration Leaf;
        ECX := Processor Frequency Information Enumeration Leaf;
        EDX := Processor Frequency Information Enumeration Leaf;
    BREAK;
    EAX = 17H:
        EAX := System-On-Chip Vendor Attribute Enumeration Leaf; (* See Table 3-8. *)
        EBX := System-On-Chip Vendor Attribute Enumeration Leaf;
        ECX := System-On-Chip Vendor Attribute Enumeration Leaf;
        EDX := System-On-Chip Vendor Attribute Enumeration Leaf;
    BREAK;
    EAX = 18H:
        EAX := Deterministic Address Translation Parameters Enumeration Leaf; (* See Table 3-8. *)
        EBX := Deterministic Address Translation Parameters Enumeration Leaf;
        ECX := Deterministic Address Translation Parameters Enumeration Leaf;
        EDX := Deterministic Address Translation Parameters Enumeration Leaf;
    BREAK;
    EAX = 19H:
        EAX := Key Locker Enumeration Leaf; (* See Table 3-8. *)
        EBX := Key Locker Enumeration Leaf;
        ECX := Key Locker Enumeration Leaf;
        EDX := Key Locker Enumeration Leaf;
    BREAK;
    EAX = 1AH:
        EAX := Native Model ID Enumeration Leaf; (* See Table 3-8. *)
        EBX := Native Model ID Enumeration Leaf;
        ECX := Native Model ID Enumeration Leaf;
        EDX := Native Model ID Enumeration Leaf;
    BREAK;
    EAX = 1BH:
        EAX := PCONFIG Information Enumeration Leaf; (* See “INPUT EAX = 1BH: Returns PCONFIG Information” on page 3-253. *)
        EBX := PCONFIG Information Enumeration Leaf;
        ECX := PCONFIG Information Enumeration Leaf;
        EDX := PCONFIG Information Enumeration Leaf;
    BREAK;
    EAX = 1CH:
        EAX := Last Branch Record Information Enumeration Leaf; (* See Table 3-8. *)
        EBX := Last Branch Record Information Enumeration Leaf;
        ECX := Last Branch Record Information Enumeration Leaf;
        EDX := Last Branch Record Information Enumeration Leaf;
    BREAK;
    EAX = 1DH:
        EAX := Tile Information Enumeration Leaf; (* See Table 3-8. *)
        EBX := Tile Information Enumeration Leaf;
        ECX := Tile Information Enumeration Leaf;
        EDX := Tile Information Enumeration Leaf;
    BREAK;
    EAX = 1EH:
        EAX := TMUL Information Enumeration Leaf; (* See Table 3-8. *)
        EBX := TMUL Information Enumeration Leaf;
        ECX := TMUL Information Enumeration Leaf;
        EDX := TMUL Information Enumeration Leaf;
    BREAK;
    EAX = 1FH:
        EAX := V2 Extended Topology Enumeration Leaf; (* See Table 3-8. *)
        EBX := V2 Extended Topology Enumeration Leaf;
        ECX := V2 Extended Topology Enumeration Leaf;
        EDX := V2 Extended Topology Enumeration Leaf;
    BREAK;
    EAX = 20H:
        EAX := Processor History Reset Sub-leaf; (* See Table 3-8. *)
        EBX := Processor History Reset Sub-leaf;
        ECX := Processor History Reset Sub-leaf;
        EDX := Processor History Reset Sub-leaf;
    BREAK;
    EAX = 80000000H:
        EAX := Highest extended function input value understood by CPUID;
        EBX := Reserved;
        ECX := Reserved;
        EDX := Reserved;
    BREAK;
    EAX = 80000001H:
        EAX := Reserved;
        EBX := Reserved;
        ECX := Extended Feature Bits (* See Table 3-8.*);
        EDX := Extended Feature Bits (* See Table 3-8. *);
    BREAK;
    EAX = 80000002H:
        EAX := Processor Brand String;
        EBX := Processor Brand String,
            continued;
        ECX := Processor Brand String,
            continued;
        EDX := Processor Brand String,
            continued;
    BREAK;
    EAX = 80000003H:
        EAX := Processor Brand String,
            continued;
        EBX := Processor Brand String,
            continued;
        ECX := Processor Brand String,
            continued;
        EDX := Processor Brand String,
            continued;
    BREAK;
    EAX = 80000004H:
        EAX := Processor Brand String,
            continued;
        EBX := Processor Brand String,
            continued;
        ECX := Processor Brand String,
            continued;
        EDX := Processor Brand String, continued;
    BREAK;
    EAX = 80000005H:
        EAX := Reserved = 0;
        EBX := Reserved = 0;
        ECX := Reserved = 0;
        EDX := Reserved = 0;
    BREAK;
    EAX = 80000006H:
        EAX := Reserved = 0;
        EBX := Reserved = 0;
        ECX := Cache information;
        EDX := Reserved = 0;
    BREAK;
    EAX = 80000007H:
        EAX := Reserved = 0;
        EBX := Reserved = 0;
        ECX := Reserved = 0;
        EDX := Reserved = Misc Feature Flags;
    BREAK;
    EAX = 80000008H:
        EAX := Address Size Information;
        EBX := Misc Feature Flags;
        ECX := Reserved = 0;
        EDX := Reserved = 0;
    BREAK;
    EAX >= 40000000H and EAX <= 4FFFFFFFH:
    DEFAULT: (* EAX = Value outside of recognized range for CPUID. *)
        (* If the highest basic information leaf data depend on ECX input value, ECX is honored.*)
        EAX := Reserved; (* Information returned for highest basic information leaf. *)
        EBX := Reserved; (* Information returned for highest basic information leaf. *)
        ECX := Reserved; (* Information returned for highest basic information leaf. *)
        EDX := Reserved; (* Information returned for highest basic information leaf. *)
    BREAK;
ESAC;
.EE

.SH FLAGS AFFECTED
None.

.SH EXCEPTIONS (ALL OPERATING MODES)  href="cpuid.html#exceptions--all-operating-modes-"
class="anchor">¶

.PP
#UD If the LOCK prefix is used.

.PP
In earlier IA-32 processors that do not support the CPUID instruction,
execution of the instruction results in an invalid opcode (#UD)
exception being generated.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
