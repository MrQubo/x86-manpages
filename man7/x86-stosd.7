'\" t
.nh
.TH "X86-STOS-STOSB-STOSW-STOSD-STOSQ" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
STOS-STOSB-STOSW-STOSD-STOSQ - STORE STRING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOpcode\fP	\fBInstruction\fP	\fBOp/En\fP	\fB64-Bit Mode\fP	\fBCompat/Leg Mode\fP	\fBDescription\fP
AA	STOS m8	ZO	Valid	Valid	T{
For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI.
T}
AB	STOS m16	ZO	Valid	Valid	T{
For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI.
T}
AB	STOS m32	ZO	Valid	Valid	T{
For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI.
T}
REX.W + AB	STOS m64	ZO	Valid	N.E.	T{
Store RAX at address RDI or EDI.
T}
AA	STOSB	ZO	Valid	Valid	T{
For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI.
T}
AB	STOSW	ZO	Valid	Valid	T{
For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI.
T}
AB	STOSD	ZO	Valid	Valid	T{
For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI.
T}
REX.W + AB	STOSQ	ZO	Valid	N.E.	T{
Store RAX at address RDI or EDI.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING <a
href="./stos:stosb:stosw:stosd:stosq.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
ZO	N/A	N/A	N/A	N/A
.TE

.SH DESCRIPTION  href="./stos:stosb:stosw:stosd:stosq.html#description"
class="anchor">¶

.PP
In non-64-bit and default 64-bit mode; stores a byte, word, or
doubleword from the AL, AX, or EAX register (respectively) into the
destination operand. The destination operand is a memory location, the
address of which is read from either the ES:EDI or ES:DI register
(depending on the address-size attribute of the instruction and the mode
of operation). The ES segment cannot be overridden with a segment
override prefix.

.PP
At the assembly-code level, two forms of the instruction are allowed:
the “explicit-operands” form and the “no-operands” form. The
explicit-operands form (specified with the STOS mnemonic) allows the
destination operand to be specified explicitly. Here, the destination
operand should be a symbol that indicates the size and location of the
destination value. The source operand is then automatically selected to
match the size of the destination operand (the AL register for byte
operands, AX for word operands, EAX for doubleword operands). The
explicit-operands form is provided to allow documentation; however, note
that the documentation provided by this form can be misleading. That is,
the destination operand symbol must specify the correct \fBtype\fP (size)
of the operand (byte, word, or doubleword), but it does not have to
specify the correct \fBlocation\fP\&. The location is always specified by
the ES:(E)DI register. These must be loaded correctly before the store
string instruction is executed.

.PP
The no-operands form provides “short forms” of the byte, word,
doubleword, and quadword versions of the STOS instructions. Here also
ES:(E)DI is assumed to be the destination operand and AL, AX, or EAX is
assumed to be the source operand. The size of the destination and source
operands is selected by the mnemonic: STOSB (byte read from register
AL), STOSW (word from AX), STOSD (doubleword from EAX).

.PP
After the byte, word, or doubleword is transferred from the register to
the memory location, the (E)DI register is incremented or decremented
according to the setting of the DF flag in the EFLAGS register. If the
DF flag is 0, the register is incremented; if the DF flag is 1, the
register is decremented (the register is incremented or decremented by 1
for byte operations, by 2 for word operations, by 4 for doubleword
operations).

.PP
.RS

.PP
To improve performance, more recent processors support modifications
to the processor’s operation during the string store operations
initiated with STOS and STOSB. See Section 7.3.9.3 in the
Intel® 64 and IA-32 Architectures Software Developer’s
Manual, Volume 1, for additional information on fast-string operation.

.RE

.PP
In 64-bit mode, the default address size is 64 bits, 32-bit address size
is supported using the prefix 67H. Using a REX prefix in the form of
REX.W promotes operation on doubleword operand to 64 bits. The promoted
no-operand mnemonic is STOSQ. STOSQ (and its explicit operands variant)
store a quadword from the RAX register into the destination addressed by
RDI or EDI. See the summary chart at the beginning of this section for
encoding data and limits.

.PP
The STOS, STOSB, STOSW, STOSD, STOSQ instructions can be preceded by the
REP prefix for block stores of ECX bytes, words, or doublewords. More
often, however, these instructions are used within a LOOP construct
because data needs to be moved into the AL, AX, or EAX register before
it can be stored. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String
Operation Prefix” in this chapter for a description of the REP prefix.

.SH OPERATION  href="./stos:stosb:stosw:stosd:stosq.html#operation"
class="anchor">¶

.SS NON-64-BIT MODE:  href="./stos:stosb:stosw:stosd:stosq.html#non-64-bit-mode-"
class="anchor">¶

.EX
IF (Byte store)
    THEN
        DEST := AL;
            THEN IF DF = 0
                THEN (E)DI := (E)DI + 1;
                ELSE (E)DI := (E)DI – 1;
            FI;
    ELSE IF (Word store)
        THEN
            DEST := AX;
                THEN IF DF = 0
                    THEN (E)DI := (E)DI + 2;
                    ELSE (E)DI := (E)DI – 2;
                FI;
        FI;
    ELSE IF (Doubleword store)
        THEN
            DEST := EAX;
                THEN IF DF = 0
                    THEN (E)DI := (E)DI + 4;
                    ELSE (E)DI := (E)DI – 4;
                FI;
        FI;
FI;
.EE

.SS 64-BIT MODE:  href="./stos:stosb:stosw:stosd:stosq.html#64-bit-mode-"
class="anchor">¶

.EX
IF (Byte store)
    THEN
        DEST := AL;
            THEN IF DF = 0
                THEN (R|E)DI := (R|E)DI + 1;
                ELSE (R|E)DI := (R|E)DI – 1;
            FI;
    ELSE IF (Word store)
        THEN
            DEST := AX;
                THEN IF DF = 0
                    THEN (R|E)DI := (R|E)DI + 2;
                    ELSE (R|E)DI := (R|E)DI – 2;
                FI;
        FI;
    ELSE IF (Doubleword store)
        THEN
            DEST := EAX;
                THEN IF DF = 0
                    THEN (R|E)DI := (R|E)DI + 4;
                    ELSE (R|E)DI := (R|E)DI – 4;
                FI;
        FI;
    ELSE IF (Quadword store using REX.W )
        THEN
            DEST := RAX;
                THEN IF DF = 0
                    THEN (R|E)DI := (R|E)DI + 8;
                    ELSE (R|E)DI := (R|E)DI – 8;
                FI;
        FI;
FI;
.EE

.SH FLAGS AFFECTED  href="./stos:stosb:stosw:stosd:stosq.html#flags-affected"
class="anchor">¶

.PP
None.

.SH PROTECTED MODE EXCEPTIONS  href="./stos:stosb:stosw:stosd:stosq.html#protected-mode-exceptions"
class="anchor">¶

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the destination is located in a non-writable segment.
T}
	T{
If a memory operand effective address is outside the limit of the ES segment.
T}
	T{
If the ES register contains a NULL segment selector.
T}
#PF(fault-code)	If a page fault occurs.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
T}
#UD	If the LOCK prefix is used.
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS <a
href="./stos:stosb:stosw:stosd:stosq.html#real-address-mode-exceptions"
class="anchor">¶

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP	T{
If a memory operand effective address is outside the ES segment limit.
T}
#UD	If the LOCK prefix is used.
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS <a
href="./stos:stosb:stosw:stosd:stosq.html#virtual-8086-mode-exceptions"
class="anchor">¶

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If a memory operand effective address is outside the ES segment limit.
T}
#PF(fault-code)	If a page fault occurs.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made.
T}
#UD	If the LOCK prefix is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS <a
href="./stos:stosb:stosw:stosd:stosq.html#compatibility-mode-exceptions"
class="anchor">¶

.PP
Same exceptions as in protected mode.

.SH 64-BIT MODE EXCEPTIONS  href="./stos:stosb:stosw:stosd:stosq.html#64-bit-mode-exceptions"
class="anchor">¶

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the memory address is in a non-canonical form.
T}
#PF(fault-code)	If a page fault occurs.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
T}
#UD	If the LOCK prefix is used.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
