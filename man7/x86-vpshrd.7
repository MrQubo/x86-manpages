'\" t
.nh
.TH "X86-VPSHRD" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
VPSHRD - CONCATENATE AND SHIFT PACKED DATA RIGHT LOGICAL
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
EVEX.128.66.0F3A.W1 72 /r /ib VPSHRDW xmm1{k1}{z}, xmm2, xmm3/m128, imm8
T}	A	V/V	AVX512_VBMI2 AVX512VL	T{
Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into xmm1.
T}
T{
EVEX.256.66.0F3A.W1 72 /r /ib VPSHRDW ymm1{k1}{z}, ymm2, ymm3/m256, imm8
T}	A	V/V	AVX512_VBMI2 AVX512VL	T{
Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into ymm1.
T}
T{
EVEX.512.66.0F3A.W1 72 /r /ib VPSHRDW zmm1{k1}{z}, zmm2, zmm3/m512, imm8
T}	A	V/V	AVX512_VBMI2	T{
Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into zmm1.
T}
T{
EVEX.128.66.0F3A.W0 73 /r /ib VPSHRDD xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst, imm8
T}	B	V/V	AVX512_VBMI2 AVX512VL	T{
Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into xmm1.
T}
T{
EVEX.256.66.0F3A.W0 73 /r /ib VPSHRDD ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst, imm8
T}	B	V/V	AVX512_VBMI2 AVX512VL	T{
Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into ymm1.
T}
T{
EVEX.512.66.0F3A.W0 73 /r /ib VPSHRDD zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst, imm8
T}	B	V/V	AVX512_VBMI2	T{
Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into zmm1.
T}
T{
EVEX.128.66.0F3A.W1 73 /r /ib VPSHRDQ xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst, imm8
T}	B	V/V	AVX512_VBMI2 AVX512VL	T{
Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into xmm1.
T}
T{
EVEX.256.66.0F3A.W1 73 /r /ib VPSHRDQ ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst, imm8
T}	B	V/V	AVX512_VBMI2 AVX512VL	T{
Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into ymm1.
T}
T{
EVEX.512.66.0F3A.W1 73 /r /ib VPSHRDQ zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst, imm8
T}	B	V/V	AVX512_VBMI2	T{
Concatenate destination and source operands, extract result shifted to the right by constant value in imm8 into zmm1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	Full Mem	ModRM:reg (w)	EVEX.vvvv (r)	ModRM:r/m (r)	imm8 (r)
B	Full	ModRM:reg (w)	EVEX.vvvv (r)	ModRM:r/m (r)	imm8 (r)
.TE

.SS DESCRIPTION
Concatenate packed data, extract result shifted to the right by constant
value.

.PP
This instruction supports memory fault suppression.

.SS OPERATION
.SS VPSHRDW DEST, SRC2, SRC3, IMM8  href="vpshrd.html#vpshrdw-dest--src2--src3--imm8"
class="anchor">¶

.EX
(KL, VL) = (8, 128), (16, 256), (32, 512)
FOR j := 0 TO KL-1:
    IF MaskBit(j) OR *no writemask*:
        DEST.word[j] := concat(SRC3.word[j], SRC2.word[j]) >> (imm8 & 15)
    ELSE IF *zeroing*:
        DEST.word[j] := 0
    *ELSE DEST.word[j] remains unchanged*
DEST[MAX_VL-1:VL] := 0
.EE

.SS VPSHRDD DEST, SRC2, SRC3, IMM8  href="vpshrd.html#vpshrdd-dest--src2--src3--imm8"
class="anchor">¶

.EX
(KL, VL) = (4, 128), (8, 256), (16, 512)
FOR j := 0 TO KL-1:
    IF SRC3 is broadcast memop:
        tsrc3 := SRC3.dword[0]
    ELSE:
        tsrc3 := SRC3.dword[j]
    IF MaskBit(j) OR *no writemask*:
        DEST.dword[j] := concat(tsrc3, SRC2.dword[j]) >> (imm8 & 31)
    ELSE IF *zeroing*:
        DEST.dword[j] := 0
    *ELSE DEST.dword[j] remains unchanged*
DEST[MAX_VL-1:VL] := 0
.EE

.SS VPSHRDQ DEST, SRC2, SRC3, IMM8  href="vpshrd.html#vpshrdq-dest--src2--src3--imm8"
class="anchor">¶

.EX
(KL, VL) = (2, 128), (4, 256), (8, 512)
FOR j := 0 TO KL-1:
    IF SRC3 is broadcast memop:
        tsrc3 := SRC3.qword[0]
    ELSE:
        tsrc3 := SRC3.qword[j]
    IF MaskBit(j) OR *no writemask*:
        DEST.qword[j] := concat(tsrc3, SRC2.qword[j]) >> (imm8 & 63)
    ELSE IF *zeroing*:
        DEST.qword[j] := 0
    *ELSE DEST.qword[j] remains unchanged*
DEST[MAX_VL-1:VL] := 0
.EE

.SS INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="vpshrd.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
VPSHRDQ __m128i _mm_shrdi_epi64(__m128i, __m128i, int);

VPSHRDQ __m128i _mm_mask_shrdi_epi64(__m128i, __mmask8, __m128i, __m128i, int);

VPSHRDQ __m128i _mm_maskz_shrdi_epi64(__mmask8, __m128i, __m128i, int);

VPSHRDQ __m256i _mm256_shrdi_epi64(__m256i, __m256i, int);

VPSHRDQ __m256i _mm256_mask_shrdi_epi64(__m256i, __mmask8, __m256i, __m256i, int);

VPSHRDQ __m256i _mm256_maskz_shrdi_epi64(__mmask8, __m256i, __m256i, int);

VPSHRDQ __m512i _mm512_shrdi_epi64(__m512i, __m512i, int);

VPSHRDQ __m512i _mm512_mask_shrdi_epi64(__m512i, __mmask8, __m512i, __m512i, int);

VPSHRDQ __m512i _mm512_maskz_shrdi_epi64(__mmask8, __m512i, __m512i, int);

VPSHRDD __m128i _mm_shrdi_epi32(__m128i, __m128i, int);

VPSHRDD __m128i _mm_mask_shrdi_epi32(__m128i, __mmask8, __m128i, __m128i, int);

VPSHRDD __m128i _mm_maskz_shrdi_epi32(__mmask8, __m128i, __m128i, int);

VPSHRDD __m256i _mm256_shrdi_epi32(__m256i, __m256i, int);

VPSHRDD __m256i _mm256_mask_shrdi_epi32(__m256i, __mmask8, __m256i, __m256i, int);

VPSHRDD __m256i _mm256_maskz_shrdi_epi32(__mmask8, __m256i, __m256i, int);

VPSHRDD __m512i _mm512_shrdi_epi32(__m512i, __m512i, int);

VPSHRDD __m512i _mm512_mask_shrdi_epi32(__m512i, __mmask16, __m512i, __m512i, int);

VPSHRDD __m512i _mm512_maskz_shrdi_epi32(__mmask16, __m512i, __m512i, int);

VPSHRDW __m128i _mm_shrdi_epi16(__m128i, __m128i, int);

VPSHRDW __m128i _mm_mask_shrdi_epi16(__m128i, __mmask8, __m128i, __m128i, int);

VPSHRDW __m128i _mm_maskz_shrdi_epi16(__mmask8, __m128i, __m128i, int);

VPSHRDW __m256i _mm256_shrdi_epi16(__m256i, __m256i, int);

VPSHRDW __m256i _mm256_mask_shrdi_epi16(__m256i, __mmask16, __m256i, __m256i, int);

VPSHRDW __m256i _mm256_maskz_shrdi_epi16(__mmask16, __m256i, __m256i, int);

VPSHRDW __m512i _mm512_shrdi_epi16(__m512i, __m512i, int);

VPSHRDW __m512i _mm512_mask_shrdi_epi16(__m512i, __mmask32, __m512i, __m512i, int);

VPSHRDW __m512i _mm512_maskz_shrdi_epi16(__mmask32, __m512i, __m512i, int);
.EE

.SS SIMD FLOATING-POINT EXCEPTIONS  href="vpshrd.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
None.

.SS OTHER EXCEPTIONS
See Table 2-49, “Type E4 Class
Exception Conditions.”

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
