'\" t
.nh
.TH "X86-GETSEC[SMCTRL]" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
GETSEC[SMCTRL] - SMX MODE CONTROL
.TS
allbox;
l l l 
l l l .
\fBOpcode\fP	\fBInstruction\fP	\fBDescription\fP
NP 0F 37 (EAX = 7)	GETSEC[SMCTRL]	T{
Perform specified SMX mode control as selected with the input EBX.
T}
.TE

.SH DESCRIPTION
The GETSEC[SMCTRL] instruction is available for performing certain SMX
specific mode control operations. The operation to be performed is
selected through the input register EBX. Currently only an input value
in EBX of 0 is supported. All other EBX settings will result in the
signaling of a general protection violation.

.PP
If EBX is set to 0, then the SMCTRL leaf is used to re-enable SMI
events. SMI is masked by the ILP executing the GETSEC[SENTER]
instruction (SMI is also masked in the responding logical processors in
response to SENTER rendezvous messages.). The determination of when this
instruction is allowed and the events that are unmasked is dependent on
the processor context (See Table
7-11). For brevity, the usage of SMCTRL where EBX=0 will be
referred to as GETSEC[SMCTRL(0)]\&.

.PP
As part of support for launching a measured environment, the SMI, NMI,
and INIT events are masked after GETSEC[SENTER], and remain masked
after exiting authenticated execution mode. Unmasking these events
should be accompanied by securely enabling these event handlers. These
security concerns can be addressed in VMX operation by a MVMM.

.PP
The VM monitor can choose two approaches:
.IP \(bu 2
In a dual monitor approach, the executive software will set up an
SMM monitor in parallel to the executive VMM (i.e., the MVMM), see
Chapter 32, “System Management Mode‚” of Intel® 64 and
IA-32 Architectures Software Developer’s Manual, Volume 3C. The SMM
monitor is dedicated to handling SMI events without compromising the
security of the MVMM. This usage model of handling SMI while a
measured environment is active does not require the use of
GETSEC[SMCTRL(0)] as event re-enabling after the VMX environment
launch is handled implicitly and through separate VMX based
controls.
.IP \(bu 2
If a dedicated SMM monitor will not be established and SMIs are to
be handled within the measured environment, then GETSEC[SMCTRL(0)]
can be used by the executive software to re-enable SMI that has been
masked as a result of SENTER.

.PP
Table 7-11 defines the processor
context in which GETSEC[SMCTRL(0)] can be used and which events will
be unmasked. Note that the events that are unmasked are dependent upon
the currently operating processor context.

.SH OPERATION
.EX
(* The state of the internal flag ACMODEFLAG and SENTERFLAG persist across instruction boundary *)
IF (CR4.SMXE=0)
    THEN #UD;
ELSE IF (in VMX non-root operation)
    THEN VM Exit (reason=”GETSEC instruction”);
ELSE IF (GETSEC leaf unsupported)
    THEN #UD;
ELSE IF ((CR0.PE=0) or (CPL>0) OR (EFLAGS.VM=1))
    THEN #GP(0);
ELSE IF((EBX=0) and (SENTERFLAG=1) and (ACMODEFLAG=0) and (IN_SMM=0) and
        (((in VMX root operation) and (SMM monitor not configured)) or (not in VMX operation)) )
    THEN unmask SMI;
ELSE
    #GP(0);
END
.EE

.SH FLAGS AFFECTED
None.

.SH USE OF PREFIXES
LOCK Causes #UD.

.PP
REP* Cause #UD (includes REPNE/REPNZ and REP/REPE/REPZ).

.PP
Operand size Causes #UD.

.PP
NP 66/F2/F3 prefixes are not allowed.

.PP
Segmentoverrides Ignored.

.PP
Address size Ignored.

.PP
REX Ignored.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If CR4.SMXE = 0.
	If GETSEC[SMCTRL] is not reported as supported by GETSEC[CAPABILITIES]\&.
#GP(0)	IfCR0.PE=0orCPL&gt;0orEFLAGS.VM=1.
	If in VMX root operation.
	T{
If a protected partition is not already active or the processor is currently in authenticated code mode.
T}
	If the processor is in SMM.
	T{
If the SMM monitor is not configured.
T}
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If CR4.SMXE = 0.
	If GETSEC[SMCTRL] is not reported as supported by GETSEC[CAPABILITIES]\&.
#GP(0)	GETSEC[SMCTRL] is not recognized in real-address mode.
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If CR4.SMXE = 0.
	If GETSEC[SMCTRL] is not reported as supported by GETSEC[CAPABILITIES]\&.
#GP(0)	GETSEC[SMCTRL] is not recognized in virtual-8086 mode.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
All protected mode exceptions apply.

.SH 64-BIT MODE EXCEPTIONS
All protected mode exceptions apply.

.SH VM-EXIT CONDITION
Reason (GETSEC) If in VMX non-root operation.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
