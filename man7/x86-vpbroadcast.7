'\" t
.nh
.TH "X86-VPBROADCAST" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
VPBROADCAST - LOAD INTEGER AND BROADCAST
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
VEX.128.66.0F38.W0 78 /r VPBROADCASTB xmm1, xmm2/m8
T}	A	V/V	AVX2	T{
Broadcast a byte integer in the source operand to sixteen locations in xmm1.
T}
T{
VEX.256.66.0F38.W0 78 /r VPBROADCASTB ymm1, xmm2/m8
T}	A	V/V	AVX2	T{
Broadcast a byte integer in the source operand to thirty-two locations in ymm1.
T}
T{
EVEX.128.66.0F38.W0 78 /r VPBROADCASTB xmm1{k1}{z}, xmm2/m8
T}	B	V/V	AVX512VL AVX512BW	T{
Broadcast a byte integer in the source operand to locations in xmm1 subject to writemask k1.
T}
T{
EVEX.256.66.0F38.W0 78 /r VPBROADCASTB ymm1{k1}{z}, xmm2/m8
T}	B	V/V	AVX512VL AVX512BW	T{
Broadcast a byte integer in the source operand to locations in ymm1 subject to writemask k1.
T}
T{
EVEX.512.66.0F38.W0 78 /r VPBROADCASTB zmm1{k1}{z}, xmm2/m8
T}	B	V/V	AVX512BW	T{
Broadcast a byte integer in the source operand to 64 locations in zmm1 subject to writemask k1.
T}
T{
VEX.128.66.0F38.W0 79 /r VPBROADCASTW xmm1, xmm2/m16
T}	A	V/V	AVX2	T{
Broadcast a word integer in the source operand to eight locations in xmm1.
T}
T{
VEX.256.66.0F38.W0 79 /r VPBROADCASTW ymm1, xmm2/m16
T}	A	V/V	AVX2	T{
Broadcast a word integer in the source operand to sixteen locations in ymm1.
T}
T{
EVEX.128.66.0F38.W0 79 /r VPBROADCASTW xmm1{k1}{z}, xmm2/m16
T}	B	V/V	AVX512VL AVX512BW	T{
Broadcast a word integer in the source operand to locations in xmm1 subject to writemask k1.
T}
T{
EVEX.256.66.0F38.W0 79 /r VPBROADCASTW ymm1{k1}{z}, xmm2/m16
T}	B	V/V	AVX512VL AVX512BW	T{
Broadcast a word integer in the source operand to locations in ymm1 subject to writemask k1.
T}
T{
EVEX.512.66.0F38.W0 79 /r VPBROADCASTW zmm1{k1}{z}, xmm2/m16
T}	B	V/V	AVX512BW	T{
Broadcast a word integer in the source operand to 32 locations in zmm1 subject to writemask k1.
T}
T{
VEX.128.66.0F38.W0 58 /r VPBROADCASTD xmm1, xmm2/m32
T}	A	V/V	AVX2	T{
Broadcast a dword integer in the source operand to four locations in xmm1.
T}
T{
VEX.256.66.0F38.W0 58 /r VPBROADCASTD ymm1, xmm2/m32
T}	A	V/V	AVX2	T{
Broadcast a dword integer in the source operand to eight locations in ymm1.
T}
T{
EVEX.128.66.0F38.W0 58 /r VPBROADCASTD xmm1 {k1}{z}, xmm2/m32
T}	B	V/V	AVX512VL AVX512F	T{
Broadcast a dword integer in the source operand to locations in xmm1 subject to writemask k1.
T}
T{
EVEX.256.66.0F38.W0 58 /r VPBROADCASTD ymm1 {k1}{z}, xmm2/m32
T}	B	V/V	AVX512VL AVX512F	T{
Broadcast a dword integer in the source operand to locations in ymm1 subject to writemask k1.
T}
T{
EVEX.512.66.0F38.W0 58 /r VPBROADCASTD zmm1 {k1}{z}, xmm2/m32
T}	B	V/V	AVX512F	T{
Broadcast a dword integer in the source operand to locations in zmm1 subject to writemask k1.
T}
T{
VEX.128.66.0F38.W0 59 /r VPBROADCASTQ xmm1, xmm2/m64
T}	A	V/V	AVX2	T{
Broadcast a qword element in source operand to two locations in xmm1.
T}
T{
VEX.256.66.0F38.W0 59 /r VPBROADCASTQ ymm1, xmm2/m64
T}	A	V/V	AVX2	T{
Broadcast a qword element in source operand to four locations in ymm1.
T}
T{
EVEX.128.66.0F38.W1 59 /r VPBROADCASTQ xmm1 {k1}{z}, xmm2/m64
T}	B	V/V	AVX512VL AVX512F	T{
Broadcast a qword element in source operand to locations in xmm1 subject to writemask k1.
T}
T{
EVEX.256.66.0F38.W1 59 /r VPBROADCASTQ ymm1 {k1}{z}, xmm2/m64
T}	B	V/V	AVX512VL AVX512F	T{
Broadcast a qword element in source operand to locations in ymm1 subject to writemask k1.
T}
T{
EVEX.512.66.0F38.W1 59 /r VPBROADCASTQ zmm1 {k1}{z}, xmm2/m64
T}	B	V/V	AVX512F	T{
Broadcast a qword element in source operand to locations in zmm1 subject to writemask k1.
T}
T{
EVEX.128.66.0F38.W0 59 /r VBROADCASTI32x2 xmm1 {k1}{z}, xmm2/m64
T}	C	V/V	AVX512VL AVX512DQ	T{
Broadcast two dword elements in source operand to locations in xmm1 subject to writemask k1.
T}
T{
EVEX.256.66.0F38.W0 59 /r VBROADCASTI32x2 ymm1 {k1}{z}, xmm2/m64
T}	C	V/V	AVX512VL AVX512DQ	T{
Broadcast two dword elements in source operand to locations in ymm1 subject to writemask k1.
T}
T{
EVEX.512.66.0F38.W0 59 /r VBROADCASTI32x2 zmm1 {k1}{z}, xmm2/m64
T}	C	V/V	AVX512DQ	T{
Broadcast two dword elements in source operand to locations in zmm1 subject to writemask k1.
T}
T{
VEX.256.66.0F38.W0 5A /r VBROADCASTI128 ymm1, m128
T}	A	V/V	AVX2	T{
Broadcast 128 bits of integer data in mem to low and high 128-bits in ymm1.
T}
T{
EVEX.256.66.0F38.W0 5A /r VBROADCASTI32X4 ymm1 {k1}{z}, m128
T}	D	V/V	AVX512VL AVX512F	T{
Broadcast 128 bits of 4 doubleword integer data in mem to locations in ymm1 using writemask k1.
T}
T{
EVEX.512.66.0F38.W0 5A /r VBROADCASTI32X4 zmm1 {k1}{z}, m128
T}	D	V/V	AVX512F	T{
Broadcast 128 bits of 4 doubleword integer data in mem to locations in zmm1 using writemask k1.
T}
T{
EVEX.256.66.0F38.W1 5A /r VBROADCASTI64X2 ymm1 {k1}{z}, m128
T}	C	V/V	AVX512VL AVX512DQ	T{
Broadcast 128 bits of 2 quadword integer data in mem to locations in ymm1 using writemask k1.
T}
T{
EVEX.512.66.0F38.W1 5A /r VBROADCASTI64X2 zmm1 {k1}{z}, m128
T}	C	V/V	AVX512DQ	T{
Broadcast 128 bits of 2 quadword integer data in mem to locations in zmm1 using writemask k1.
T}
T{
EVEX.512.66.0F38.W0 5B /r VBROADCASTI32X8 zmm1 {k1}{z}, m256
T}	E	V/V	AVX512DQ	T{
Broadcast 256 bits of 8 doubleword integer data in mem to locations in zmm1 using writemask k1.
T}
T{
EVEX.512.66.0F38.W1 5B /r VBROADCASTI64X4 zmm1 {k1}{z}, m256
T}	D	V/V	AVX512F	T{
Broadcast 256 bits of 4 quadword integer data in mem to locations in zmm1 using writemask k1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING  href="vpbroadcast.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple Type\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	N/A	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
B	Tuple1 Scalar	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
C	Tuple2	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
D	Tuple4	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
E	Tuple8	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
.TE

.SS DESCRIPTION
Load integer data from the source operand (the second operand) and
broadcast to all elements of the destination operand (the first
operand).

.PP
VEX256-encoded VPBROADCASTB/W/D/Q: The source operand is 8-bit, 16-bit,
32-bit, 64-bit memory location or the low 8-bit, 16-bit 32-bit, 64-bit
data in an XMM register. The destination operand is a YMM register.
VPBROAD-CASTI128 support the source operand of 128-bit memory location.
Register source encodings for VPBROADCAS-TI128 is reserved and will
#UD. Bits (MAXVL-1:256) of the destination register are zeroed.

.PP
EVEX-encoded VPBROADCASTD/Q: The source operand is a 32-bit, 64-bit
memory location or the low 32-bit, 64-bit data in an XMM register. The
destination operand is a ZMM/YMM/XMM register and updated according to
the writemask k1.

.PP
VPBROADCASTI32X4 and VPBROADCASTI64X4: The destination operand is a ZMM
register and updated according to the writemask k1. The source operand
is 128-bit or 256-bit memory location. Register source encodings for
VBROADCASTI32X4 and VBROADCASTI64X4 are reserved and will #UD.

.PP
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise
instructions will #UD.

.PP
If VPBROADCASTI128 is encoded with VEX.L= 0, an attempt to execute the
instruction encoded with VEX.L= 0 will cause an #UD exception.

.SS OPERATION
.SS VPBROADCASTB (EVEX ENCODED VERSIONS)  href="vpbroadcast.html#vpbroadcastb--evex-encoded-versions-"
class="anchor">¶

.EX
(KL, VL) = (16, 128), (32, 256), (64, 512)
FOR j := 0 TO KL-1
    i := j * 8
    IF k1[j] OR *no writemask*
        THEN DEST[i+7:i] := SRC[7:0]
        ELSE
            IF *merging-masking*
                        ; merging-masking
                THEN *DEST[i+7:i] remains unchanged*
                ELSE
                        ; zeroing-masking
                    DEST[i+7:i] := 0
            FI
    FI;
ENDFOR
DEST[MAXVL-1:VL] := 0
.EE

.SS VPBROADCASTW (EVEX ENCODED VERSIONS)  href="vpbroadcast.html#vpbroadcastw--evex-encoded-versions-"
class="anchor">¶

.EX
(KL, VL) = (8, 128), (16, 256), (32, 512)
FOR j := 0 TO KL-1
    i := j * 16
    IF k1[j] OR *no writemask*
        THEN DEST[i+15:i] := SRC[15:0]
        ELSE
            IF *merging-masking*
                        ; merging-masking
                THEN *DEST[i+15:i] remains unchanged*
                ELSE
                        ; zeroing-masking
                    DEST[i+15:i] := 0
            FI
    FI;
ENDFOR
DEST[MAXVL-1:VL] := 0
.EE

.SS VPBROADCASTD (128 BIT VERSION)  href="vpbroadcast.html#vpbroadcastd--128-bit-version-"
class="anchor">¶

.EX
temp := SRC[31:0]
DEST[31:0] := temp
DEST[63:32] := temp
DEST[95:64] := temp
DEST[127:96] := temp
DEST[MAXVL-1:128] := 0
.EE

.SS VPBROADCASTD (VEX.256 ENCODED VERSION)  href="vpbroadcast.html#vpbroadcastd--vex-256-encoded-version-"
class="anchor">¶

.EX
temp := SRC[31:0]
DEST[31:0] := temp
DEST[63:32] := temp
DEST[95:64] := temp
DEST[127:96] := temp
DEST[159:128] := temp
DEST[191:160] := temp
DEST[223:192] := temp
DEST[255:224] := temp
DEST[MAXVL-1:256] := 0
VPBROADCASTD (EVEX encoded versions)
(KL, VL) = (4, 128), (8, 256), (16, 512)
FOR j := 0 TO KL-1
    i := j * 32
    IF k1[j] OR *no writemask*
        THEN DEST[i+31:i] := SRC[31:0]
        ELSE
            IF *merging-masking*
                        ; merging-masking
                THEN *DEST[i+31:i] remains unchanged*
                ELSE
                        ; zeroing-masking
                    DEST[i+31:i] := 0
            FI
    FI;
ENDFOR
DEST[MAXVL-1:VL] := 0
.EE

.SS VPBROADCASTQ (VEX.256 ENCODED VERSION)  href="vpbroadcast.html#vpbroadcastq--vex-256-encoded-version-"
class="anchor">¶

.EX
temp := SRC[63:0]
DEST[63:0] := temp
DEST[127:64] := temp
DEST[191:128] := temp
DEST[255:192] := temp
DEST[MAXVL-1:256] := 0
.EE

.SS VPBROADCASTQ (EVEX ENCODED VERSIONS)  href="vpbroadcast.html#vpbroadcastq--evex-encoded-versions-"
class="anchor">¶

.EX
(KL, VL) = (2, 128), (4, 256), (8, 512)
FOR j := 0 TO KL-1
    i := j * 64
    IF k1[j] OR *no writemask*
        THEN DEST[i+63:i] := SRC[63:0]
        ELSE
            IF *merging-masking*
                        ; merging-masking
                THEN *DEST[i+63:i] remains unchanged*
                ELSE
                        ; zeroing-masking
                    DEST[i+63:i] := 0
            FI
    FI;
ENDFOR
DEST[MAXVL-1:VL] := 0
VBROADCASTI32x2 (EVEX encoded versions)
(KL, VL) = (4, 128), (8, 256), (16, 512)
FOR j := 0 TO KL-1
    i := j * 32
    n := (j mod 2) * 32
    IF k1[j] OR *no writemask*
        THEN DEST[i+31:i] := SRC[n+31:n]
        ELSE
            IF *merging-masking*
                        ; merging-masking
                THEN *DEST[i+31:i] remains unchanged*
                ELSE
                        ; zeroing-masking
                    DEST[i+31:i] := 0
            FI
    FI;
ENDFOR
DEST[MAXVL-1:VL] := 0
.EE

.SS VBROADCASTI128 (VEX.256 ENCODED VERSION)  href="vpbroadcast.html#vbroadcasti128--vex-256-encoded-version-"
class="anchor">¶

.EX
temp := SRC[127:0]
DEST[127:0] := temp
DEST[255:128] := temp
DEST[MAXVL-1:256] := 0
.EE

.SS VBROADCASTI32X4 (EVEX ENCODED VERSIONS)  href="vpbroadcast.html#vbroadcasti32x4--evex-encoded-versions-"
class="anchor">¶

.EX
(KL, VL) = (8, 256), (16, 512)
FOR j := 0 TO KL-1
    i := j* 32
    n := (j modulo 4) * 32
    IF k1[j] OR *no writemask*
        THEN DEST[i+31:i] := SRC[n+31:n]
        ELSE
            IF *merging-masking*
                        ; merging-masking
                THEN *DEST[i+31:i] remains unchanged*
                ELSE
                        ; zeroing-masking
                    DEST[i+31:i] := 0
            FI
    FI;
ENDFOR
DEST[MAXVL-1:VL] := 0
.EE

.SS VBROADCASTI64X2 (EVEX ENCODED VERSIONS)  href="vpbroadcast.html#vbroadcasti64x2--evex-encoded-versions-"
class="anchor">¶

.EX
(KL, VL) = (8, 256), (16, 512)
FOR j := 0 TO KL-1
    i := j * 64
    n := (j modulo 2) * 64
    IF k1[j] OR *no writemask*
        THEN DEST[i+63:i] := SRC[n+63:n]
        ELSE
            IF *merging-masking*
                THEN *DEST[i+63:i] remains unchanged*
                ELSE ; zeroing-masking
                    DEST[i+63:i] = 0
            FI
    FI;
ENDFOR;
.EE

.SS VBROADCASTI32X8 (EVEX.U1.512 ENCODED VERSION)  href="vpbroadcast.html#vbroadcasti32x8--evex-u1-512-encoded-version-"
class="anchor">¶

.EX
FOR j := 0 TO 15
    i := j * 32
    n := (j modulo 8) * 32
    IF k1[j] OR *no writemask*
        THEN DEST[i+31:i] := SRC[n+31:n]
        ELSE
            IF *merging-masking*
                        ; merging-masking
                THEN *DEST[i+31:i] remains unchanged*
                ELSE
                        ; zeroing-masking
                    DEST[i+31:i] := 0
            FI
    FI;
ENDFOR
DEST[MAXVL-1:VL] := 0
.EE

.SS VBROADCASTI64X4 (EVEX.512 ENCODED VERSION)  href="vpbroadcast.html#vbroadcasti64x4--evex-512-encoded-version-"
class="anchor">¶

.EX
FOR j := 0 TO 7
    i := j * 64
    n := (j modulo 4) * 64
    IF k1[j] OR *no writemask*
        THEN DEST[i+63:i] := SRC[n+63:n]
        ELSE
            IF *merging-masking*
                THEN *DEST[i+63:i] remains unchanged*
                ELSE ; zeroing-masking
                    DEST[i+63:i] := 0
            FI
    FI;
ENDFOR
DEST[MAXVL-1:VL] := 0
.EE

.SS INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="vpbroadcast.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
VPBROADCASTB __m512i _mm512_broadcastb_epi8( __m128i a);

VPBROADCASTB __m512i _mm512_mask_broadcastb_epi8(__m512i s, __mmask64 k, __m128i a);

VPBROADCASTB __m512i _mm512_maskz_broadcastb_epi8( __mmask64 k, __m128i a);

VPBROADCASTB __m256i _mm256_broadcastb_epi8(__m128i a);

VPBROADCASTB __m256i _mm256_mask_broadcastb_epi8(__m256i s, __mmask32 k, __m128i a);

VPBROADCASTB __m256i _mm256_maskz_broadcastb_epi8( __mmask32 k, __m128i a);

VPBROADCASTB __m128i _mm_mask_broadcastb_epi8(__m128i s, __mmask16 k, __m128i a);

VPBROADCASTB __m128i _mm_maskz_broadcastb_epi8( __mmask16 k, __m128i a);

VPBROADCASTB __m128i _mm_broadcastb_epi8(__m128i a);

VPBROADCASTD __m512i _mm512_broadcastd_epi32( __m128i a);

VPBROADCASTD __m512i _mm512_mask_broadcastd_epi32(__m512i s, __mmask16 k, __m128i a);

VPBROADCASTD __m512i _mm512_maskz_broadcastd_epi32( __mmask16 k, __m128i a);

VPBROADCASTD __m256i _mm256_broadcastd_epi32( __m128i a);

VPBROADCASTD __m256i _mm256_mask_broadcastd_epi32(__m256i s, __mmask8 k, __m128i a);

VPBROADCASTD __m256i _mm256_maskz_broadcastd_epi32( __mmask8 k, __m128i a);

VPBROADCASTD __m128i _mm_broadcastd_epi32(__m128i a);

VPBROADCASTD __m128i _mm_mask_broadcastd_epi32(__m128i s, __mmask8 k, __m128i a);

VPBROADCASTD __m128i _mm_maskz_broadcastd_epi32( __mmask8 k, __m128i a);

VPBROADCASTQ __m512i _mm512_broadcastq_epi64( __m128i a);

VPBROADCASTQ __m512i _mm512_mask_broadcastq_epi64(__m512i s, __mmask8 k, __m128i a);

VPBROADCASTQ __m512i _mm512_maskz_broadcastq_epi64( __mmask8 k, __m128i a);

VPBROADCASTQ __m256i _mm256_broadcastq_epi64(__m128i a);

VPBROADCASTQ __m256i _mm256_mask_broadcastq_epi64(__m256i s, __mmask8 k, __m128i a);

VPBROADCASTQ __m256i _mm256_maskz_broadcastq_epi64( __mmask8 k, __m128i a);

VPBROADCASTQ __m128i _mm_broadcastq_epi64(__m128i a);

VPBROADCASTQ __m128i _mm_mask_broadcastq_epi64(__m128i s, __mmask8 k, __m128i a);

VPBROADCASTQ __m128i _mm_maskz_broadcastq_epi64( __mmask8 k, __m128i a);

VPBROADCASTW __m512i _mm512_broadcastw_epi16(__m128i a);

VPBROADCASTW __m512i _mm512_mask_broadcastw_epi16(__m512i s, __mmask32 k, __m128i a);

VPBROADCASTW __m512i _mm512_maskz_broadcastw_epi16( __mmask32 k, __m128i a);

VPBROADCASTW __m256i _mm256_broadcastw_epi16(__m128i a);

VPBROADCASTW __m256i _mm256_mask_broadcastw_epi16(__m256i s, __mmask16 k, __m128i a);

VPBROADCASTW __m256i _mm256_maskz_broadcastw_epi16( __mmask16 k, __m128i a);

VPBROADCASTW __m128i _mm_broadcastw_epi16(__m128i a);

VPBROADCASTW __m128i _mm_mask_broadcastw_epi16(__m128i s, __mmask8 k, __m128i a);

VPBROADCASTW __m128i _mm_maskz_broadcastw_epi16( __mmask8 k, __m128i a);

VBROADCASTI32x2 __m512i _mm512_broadcast_i32x2( __m128i a);

VBROADCASTI32x2 __m512i _mm512_mask_broadcast_i32x2(__m512i s, __mmask16 k, __m128i a);

VBROADCASTI32x2 __m512i _mm512_maskz_broadcast_i32x2( __mmask16 k, __m128i a);

VBROADCASTI32x2 __m256i _mm256_broadcast_i32x2( __m128i a);

VBROADCASTI32x2 __m256i _mm256_mask_broadcast_i32x2(__m256i s, __mmask8 k, __m128i a);

VBROADCASTI32x2 __m256i _mm256_maskz_broadcast_i32x2( __mmask8 k, __m128i a);

VBROADCASTI32x2 __m128i _mm_broadcast_i32x2(__m128i a);

VBROADCASTI32x2 __m128i _mm_mask_broadcast_i32x2(__m128i s, __mmask8 k, __m128i a);

VBROADCASTI32x2 __m128i _mm_maskz_broadcast_i32x2( __mmask8 k, __m128i a);

VBROADCASTI32x4 __m512i _mm512_broadcast_i32x4( __m128i a);

VBROADCASTI32x4 __m512i _mm512_mask_broadcast_i32x4(__m512i s, __mmask16 k, __m128i a);

VBROADCASTI32x4 __m512i _mm512_maskz_broadcast_i32x4( __mmask16 k, __m128i a);

VBROADCASTI32x4 __m256i _mm256_broadcast_i32x4( __m128i a);

VBROADCASTI32x4 __m256i _mm256_mask_broadcast_i32x4(__m256i s, __mmask8 k, __m128i a);

VBROADCASTI32x4 __m256i _mm256_maskz_broadcast_i32x4( __mmask8 k, __m128i a);

VBROADCASTI32x8 __m512i _mm512_broadcast_i32x8( __m256i a);

VBROADCASTI32x8 __m512i _mm512_mask_broadcast_i32x8(__m512i s, __mmask16 k, __m256i a);

VBROADCASTI32x8 __m512i _mm512_maskz_broadcast_i32x8( __mmask16 k, __m256i a);

VBROADCASTI64x2 __m512i _mm512_broadcast_i64x2( __m128i a);

VBROADCASTI64x2 __m512i _mm512_mask_broadcast_i64x2(__m512i s, __mmask8 k, __m128i a);

VBROADCASTI64x2 __m512i _mm512_maskz_broadcast_i64x2( __mmask8 k, __m128i a);

VBROADCASTI64x2 __m256i _mm256_broadcast_i64x2( __m128i a);

VBROADCASTI64x2 __m256i _mm256_mask_broadcast_i64x2(__m256i s, __mmask8 k, __m128i a);

VBROADCASTI64x2 __m256i _mm256_maskz_broadcast_i64x2( __mmask8 k, __m128i a);

VBROADCASTI64x4 __m512i _mm512_broadcast_i64x4( __m256i a);

VBROADCASTI64x4 __m512i _mm512_mask_broadcast_i64x4(__m512i s, __mmask8 k, __m256i a);

VBROADCASTI64x4 __m512i _mm512_maskz_broadcast_i64x4( __mmask8 k, __m256i a);
.EE

.SS SIMD FLOATING-POINT EXCEPTIONS  href="vpbroadcast.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
None.

.SS OTHER EXCEPTIONS
EVEX-encoded instructions, see Table
2-23, “Type 6 Class Exception Conditions.”

.PP
EVEX-encoded instructions, syntax with reg/mem operand, see
Table 2-53, “Type E6 Class Exception
Conditions.”

.PP
Additionally:

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
If VEX.L = 0 for VPBROADCASTQ, VPBROADCASTI128.
T}
	T{
If EVEX.L’L = 0 for VBROADCASTI32X4/VBROADCASTI64X2.
T}
	If EVEX.L’L &lt; 10b for VBROADCASTI32X8/VBROADCASTI64X4.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
