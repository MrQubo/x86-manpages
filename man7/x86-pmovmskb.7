'\" t
.nh
.TH "X86-PMOVMSKB" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
PMOVMSKB - MOVE BYTE MASK
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
NP 0F D7 /r1 PMOVMSKB reg, mm	RM	V/V	SSE	T{
Move a byte mask of mm to reg. The upper bits of r32 or r64 are zeroed
T}
66 0F D7 /r PMOVMSKB reg, xmm	RM	V/V	SSE2	T{
Move a byte mask of xmm to reg. The upper bits of r32 or r64 are zeroed
T}
T{
VEX.128.66.0F.WIG D7 /r VPMOVMSKB reg, xmm1
T}	RM	V/V	AVX	T{
Move a byte mask of xmm1 to reg. The upper bits of r32 or r64 are filled with zeros.
T}
T{
VEX.256.66.0F.WIG D7 /r VPMOVMSKB reg, ymm1
T}	RM	V/V	AVX2	T{
Move a 32-bit mask of ymm1 to reg. The upper bits of r64 are filled with zeros.
T}
.TE

.PP
.RS

.PP
1\&. See note in Section 2.5, “Intel® AVX and Intel® SSE Instruction
Exception Classification,” in the Intel® 64 and IA-32
Architectures Software Developer’s Manual, Volume 2A, and Section
23.25.3, “Exception Conditions of Legacy SIMD Instructions Operating
on MMX Registers,” in the Intel® 64 and IA-32 Architectures
Software Developer’s Manual, Volume 3B.

.RE

.SH INSTRUCTION OPERAND ENCODING  href="pmovmskb.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
RM	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
.TE

.SH DESCRIPTION
Creates a mask made up of the most significant bit of each byte of the
source operand (second operand) and stores the result in the low byte or
word of the destination operand (first operand).

.PP
The byte mask is 8 bits for 64-bit source operand, 16 bits for 128-bit
source operand and 32 bits for 256-bit source operand. The destination
operand is a general-purpose register.

.PP
In 64-bit mode, the instruction can access additional registers
(XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand
size is 64-bit in 64-bit mode.

.PP
Legacy SSE version: The source operand is an MMX technology register.

.PP
128-bit Legacy SSE version: The source operand is an XMM register.

.PP
VEX.128 encoded version: The source operand is an XMM register.

.PP
VEX.256 encoded version: The source operand is a YMM register.

.PP
Note: VEX.vvvv is reserved and must be 1111b.

.SH OPERATION
.SS PMOVMSKB (WITH 64-BIT SOURCE OPERAND AND R32)  href="pmovmskb.html#pmovmskb--with-64-bit-source-operand-and-r32-"
class="anchor">¶

.EX
r32[0] := SRC[7];
r32[1] := SRC[15];
(* Repeat operation for bytes 2 through 6 *)
r32[7] := SRC[63];
r32[31:8] := ZERO_FILL;
.EE

.SS (V)PMOVMSKB (WITH 128-BIT SOURCE OPERAND AND R32) <a
href="pmovmskb.html#-v-pmovmskb--with-128-bit-source-operand-and-r32-"
class="anchor">¶

.EX
r32[0] := SRC[7];
r32[1] := SRC[15];
(* Repeat operation for bytes 2 through 14 *)
r32[15] := SRC[127];
r32[31:16] := ZERO_FILL;
.EE

.SS VPMOVMSKB (WITH 256-BIT SOURCE OPERAND AND R32)  href="pmovmskb.html#vpmovmskb--with-256-bit-source-operand-and-r32-"
class="anchor">¶

.EX
r32[0] := SRC[7];
r32[1] := SRC[15];
(* Repeat operation for bytes 3rd through 31*)
r32[31] := SRC[255];
.EE

.SS PMOVMSKB (WITH 64-BIT SOURCE OPERAND AND R64)  href="pmovmskb.html#pmovmskb--with-64-bit-source-operand-and-r64-"
class="anchor">¶

.EX
r64[0] := SRC[7];
r64[1] := SRC[15];
(* Repeat operation for bytes 2 through 6 *)
r64[7] := SRC[63];
r64[63:8] := ZERO_FILL;
.EE

.SS (V)PMOVMSKB (WITH 128-BIT SOURCE OPERAND AND R64) <a
href="pmovmskb.html#-v-pmovmskb--with-128-bit-source-operand-and-r64-"
class="anchor">¶

.EX
r64[0] := SRC[7];
r64[1] := SRC[15];
(* Repeat operation for bytes 2 through 14 *)
r64[15] := SRC[127];
r64[63:16] := ZERO_FILL;
.EE

.SS VPMOVMSKB (WITH 256-BIT SOURCE OPERAND AND R64)  href="pmovmskb.html#vpmovmskb--with-256-bit-source-operand-and-r64-"
class="anchor">¶

.EX
r64[0] := SRC[7];
r64[1] := SRC[15];
(* Repeat operation for bytes 2 through 31*)
r64[31] := SRC[255];
r64[63:32] := ZERO_FILL;
.EE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="pmovmskb.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
PMOVMSKB int _mm_movemask_pi8(__m64 a)

(V)PMOVMSKB int _mm_movemask_epi8 ( __m128i a)

VPMOVMSKB int _mm256_movemask_epi8 ( __m256i a)
.EE

.SH FLAGS AFFECTED
None.

.SH NUMERIC EXCEPTIONS
None.

.SH OTHER EXCEPTIONS
See Table 2-24, “Type 7 Class
Exception Conditions,” additionally:

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If VEX.vvvv ≠ 1111B.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
