'\" t
.nh
.TH "X86-CLRSSBSY" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
CLRSSBSY - CLEAR BUSY FLAG IN A SUPERVISOR SHADOW STACK TOKEN
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp / En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
F3 0F AE /6 CLRSSBSY m64	M	V/V	CET_SS	T{
Clear busy flag in supervisor shadow stack token reference by m64.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING  href="clrssbsy.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple Type\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
M	N/A	ModRM:r/m (r, w)	N/A	N/A	N/A
.TE

.SH DESCRIPTION
Clear busy flag in supervisor shadow stack token reference by m64.
Subsequent to marking the shadow stack as not busy the SSP is loaded
with value 0.

.SH OPERATION
.EX
IF (CR4.CET = 0)
    THEN #UD; FI;
IF (IA32_S_CET.SH_STK_EN = 0)
    THEN #UD; FI;
IF CPL > 0
    THEN GP(0); FI;
SSP_LA = Linear_Address(mem operand)
IF SSP_LA not aligned to 8 bytes
    THEN #GP(0); FI;
expected_token_value=SSP_LA|BUSY_BIT (*busybit-bitposition0-mustbeset*)
new_token_value = SSP_LA (* Clear the busy bit *)
IF shadow_stack_lock_cmpxchg8b(SSP_LA, new_token_value, expected_token_value) != expected_token_value
    invalid_token := 1; FI
(* Set the CF if invalid token was detected *)
RFLAGS.CF = (invalid_token == 1) ? 1 : 0;
RFLAGS.ZF,PF,AF,OF,SF := 0;
SSP := 0
.EE

.SH FLAGS AFFECTED
CF is set if an invalid token was detected, else it is cleared. ZF, PF,
AF, OF, and SF are cleared.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If the LOCK prefix is used.
	If CR4.CET = 0.
	IF IA32_S_CET.SH_STK_EN = 0.
#GP(0)	T{
If memory operand linear address not aligned to 8 bytes.
T}
	T{
If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.
T}
	T{
If destination is located in a non-writeable segment.
T}
	T{
If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.
T}
	If CPL is not 0.
#SS(0)	T{
If a memory operand effective address is outside the SS segment limit.
T}
#PF(fault-code)	If a page fault occurs.
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS  href="clrssbsy.html#real-address-mode-exceptions"
class="anchor">¶

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
The CLRSSBSY instruction is not recognized in real-address mode.
T}
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS  href="clrssbsy.html#virtual-8086-mode-exceptions"
class="anchor">¶

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
The CLRSSBSY instruction is not recognized in virtual-8086 mode.
T}
.TE

.SH COMPATIBILITY MODE EXCEPTIONS  href="clrssbsy.html#compatibility-mode-exceptions"
class="anchor">¶

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
Same exceptions as in protected mode.
T}
#GP(0)	T{
Same exceptions as in protected mode.
T}
#PF(fault-code)	If a page fault occurs.
.TE

.SH 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If the LOCK prefix is used.
	If CR4.CET = 0.
	IF IA32_S_CET.SH_STK_EN = 0.
#GP(0)	T{
If memory operand linear address not aligned to 8 bytes.
T}
	If CPL is not 0.
	T{
If the memory address is in a non-canonical form.
T}
	If token is invalid.
#SS(0)	T{
If a memory address referencing the SS segment is in a non-canonical form.
T}
#PF(fault-code)	If a page fault occurs.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
