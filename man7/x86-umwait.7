'\" t
.nh
.TH "X86-UMWAIT" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
UMWAIT - USER LEVEL MONITOR WAIT
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode / Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
F2 0F AE /6 UMWAIT r32, &lt;edx&gt;, &lt;eax&gt;	A	V/V	WAITPKG	T{
A hint that allows the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING1
.PP
.RS

.PP
1\&. The Mod field of the ModR/M byte must have value 11B.

.RE

.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	N/A	ModRM:r/m (r)	N/A	N/A	N/A
.TE

.SH DESCRIPTION
UMWAIT instructs the processor to enter an implementation-dependent
optimized state while monitoring a range of addresses. The optimized
state may be either a light-weight power/performance optimized state or
an improved power/performance optimized state. The selection between the
two states is governed by the explicit input register bit[0] source
operand.

.PP
UMWAIT is available when CPUID.7.0:ECX.WAITPKG[bit 5] is enumerated
as 1. UMWAIT may be executed at any privilege level. This instruction’s
operation is the same in non-64-bit modes and in 64-bit mode.

.PP
The input register contains information such as the preferred optimized
state the processor should enter as described in the following table.
Bits other than bit 0 are reserved and will result in #GP if nonzero.

.PP
The instruction wakes up when the time-stamp counter reaches or exceeds
the implicit EDX:EAX 64-bit input value (if the monitoring hardware did
not trigger beforehand).

.PP
Prior to executing the UMWAIT instruction, an operating system may
specify the maximum delay it allows the processor to suspend its
operation. It can do so by writing TSC-quanta value to the following
32bit MSR (IA32_UM-WAIT_CONTROL at MSR index E1H):
.IP \(bu 2
IA32_UMWAIT_CONTROL[31:2] — Determines the maximum time in
TSC-quanta that the processor can reside in either C0.1 or C0.2. A
zero value indicates no maximum time. The maximum time value is a
32-bit value where the upper 30 bits come from this field and the
lower two bits are zero.
.IP \(bu 2
IA32_UMWAIT_CONTROL[1] — Reserved.
.IP \(bu 2
IA32_UMWAIT_CONTROL[0] — C0.2 is not allowed by the OS. Value of
“1” means all C0.2 requests revert to C0.1.

.PP
If the processor that executed a UMWAIT instruction wakes due to the
expiration of the operating system timelimit, the instructions sets
RFLAGS.CF; otherwise, that flag is cleared.

.PP
The UMWAIT instruction causes a transactional abort when used inside a
transactional region.

.PP
The UMWAIT instruction operates with the UMONITOR instruction. The two
instructions allow the definition of an address at which to wait
(UMONITOR) and an implementation-dependent optimized operation to
perform while waiting (UMWAIT). The execution of UMWAIT is a hint to the
processor that it can enter an implementation-dependent-optimized state
while waiting for an event or a store operation to the address range
armed by UMONITOR. The UMWAIT instruction will not wait (will not enter
an implementation-dependent optimized state) if any of the

.PP
following instructions were executed before UMWAIT and after the most
recent execution of UMONITOR: IRET, MONITOR, SYSEXIT, SYSRET, and far
RET (the last if it is changing CPL).

.PP
The following additional events cause the processor to exit the
implementation-dependent optimized state: a store to the address range
armed by the UMONITOR instruction, an NMI or SMI, a debug exception, a
machine check exception, the BINIT# signal, the INIT# signal, and the
RESET# signal. Other implementation-dependent events may also cause the
processor to exit the implementation-dependent optimized state.

.PP
In addition, an external interrupt causes the processor to exit the
implementation-dependent optimized state regardless of whether
maskable-interrupts are inhibited (EFLAGS.IF =0).

.PP
Following exit from the implementation-dependent-optimized state,
control passes to the instruction after the UMWAIT instruction. A
pending interrupt that is not masked (including an NMI or an SMI) may be
delivered before execution of that instruction.

.PP
Unlike the HLT instruction, the UMWAIT instruction does not restart at
the UMWAIT instruction following the handling of an SMI.

.PP
If the preceding UMONITOR instruction did not successfully arm an
address range or if UMONITOR was not executed prior to executing UMWAIT
and following the most recent execution of the legacy MONITOR
instruction (UMWAIT does not interoperate with MONITOR), then the
processor will not enter an optimized state. Execution will continue to
the instruction following UMWAIT.

.PP
A store to the address range armed by the UMONITOR instruction will
cause the processor to exit UMWAIT if either the store was originated by
other processor agents or the store was originated by a non-processor
agent.

.SH OPERATION
.EX
os_deadline := TSC+(IA32_UMWAIT_CONTROL[31:2]<<2)
instr_deadline := UINT64(EDX:EAX)
IF os_deadline < instr_deadline:
    deadline := os_deadline
    using_os_deadline := 1
ELSE:
    deadline := instr_deadline
    using_os_deadline := 0
WHILE monitor hardware armed AND TSC < deadline:
    implementation_dependent_optimized_state(Source register, deadline, IA32_UMWAIT_CONTROL[0] )
IF using_os_deadline AND TSC ≥ deadline:
    RFLAGS.CF := 1
ELSE:
    RFLAGS.CF := 0
RFLAGS.AF,PF,SF,ZF,OF := 0
.EE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="umwait.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
UMWAIT uint8_t _umwait(uint32_t control, uint64_t counter);
.EE

.SH NUMERIC EXCEPTIONS
None.

.SH EXCEPTIONS (ALL OPERATING MODES)  href="umwait.html#exceptions--all-operating-modes-"
class="anchor">¶

.PP
#GP(0) If src[31:1] != 0.

.PP
If CR4.TSD = 1 and CPL != 0.

.PP
#UD If CPUID.7.0:ECX.WAITPKG[bit 5]=0.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
