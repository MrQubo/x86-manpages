'\" t
.nh
.TH "X86-VCVTTSS2USI" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
VCVTTSS2USI - CONVERT WITH TRUNCATION SCALAR SINGLE PRECISION FLOATING-POINT VALUE TOUNSIGNED INTEGER
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 Bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
EVEX.LLIG.F3.0F.W0 78 /r VCVTTSS2USI r32, xmm1/m32{sae}
T}	A	V/V	AVX512F	T{
Convert one single precision floating-point value from xmm1/m32 to one unsigned doubleword integer in r32 using truncation.
T}
T{
EVEX.LLIG.F3.0F.W1 78 /r VCVTTSS2USI r64, xmm1/m32{sae}
T}	A	V/N.E.1	AVX512F	T{
Convert one single precision floating-point value from xmm1/m32 to one unsigned quadword integer in r64 using truncation.
T}
.TE

.PP
.RS

.PP
1\&. For this specific instruction, EVEX.W in non-64 bit is ignored;
the instruction behaves as if the W0 version is used.

.RE

.SH INSTRUCTION OPERAND ENCODING  href="vcvttss2usi.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple Type\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	Tuple1 Fixed	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
.TE

.SS DESCRIPTION
Converts with truncation a single precision floating-point value in the
source operand (the second operand) to an unsigned doubleword integer
(or unsigned quadword integer if operand size is 64 bits) in the
destination operand (the first operand). The source operand can be an
XMM register or a memory location. The destination operand is a
general-purpose register. When the source operand is an XMM register,
the single precision floating-point value is contained in the low
doubleword of the register.

.PP
When a conversion is inexact, a truncated (round toward zero) value is
returned. If a converted result cannot be represented in the destination
format, the floating-point invalid exception is raised, and if this
exception is masked, the integer value 2w – 1 is returned,
where w represents the number of bits in the destination format.

.PP
EVEX.W1 version: promotes the instruction to produce 64-bit data in
64-bit mode.

.PP
Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions
will #UD.

.SS OPERATION
.SS VCVTTSS2USI (EVEX ENCODED VERSION)  href="vcvttss2usi.html#vcvttss2usi--evex-encoded-version-"
class="anchor">¶

.EX
IF 64-bit Mode and OperandSize = 64
THEN
    DEST[63:0] := Convert_Single_Precision_Floating_Point_To_UInteger_Truncate(SRC[31:0]);
ELSE
    DEST[31:0] := Convert_Single_Precision_Floating_Point_To_UInteger_Truncate(SRC[31:0]);
FI;
.EE

.SS INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="vcvttss2usi.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
VCVTTSS2USI unsigned int _mm_cvttss_u32( __m128 a);

VCVTTSS2USI unsigned int _mm_cvtt_roundss_u32( __m128 a, int sae);

VCVTTSS2USI unsigned __int64 _mm_cvttss_u64( __m128 a);

VCVTTSS2USI unsigned __int64 _mm_cvtt_roundss_u64( __m128 a, int sae);
.EE

.SS SIMD FLOATING-POINT EXCEPTIONS  href="vcvttss2usi.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
Invalid, Precision.

.SS OTHER EXCEPTIONS
EVEX-encoded instructions, see Table
2-48, “Type E3NF Class Exception Conditions.”

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
