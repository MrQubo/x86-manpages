'\" t
.nh
.TH "X86-V4FMADDSS-V4FNMADDSS" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
V4FMADDSS-V4FNMADDSS - SCALAR SINGLE PRECISION FLOATING-POINT FUSED MULTIPLY-ADD(4-ITERATIONS)
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
EVEX.LLIG.F2.0F38.W0 9B /r V4FMADDSS xmm1{k1}{z}, xmm2+3, m128
T}	A	V/V	AVX512_4FMAPS	T{
Multiply scalar single-precision floating-point values from source register block indicated by xmm2 by values from m128 and accumulate the result in xmm1.
T}
T{
EVEX.LLIG.F2.0F38.W0 AB /r V4FNMADDSS xmm1{k1}{z}, xmm2+3, m128
T}	A	V/V	AVX512_4FMAPS	T{
Multiply and negate scalar single-precision floating-point values from source register block indicated by xmm2 by values from m128 and accumulate the result in xmm1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING  href="./v4fmaddss:v4fnmaddss.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En Tuple Operand 1 Operand 2 Operand 3 Operand 4\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP
A Tuple1_4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) N/A					
.TE

.SS DESCRIPTION
This instruction computes 4 sequential scalar fused single-precision
floating-point multiply-add instructions with a sequentially selected
memory operand in each of the four steps.

.PP
In the above box, the notation of “+3” is used to denote that the
instruction accesses 4 source registers based that operand; sources are
consecutive, start in a multiple of 4 boundary, and contain the encoded
register operand.

.PP
This instruction supports memory fault suppression. The entire memory
operand is loaded if the least significant mask bit is set to 1 or if a
“no masking” encoding is used.

.PP
The tuple type Tuple1_4X implies that four 32-bit elements (16 bytes)
are referenced by the memory operation portion of this instruction.

.PP
Rounding is performed at every FMA boundary. Exceptions are also taken
sequentially. Pre- and post-computational exceptions of the first FMA
take priority over the pre- and post-computational exceptions of the
second FMA, etc.

.SS OPERATION
.EX
src_reg_id is the 5 bit index of the vector register specified in the instruction as the src1 register.
define NFMA_SS(vl, dest, k1, msrc, regs_loaded, src_base, posneg):
    tmpdest := dest
    // reg[] is an array representing the SIMD register file.
    IF k1[0] or *no writemask*:
        FOR j := 0 to regs_loaded - 1:
            IF posneg = 0:
                tmpdest.single[0] := RoundFPControl_MXCSR(tmpdest.single[0] - reg[src_base + j ].single[0] * msrc.single[j])
            ELSE:
                tmpdest.single[0] := RoundFPControl_MXCSR(tmpdest.single[0] + reg[src_base + j ].single[0] * msrc.single[j])
    ELSE IF *zeroing*:
        tmpdest.single[0] := 0
    dest := tmpdst
    dest[MAX_VL-1:VL] := 0
.EE

.SS V4FMADDSS AND V4FNMADDSS DEST{K1}, SRC1, MSRC (AVX512) <a
href="./v4fmaddss:v4fnmaddss.html#v4fmaddss-and-v4fnmaddss-dest-k1---src1--msrc--avx512-"
class="anchor">¶

.EX
VL = 128
regs_loaded := 4
src_base := src_reg_id & ~3 // for src1 operand
posneg := 0 if negative form, 1 otherwise
NFMA_SS(vl, dest, k1, msrc, regs_loaded, src_base, posneg)
.EE

.SS INTEL C/C++ COMPILER INTRINSIC EQUIVALENT <a
href="./v4fmaddss:v4fnmaddss.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
V4FMADDSS __m128 _mm_4fmadd_ss(__m128, __m128x4, __m128 *);

V4FMADDSS __m128 _mm_mask_4fmadd_ss(__m128, __mmask8, __m128x4, __m128 *);

V4FMADDSS __m128 _mm_maskz_4fmadd_ss(__mmask8, __m128, __m128x4, __m128 *);

V4FNMADDSS __m128 _mm_4fnmadd_ss(__m128, __m128x4, __m128 *);

V4FNMADDSS __m128 _mm_mask_4fnmadd_ss(__m128, __mmask8, __m128x4, __m128 *);

V4FNMADDSS __m128 _mm_maskz_4fnmadd_ss(__mmask8, __m128, __m128x4, __m128 *);
.EE

.SS SIMD FLOATING-POINT EXCEPTIONS  href="./v4fmaddss:v4fnmaddss.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
Overflow, Underflow, Invalid, Precision, Denormal.

.SS OTHER EXCEPTIONS  href="./v4fmaddss:v4fnmaddss.html#other-exceptions"
class="anchor">¶

.PP
See Type E2; additionally:

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
If the EVEX broadcast bit is set to 1.
T}
#UD	If the MODRM.mod = 0b11.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
