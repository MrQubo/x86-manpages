'\" t
.nh
.TH "X86-EMODPR" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
EMODPR - RESTRICT THE PERMISSIONS OF AN EPC PAGE
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
EAX = 0EH ENCLS[EMODPR]	IR	V/V	SGX2	T{
This leaf function restricts the access rights associated with a EPC page in an initialized enclave.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP
Op/En	EAX		RBX	RCX
IR	EMODPR (In)	Return Error Code (Out)	Address of a SECINFO (In)	T{
Address of the destination EPC page (In)
T}
.TE

.SS DESCRIPTION
This leaf function restricts the access rights associated with an EPC
page in an initialized enclave. THE RWX bits of the SECINFO parameter
are treated as a permissions mask; supplying a value that does not
restrict the page permissions will have no effect. This instruction can
only be executed when current privilege level is 0.

.PP
RBX contains the effective address of a SECINFO structure while RCX
contains the effective address of an EPC page. The table below provides
additional information on the memory parameter of the EMODPR leaf
function.

.SH EMODPR MEMORY PARAMETER SEMANTICS  href="emodpr.html#emodpr-memory-parameter-semantics"
class="anchor">¶

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
SECINFO	EPCPAGE
T{
Read access permitted by Non Enclave
T}	T{
Read/Write access permitted by Enclave
T}
.TE

.PP
The instruction faults if any of the following:

.SH EMODPR FAULTING CONDITIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
T{
The operands are not properly aligned.
T}	T{
If unsupported security attributes are set.
T}
T{
The Enclave is not initialized.
T}	T{
SECS is locked by another thread.
T}
T{
The EPC page is locked by another thread.
T}	T{
RCX does not contain an effective address of an EPC page in the running enclave.
T}
The EPC page is not valid.	
.TE

.PP
The error codes are:

.SS CONCURRENCY RESTRICTIONS
.SS OPERATION
.SH TEMP VARIABLES IN EMODPR OPERATIONAL FLOW  href="emodpr.html#temp-variables-in-emodpr-operational-flow"
class="anchor">¶

.TS
allbox;
l l l l 
l l l l .
\fBName\fP	\fBType\fP	\fBSize (bits)\fP	\fBDescription\fP
TMP_SECS	Effective Address	32/64	T{
Physical address of SECS to which EPC operand belongs.
T}
SCRATCH_SECINFO	SECINFO	512	T{
Scratch storage for holding the contents of DS:RBX.
T}
.TE

.PP
IF (DS:RBX is not 64Byte Aligned)

.PP
THEN #GP(0); FI;

.PP
IF (DS:RCX is not 4KByte Aligned)

.PP
THEN #GP(0); FI;

.PP
IF (DS:RCX does not resolve within an EPC)

.PP
THEN #PF(DS:RCX); FI;

.PP
SCRATCH_SECINFO := DS:RBX;

.PP
(* Check for misconfigured SECINFO flags*)

.PP
IF ( (SCRATCH_SECINFO reserved fields are not zero ) or

.PP
(SCRATCH_SECINFO.FLAGS.R is 0 and SCRATCH_SECINFO.FLAGS.W is not 0) )

.PP
THEN #GP(0); FI;

.PP
(* Check concurrency with SGX1 or SGX2 instructions on the EPC page *)

.PP
IF (SGX1 or other SGX2 instructions accessing EPC page)

.PP
THEN #GP(0); FI;

.PP
IF (EPCM(DS:RCX).VALID is 0 )

.PP
THEN #PF(DS:RCX); FI;

.PP
(* Check the EPC page for concurrency *)

.PP
IF (EPC page in use by another SGX2 instruction)

.PP
THEN

.PP
RFLAGS.ZF := 1;

.PP
RAX := SGX_EPC_PAGE_CONFLICT;

.PP
GOTO DONE;

.PP
FI;

.PP
IF (EPCM(DS:RCX).PENDING is not 0 or (EPCM(DS:RCX).MODIFIED is not 0) )

.PP
THEN

.PP
RFLAGS.ZF := 1;

.PP
RAX := SGX_PAGE_NOT_MODIFIABLE;

.PP
GOTO DONE;

.PP
FI;

.PP
IF (EPCM(DS:RCX).PT is not PT_REG)

.PP
THEN #PF(DS:RCX); FI;

.PP
TMP_SECS := GET_SECS_ADDRESS

.PP
IF (TMP_SECS.ATTRIBUTES.INIT = 0)

.PP
THEN #GP(0); FI;

.PP
(* Set the PR bit to indicate that permission restriction is in
progress *)

.PP
EPCM(DS:RCX).PR := 1;

.PP
(* Update EPCM permissions *)

.PP
EPCM(DS:RCX).R := EPCM(DS:RCX).R & SCRATCH_SECINFO.FLAGS.R;

.PP
EPCM(DS:RCX).W := EPCM(DS:RCX).W & SCRATCH_SECINFO.FLAGS.W;

.PP
EPCM(DS:RCX).X := EPCM(DS:RCX).X & SCRATCH_SECINFO.FLAGS.X;

.PP
RFLAGS.ZF := 0;

.PP
RAX := 0;

.PP
DONE:

.PP
RFLAGS.CF,PF,AF,OF,SF := 0;

.SS FLAGS AFFECTED
Sets ZF if page is not modifiable or if other SGX2 instructions are
executing concurrently, otherwise cleared. Clears CF, PF, AF, OF, SF.

.SS PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If a memory operand effective address is outside the DS segment limit.
T}
	T{
If a memory operand is not properly aligned.
T}
	If a memory operand is locked.
#PF(error	T{
code) If a page fault occurs in accessing memory operands.
T}
	T{
If a memory operand is not an EPC page.
T}
.TE

.SS 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If a memory operand is non-canonical form.
T}
	T{
If a memory operand is not properly aligned.
T}
	If a memory operand is locked.
#PF(error	T{
code) If a page fault occurs in accessing memory operands.
T}
	T{
If a memory operand is not an EPC page.
T}
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
