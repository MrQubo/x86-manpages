'\" t
.nh
.TH "X86-FXSAVE" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
FXSAVE - SAVE X87 FPU, MMX TECHNOLOGY, AND SSE STATE
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64-Bit Mode\fP	\fBCompat/Leg Mode\fP	\fBDescription\fP
NP 0F AE /0 FXSAVE m512byte	M	Valid	Valid	T{
Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte.
T}
T{
NP REX.W + 0F AE /0 FXSAVE64 m512byte
T}	M	Valid	N.E.	T{
Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
M	ModRM:r/m (w)	N/A	N/A	N/A
.TE

.SH DESCRIPTION
Saves the current state of the x87 FPU, MMX technology, XMM, and MXCSR
registers to a 512-byte memory location specified in the destination
operand. The content layout of the 512 byte region depends on whether
the processor is operating in non-64-bit operating modes or 64-bit
sub-mode of IA-32e mode.

.PP
Bytes 464:511 are available to software use. The processor does not
write to bytes 464:511 of an FXSAVE area.

.PP
The operation of FXSAVE in non-64-bit modes is described first.

.SH NON-64-BIT MODE OPERATION
Table 3-43
\[la]fxsave.html#tbl\-3\-43\[ra] shows the layout of the state
information in memory when the processor is operating in legacy modes.

.PP
The destination operand contains the first byte of the memory image, and
it must be aligned on a 16-byte boundary. A misaligned destination
operand will result in a general-protection (#GP) exception being
generated (or in some cases, an alignment check exception [#AC]).

.PP
The FXSAVE instruction is used when an operating system needs to perform
a context switch or when an exception handler needs to save and examine
the current state of the x87 FPU, MMX technology, and/or XMM and MXCSR
registers.

.PP
The fields in Table 3-43
\[la]fxsave.html#tbl\-3\-43\[ra] are defined in Table
3-44
\[la]fxsave.html#tbl\-3\-44\[ra]\&.

.PP
The FXSAVE instruction saves an abridged version of the x87 FPU tag word
in the FTW field (unlike the FSAVE instruction, which saves the complete
tag word). The tag information is saved in physical register order (R0
through R7), rather than in top-of-stack (TOS) order. With the FXSAVE
instruction, however, only a single bit (1 for valid or 0 for empty) is
saved for each tag. For example, assume that the tag word is currently
set as follows:

.PP
R7 R6 R5 R4 R3 R2 R1 R0

.PP
11 xx xx xx 11 11 11 11

.PP
Here, 11B indicates empty stack elements and “xx” indicates valid (00B),
zero (01B), or special (10B).

.PP
For this example, the FXSAVE instruction saves only the following 8 bits
of information:

.PP
R7 R6 R5 R4 R3 R2 R1 R0

.PP
01110000

.PP
Here, a 1 is saved for any valid, zero, or special tag, and a 0 is saved
for any empty tag.

.PP
The operation of the FXSAVE instruction differs from that of the FSAVE
instruction, the as follows:
.IP \(bu 2
FXSAVE instruction does not check for pending unmasked
floating-point exceptions. (The FXSAVE operation in this regard is
similar to the operation of the FNSAVE instruction).
.IP \(bu 2
After the FXSAVE instruction has saved the state of the x87 FPU, MMX
technology, XMM, and MXCSR registers, the processor retains the
contents of the registers. Because of this behavior, the FXSAVE
instruction cannot be used by an application program to pass a
“clean” x87 FPU state to a procedure, since it retains the current
state. To clean the x87 FPU state, an application must explicitly
execute an FINIT instruction after an FXSAVE instruction to
reinitialize the x87 FPU state.
.IP \(bu 2
The format of the memory image saved with the FXSAVE instruction is
the same regardless of the current addressing mode (32-bit or
16-bit) and operating mode (protected, real address, or system
management). This behavior differs from the FSAVE instructions,
where the memory image format is different depending on the
addressing mode and operating mode. Because of the different image
formats, the memory image saved with the FXSAVE instruction cannot
be restored correctly with the FRSTOR instruction, and likewise the
state saved with the FSAVE instruction cannot be restored correctly
with the FXRSTOR instruction.

.PP
The FSAVE format for FTW can be recreated from the FTW valid bits and
the stored 80-bit floating-point data (assuming the stored data was not
the contents of MMX technology registers) using Table
3-45
\[la]fxsave.html#tbl\-3\-45\[ra]\&.

.PP
The J-bit is defined to be the 1-bit binary integer to the left of the
decimal place in the significand. The M-bit is defined to be the most
significant bit of the fractional portion of the significand (i.e., the
bit immediately to the right of the decimal place).

.PP
When the M-bit is the most significant bit of the fractional portion of
the significand, it must be 0 if the fraction is all 0’s.

.SH IA-32E MODE OPERATION
In compatibility sub-mode of IA-32e mode, legacy SSE registers, XMM0
through XMM7, are saved according to the legacy FXSAVE map. In 64-bit
mode, all of the SSE registers, XMM0 through XMM15, are saved.
Additionally, there are two different layouts of the FXSAVE map in
64-bit mode, corresponding to FXSAVE64 (which requires REX.W=1) and
FXSAVE (REX.W=0). In the FXSAVE64 map (Table
3-46
\[la]fxsave.html#tbl\-3\-46\[ra]), the FPU IP and FPU DP pointers are 64-bit
wide. In the FXSAVE map for 64-bit mode (Table
3-47
\[la]fxsave.html#tbl\-3\-47\[ra]), the FPU IP and FPU DP pointers are
32-bits.

.SH OPERATION
.EX
IF 64-Bit Mode
    THEN
        IF REX.W = 1
            THEN
                DEST := Save64BitPromotedFxsave(x87 FPU, MMX, XMM15-XMM0,
                MXCSR);
            ELSE
                DEST := Save64BitDefaultFxsave(x87 FPU, MMX, XMM15-XMM0, MXCSR);
        FI;
    ELSE
        DEST := SaveLegacyFxsave(x87 FPU, MMX, XMM7-XMM0, MXCSR);
FI;
.EE

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.
T}
	T{
If a memory operand is not aligned on a 16-byte boundary, regardless of segment. (See the description of the alignment check exception [#AC] below.)
T}
#SS(0)	T{
For an illegal address in the SS segment.
T}
#PF(fault-code)	For a page fault.
#NM	If CR0.TS[bit 3] = 1.
	If CR0.EM[bit 2] = 1.
#UD	If CPUID.01H:EDX.FXSR[bit 24] = 0.
#UD	If the LOCK prefix is used.
#AC	T{
If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 16-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an alignment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).
T}
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP	T{
If a memory operand is not aligned on a 16-byte boundary, regardless of segment.
T}
	T{
If any part of the operand lies outside the effective address space from 0 to FFFFH.
T}
#NM	If CR0.TS[bit 3] = 1.
	If CR0.EM[bit 2] = 1.
#UD	If CPUID.01H:EDX.FXSR[bit 24] = 0.
	If the LOCK prefix is used.
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS
Same exceptions as in real address mode.

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#PF(fault-code)	For a page fault.
#AC	T{
For unaligned memory reference.
T}
#UD	If the LOCK prefix is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#SS(0)	T{
If a memory address referencing the SS segment is in a non-canonical form.
T}
#GP(0)	T{
If the memory address is in a non-canonical form.
T}
	T{
If memory operand is not aligned on a 16-byte boundary, regardless of segment.
T}
#PF(fault-code)	For a page fault.
#NM	If CR0.TS[bit 3] = 1.
	If CR0.EM[bit 2] = 1.
#UD	If CPUID.01H:EDX.FXSR[bit 24] = 0.
	If the LOCK prefix is used.
#AC	T{
If this exception is disabled a general protection exception (#GP) is signaled if the memory operand is not aligned on a 16-byte boundary, as described above. If the alignment check exception (#AC) is enabled (and the CPL is 3), signaling of #AC is not guaranteed and may vary with implementation, as follows. In all implementations where #AC is not signaled, a general protection exception is signaled in its place. In addition, the width of the alignment check may also vary with implementation. For instance, for a given implementation, an alignment check exception might be signaled for a 2-byte misalignment, whereas a general protection exception might be signaled for all other misalignments (4-, 8-, or 16-byte misalignments).
T}
.TE

.SH IMPLEMENTATION NOTE
The order in which the processor signals general-protection (#GP) and
page-fault (#PF) exceptions when they both occur on an instruction
boundary is given in Table
5-2
\[la]./vfmadd132ph:vfnmadd132ph:vfmadd213ph:vfnmadd213ph:vfmadd231ph:vfnmadd231ph.html#tbl\-5\-2\[ra]
in the Intel® 64 and IA-32 Architectures Software Developer’s
Manual, Volume 3B. This order vary for FXSAVE for different processor
implementations.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
