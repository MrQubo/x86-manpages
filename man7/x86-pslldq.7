'\" t
.nh
.TH "X86-PSLLDQ" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
PSLLDQ - SHIFT DOUBLE QUADWORD LEFT LOGICAL
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
66 0F 73 /7 ib PSLLDQ xmm1, imm8
T}	A	V/V	SSE2	T{
Shift xmm1 left by imm8 bytes while shifting in 0s.
T}
T{
VEX.128.66.0F.WIG 73 /7 ib VPSLLDQ xmm1, xmm2, imm8
T}	B	V/V	AVX	T{
Shift xmm2 left by imm8 bytes while shifting in 0s and store result in xmm1.
T}
T{
VEX.256.66.0F.WIG 73 /7 ib VPSLLDQ ymm1, ymm2, imm8
T}	B	V/V	AVX2	T{
Shift ymm2 left by imm8 bytes while shifting in 0s and store result in ymm1.
T}
T{
EVEX.128.66.0F.WIG 73 /7 ib VPSLLDQ xmm1,xmm2/ m128, imm8
T}	C	V/V	AVX512VL AVX512BW	T{
Shift xmm2/m128 left by imm8 bytes while shifting in 0s and store result in xmm1.
T}
T{
EVEX.256.66.0F.WIG 73 /7 ib VPSLLDQ ymm1, ymm2/m256, imm8
T}	C	V/V	AVX512VL AVX512BW	T{
Shift ymm2/m256 left by imm8 bytes while shifting in 0s and store result in ymm1.
T}
T{
EVEX.512.66.0F.WIG 73 /7 ib VPSLLDQ zmm1, zmm2/m512, imm8
T}	C	V/V	AVX512BW	T{
Shift zmm2/m512 left by imm8 bytes while shifting in 0s and store result in zmm1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple Type\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	N/A	ModRM:r/m (r, w)	imm8	N/A	N/A
B	N/A	VEX.vvvv (w)	ModRM:r/m (r)	imm8	N/A
C	Full Mem	EVEX.vvvv (w)	ModRM:r/m (r)	imm8	N/A
.TE

.SH DESCRIPTION
Shifts the destination operand (first operand) to the left by the number
of bytes specified in the count operand (second operand). The empty
low-order bytes are cleared (set to all 0s). If the value specified by
the count operand is greater than 15, the destination operand is set to
all 0s. The count operand is an 8-bit immediate.

.PP
128-bit Legacy SSE version: The source and destination operands are the
same. Bits (MAXVL-1:128) of the corresponding YMM destination register
remain unchanged.

.PP
VEX.128 encoded version: The source and destination operands are XMM
registers. Bits (MAXVL-1:128) of the destination YMM register are
zeroed.

.PP
VEX.256 encoded version: The source operand is YMM register. The
destination operand is an YMM register. Bits (MAXVL-1:256) of the
corresponding ZMM register are zeroed. The count operand applies to both
the low and high 128-bit lanes.

.PP
EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a
512/256/128-bit memory location. The destination operand is a
ZMM/YMM/XMM register. The count operand applies to each 128-bit lanes.

.SH OPERATION
.SS VPSLLDQ (EVEX.U1.512 ENCODED VERSION)  href="pslldq.html#vpslldq--evex-u1-512-encoded-version-"
class="anchor">¶

.EX
TEMP := COUNT
IF (TEMP > 15) THEN TEMP := 16; FI
DEST[127:0] := SRC[127:0] << (TEMP * 8)
DEST[255:128] := SRC[255:128] << (TEMP * 8)
DEST[383:256] := SRC[383:256] << (TEMP * 8)
DEST[511:384] := SRC[511:384] << (TEMP * 8)
DEST[MAXVL-1:512] := 0
.EE

.SS VPSLLDQ (VEX.256 AND EVEX.256 ENCODED VERSION)  href="pslldq.html#vpslldq--vex-256-and-evex-256-encoded-version-"
class="anchor">¶

.EX
TEMP := COUNT
IF (TEMP > 15) THEN TEMP := 16; FI
DEST[127:0] := SRC[127:0] << (TEMP * 8)
DEST[255:128] := SRC[255:128] << (TEMP * 8)
DEST[MAXVL-1:256] := 0
.EE

.SS VPSLLDQ (VEX.128 AND EVEX.128 ENCODED VERSION)  href="pslldq.html#vpslldq--vex-128-and-evex-128-encoded-version-"
class="anchor">¶

.EX
TEMP := COUNT
IF (TEMP > 15) THEN TEMP := 16; FI
DEST := SRC << (TEMP * 8)
DEST[MAXVL-1:128] := 0
.EE

.SS PSLLDQ(128-BIT LEGACY SSE VERSION)  href="pslldq.html#pslldq-128-bit-legacy-sse-version-"
class="anchor">¶

.EX
TEMP := COUNT
IF (TEMP > 15) THEN TEMP := 16; FI
DEST := DEST << (TEMP * 8)
DEST[MAXVL-1:128] (Unmodified)
.EE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="pslldq.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
(V)PSLLDQ __m128i _mm_slli_si128 ( __m128i a, int imm)

VPSLLDQ __m256i _mm256_slli_si256 ( __m256i a, const int imm)

VPSLLDQ __m512i _mm512_bslli_epi128 ( __m512i a, const int imm)
.EE

.SH FLAGS AFFECTED
None.

.SH NUMERIC EXCEPTIONS
None.

.SH OTHER EXCEPTIONS
Non-EVEX-encoded instruction, see Table
2-24, “Type 7 Class Exception Conditions.”

.PP
EVEX-encoded instruction, see Exceptions Type E4NF.nb in
Table 2-50, “Type E4NF Class Exception
Conditions.”

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
