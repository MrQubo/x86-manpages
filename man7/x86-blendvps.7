'\" t
.nh
.TH "X86-BLENDVPS" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
BLENDVPS - VARIABLE BLEND PACKED SINGLE PRECISION FLOATING-POINT VALUES
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32-bit Mode\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
66 0F 38 14 /r BLENDVPS xmm1, xmm2/m128, &lt;XMM0&gt;
T}	RM0	V/V	SSE4_1	T{
Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1.
T}
T{
VEX.128.66.0F3A.W0 4A /r /is4 VBLENDVPS xmm1, xmm2, xmm3/m128, xmm4
T}	RVMR	V/V	AVX	T{
Conditionally copy single precision floating-point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the specified mask operand, xmm4.
T}
T{
VEX.256.66.0F3A.W0 4A /r /is4 VBLENDVPS ymm1, ymm2, ymm3/m256, ymm4
T}	RVMR	V/V	AVX	T{
Conditionally copy single precision floating-point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the specified mask register, ymm4.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING  href="blendvps.html#instruction-operand-encoding"
class="anchor">¶

.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
RM0	ModRM:reg (r, w)	ModRM:r/m (r)	implicit XMM0	N/A
RVMR	ModRM:reg (w)	VEX.vvvv (r)	ModRM:r/m (r)	imm8[7:4]
.TE

.SH DESCRIPTION
Conditionally copy each dword data element of single precision
floating-point value from the second source operand and the first source
operand depending on mask bits defined in the mask register operand. The
mask bits are the most significant bit in each dword element of the mask
register.

.PP
Each quadword element of the destination operand is copied from:
.IP \(bu 2
the corresponding dword element in the second source operand, if a
mask bit is “1”; or
.IP \(bu 2
the corresponding dword element in the first source operand, if a
mask bit is “0”.

.PP
The register assignment of the implicit mask operand for BLENDVPS is
defined to be the architectural register XMM0.

.PP
128-bit Legacy SSE version: The first source operand and the destination
operand is the same. Bits (MAXVL-1:128) of the corresponding YMM
destination register remain unchanged. The mask register operand is
implicitly defined to be the architectural register XMM0. An attempt to
execute BLENDVPS with a VEX prefix will cause #UD.

.PP
VEX.128 encoded version: The first source operand and the destination
operand are XMM registers. The second source operand is an XMM register
or 128-bit memory location. The mask operand is the third source
register, and encoded in bits[7:4] of the immediate byte(imm8). The
bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored.
The upper bits (MAXVL-1:128) of the corresponding YMM register
(destination register) are zeroed. VEX.W must be 0, otherwise, the
instruction will #UD.

.PP
VEX.256 encoded version: The first source operand and destination
operand are YMM registers. The second source operand can be a YMM
register or a 256-bit memory location. The mask operand is the third
source register, and encoded in bits[7:4] of the immediate byte(imm8).
The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
ignored. VEX.W must be 0, otherwise, the instruction will #UD.

.PP
VBLENDVPS permits the mask to be any XMM or YMM register. In contrast,
BLENDVPS treats XMM0 implicitly as the mask and do not support
non-destructive destination operation.

.SH OPERATION
.SS BLENDVPS (128-BIT LEGACY SSE VERSION)  href="blendvps.html#blendvps--128-bit-legacy-sse-version-"
class="anchor">¶

.EX
MASK := XMM0
IF (MASK[31] = 0) THEN DEST[31:0] := DEST[31:0]
    ELSE DEST [31:0] := SRC[31:0] FI
IF (MASK[63] = 0) THEN DEST[63:32] := DEST[63:32]
    ELSE DEST [63:32] := SRC[63:32] FI
IF (MASK[95] = 0) THEN DEST[95:64] := DEST[95:64]
    ELSE DEST [95:64] := SRC[95:64] FI
IF (MASK[127] = 0) THEN DEST[127:96] := DEST[127:96]
    ELSE DEST [127:96] := SRC[127:96] FI
DEST[MAXVL-1:128] (Unmodified)
.EE

.SS VBLENDVPS (VEX.128 ENCODED VERSION)  href="blendvps.html#vblendvps--vex-128-encoded-version-"
class="anchor">¶

.EX
MASK := SRC3
IF (MASK[31] = 0) THEN DEST[31:0] := SRC1[31:0]
    ELSE DEST [31:0] := SRC2[31:0] FI
IF (MASK[63] = 0) THEN DEST[63:32] := SRC1[63:32]
    ELSE DEST [63:32] := SRC2[63:32] FI
IF (MASK[95] = 0) THEN DEST[95:64] := SRC1[95:64]
    ELSE DEST [95:64] := SRC2[95:64] FI
IF (MASK[127] = 0) THEN DEST[127:96] := SRC1[127:96]
    ELSE DEST [127:96] := SRC2[127:96] FI
DEST[MAXVL-1:128] := 0
.EE

.SS VBLENDVPS (VEX.256 ENCODED VERSION)  href="blendvps.html#vblendvps--vex-256-encoded-version-"
class="anchor">¶

.EX
MASK := SRC3
IF (MASK[31] = 0) THEN DEST[31:0] := SRC1[31:0]
    ELSE DEST [31:0] := SRC2[31:0] FI
IF (MASK[63] = 0) THEN DEST[63:32] := SRC1[63:32]
    ELSE DEST [63:32] := SRC2[63:32] FI
IF (MASK[95] = 0) THEN DEST[95:64] := SRC1[95:64]
    ELSE DEST [95:64] := SRC2[95:64] FI
IF (MASK[127] = 0) THEN DEST[127:96] := SRC1[127:96]
    ELSE DEST [127:96] := SRC2[127:96] FI
IF (MASK[159] = 0) THEN DEST[159:128] := SRC1[159:128]
    ELSE DEST [159:128] := SRC2[159:128] FI
IF (MASK[191] = 0) THEN DEST[191:160] := SRC1[191:160]
    ELSE DEST [191:160] := SRC2[191:160] FI
IF (MASK[223] = 0) THEN DEST[223:192] := SRC1[223:192]
    ELSE DEST [223:192] := SRC2[223:192] FI
IF (MASK[255] = 0) THEN DEST[255:224] := SRC1[255:224]
    ELSE DEST [255:224] := SRC2[255:224] FI
.EE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT  href="blendvps.html#intel-c-c++-compiler-intrinsic-equivalent"
class="anchor">¶

.EX
BLENDVPS __m128 _mm_blendv_ps(__m128 v1, __m128 v2, __m128 v3);

VBLENDVPS __m128 _mm_blendv_ps (__m128 a, __m128 b, __m128 mask);

VBLENDVPS __m256 _mm256_blendv_ps (__m256 a, __m256 b, __m256 mask);
.EE

.SH SIMD FLOATING-POINT EXCEPTIONS  href="blendvps.html#simd-floating-point-exceptions"
class="anchor">¶

.PP
None.

.SH OTHER EXCEPTIONS
See Table 2-21, “Type 4 Class
Exception Conditions,” additionally:

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If VEX.W = 1.
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
