'\" t
.nh
.TH "X86-EEXTEND" "7" "December 2023" "Intel" "Intel x86-64 ISA Manual"
.SH NAME
EEXTEND - EXTEND UNINITIALIZED ENCLAVE MEASUREMENT BY 256 BYTES
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
EAX = 06H ENCLS[EEXTEND]	IR	V/V	SGX1	T{
This leaf function measures 256 bytes of an uninitialized enclave page.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l 
l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP
Op/En	EAX	EBX	RCX
IR	EEXTEND (In)	T{
Effective address of the SECS of the data chunk (In)
T}	T{
Effective address of a 256-byte chunk in the EPC (In)
T}
.TE

.SS DESCRIPTION
This leaf function updates the MRENCLAVE measurement register of an SECS
with the measurement of an EXTEND string compromising of “EEXTEND” ||
ENCLAVEOFFSET || PADDING || 256 bytes of the enclave page. This
instruction can only be executed when current privilege level is 0 and
the enclave is uninitialized.

.PP
RBX contains the effective address of the SECS of the region to be
measured. The address must be the same as the one used to add the page
into the enclave.

.PP
RCX contains the effective address of the 256 byte region of an EPC page
to be measured. The DS segment is used to create linear addresses.
Segment override is not supported.

.SH EEXTEND MEMORY PARAMETER SEMANTICS  href="eextend.html#eextend-memory-parameter-semantics"
class="anchor">¶

.TS
allbox;
l 
l .
\fB\fP
EPC[RCX]
Read access by Enclave
.TE

.PP
The instruction faults if any of the following:

.SH EEXTEND FAULTING CONDITIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
T{
RBX points to an address not 4KBytes aligned.
T}	T{
RBX does not resolve to an SECS.
T}
T{
RBX does not point to an SECS page.
T}	T{
RBX does not point to the SECS page of the data chunk.
T}
T{
RCX points to an address not 256B aligned.
T}	T{
RCX points to an unused page or a SECS.
T}
T{
RCX does not resolve in an EPC page.
T}	If SECS is locked.
T{
If the SECS is already initialized.
T}	May page fault.
CPL &gt; 0.	
.TE

.SS CONCURRENCY RESTRICTIONS
.SS OPERATION
.SH TEMP VARIABLES IN EEXTEND OPERATIONAL FLOW  href="eextend.html#temp-variables-in-eextend-operational-flow"
class="anchor">¶

.TS
allbox;
l l l l 
l l l l .
\fBName\fP	\fBType\fP	\fBSize (Bits)\fP	\fBDescription\fP
TMP_SECS		64	T{
Physical address of SECS of the enclave to which source operand belongs.
T}
TMP_ENCLAVEOFFS ET	Enclave Offset	64	T{
The page displacement from the enclave base address.
T}
TMPUPDATEFIELD	SHA256 Buffer	512	T{
Buffer used to hold data being added to TMP_SECS.MRENCLAVE.
T}
.TE

.PP
TMP_MODE64 := ((IA32_EFER.LMA = 1) && (CS.L = 1));

.PP
IF (DS:RBX is not 4096 Byte Aligned)

.PP
THEN #GP(0); FI;

.PP
IF (DS:RBX does not resolve to an EPC page)

.PP
THEN #PF(DS:RBX); FI;

.PP
IF (DS:RCX is not 256Byte Aligned)

.PP
THEN #GP(0); FI;

.PP
IF (DS:RCX does not resolve within an EPC)

.PP
THEN #PF(DS:RCX); FI;

.PP
(* make sure no other Intel SGX instruction is accessing EPCM *)

.PP
IF (Other instructions accessing EPCM)

.PP
THEN #GP(0); FI;

.PP
IF (EPCM(DS:RCX). VALID = 0)

.PP
THEN #PF(DS:RCX); FI;

.PP
(* make sure that DS:RCX (DST) is pointing to a PT_REG or PT_TCS or
PT_SS_FIRST or PT_SS_REST *)

.PP
IF ( (EPCM(DS:RCX).PT ≠ PT_REG) and (EPCM(DS:RCX).PT ≠ PT_TCS)

.PP
and (EPCM(DS:RCX).PT ≠ PT_SS_FIRST) and (EPCM(DS:RCX).PT ≠
PT_SS_REST))

.PP
THEN #PF(DS:RCX); FI;

.PP
TMP_SECS := Get_SECS_ADDRESS();

.PP
IF (DS:RBX does not resolve to TMP_SECS)

.PP
THEN #GP(0); FI;

.PP
(* make sure no other instruction is accessing MRENCLAVE or
ATTRIBUTES.INIT *)

.PP
IF ( (Other instruction accessing MRENCLAVE) or (Other instructions
checking or updating the initialized state of the SECS))

.PP
THEN #GP(0); FI;

.PP
(* Calculate enclave offset *)

.PP
TMP_ENCLAVEOFFSET := EPCM(DS:RCX).ENCLAVEADDRESS - TMP_SECS.BASEADDR;

.PP
TMP_ENCLAVEOFFSET := TMP_ENCLAVEOFFSET + (DS:RCX & 0FFFH)

.PP
(* Add EEXTEND message and offset to MRENCLAVE *)

.PP
TMPUPDATEFIELD[63:0] := 00444E4554584545H; // “EEXTEND”

.PP
TMPUPDATEFIELD[127:64] := TMP_ENCLAVEOFFSET;

.PP
TMPUPDATEFIELD[511:128] := 0; // 48 bytes

.PP
TMP_SECS.MRENCLAVE := SHA256UPDATE(TMP_SECS.MRENCLAVE, TMPUPDATEFIELD)

.PP
INC enclave’s MRENCLAVE update counter;

.PP
(*Add 256 bytes to MRENCLAVE, 64 byte at a time *)

.PP
TMP_SECS.MRENCLAVE := SHA256UPDATE(TMP_SECS.MRENCLAVE, DS:RCX[511:0]
);

.PP
TMP_SECS.MRENCLAVE := SHA256UPDATE(TMP_SECS.MRENCLAVE, DS:RCX[1023:
512] );

.PP
TMP_SECS.MRENCLAVE := SHA256UPDATE(TMP_SECS.MRENCLAVE, DS:RCX[1535:
1024] );

.PP
TMP_SECS.MRENCLAVE := SHA256UPDATE(TMP_SECS.MRENCLAVE, DS:RCX[2047:
1536] );

.PP
INC enclave’s MRENCLAVE update counter by 4;

.SS FLAGS AFFECTED
None

.SS PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the address in RBX is outside the DS segment limit.
T}
	T{
If RBX points to an SECS page which is not the SECS of the data chunk.
T}
	T{
If the address in RCX is outside the DS segment limit.
T}
	T{
If RCX points to a memory location not 256Byte-aligned.
T}
	T{
If another instruction is accessing MRENCLAVE.
T}
	T{
If another instruction is checking or updating the SECS.
T}
	T{
If the enclave is already initialized.
T}
#PF(error	T{
code) If a page fault occurs in accessing memory operands.
T}
	T{
If the address in RBX points to a non-EPC page.
T}
	T{
If the address in RCX points to a page which is not PT_TCS or PT_REG.
T}
	T{
If the address in RCX points to a non-EPC page.
T}
	T{
If the address in RCX points to an invalid EPC page.
T}
.TE

.SS 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	If RBX is non-canonical form.
	T{
If RBX points to an SECS page which is not the SECS of the data chunk.
T}
	If RCX is non-canonical form.
	T{
If RCX points to a memory location not 256 Byte-aligned.
T}
	T{
If another instruction is accessing MRENCLAVE.
T}
	T{
If another instruction is checking or updating the SECS.
T}
	T{
If the enclave is already initialized.
T}
#PF(error	T{
code) If a page fault occurs in accessing memory operands.
T}
	T{
If the address in RBX points to a non-EPC page.
T}
	T{
If the address in RCX points to a page which is not PT_TCS or PT_REG.
T}
	T{
If the address in RCX points to a non-EPC page.
T}
	T{
If the address in RCX points to an invalid EPC page.
T}
.TE

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s
Manual
\[la]https://software.intel.com/en\-us/download/intel\-64\-and\-ia\-32\-architectures\-sdm\-combined\-volumes\-1\-2a\-2b\-2c\-2d\-3a\-3b\-3c\-3d\-and\-4\[ra]
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/MrQubo/x86-manpages.
